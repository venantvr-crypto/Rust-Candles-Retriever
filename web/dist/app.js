var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/pixi.js/lib/extensions/Extensions.mjs
var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
var init_Extensions = __esm({
  "node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
    "use strict";
    ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
      ExtensionType2["Application"] = "application";
      ExtensionType2["WebGLPipes"] = "webgl-pipes";
      ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
      ExtensionType2["WebGLSystem"] = "webgl-system";
      ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
      ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
      ExtensionType2["WebGPUSystem"] = "webgpu-system";
      ExtensionType2["CanvasSystem"] = "canvas-system";
      ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
      ExtensionType2["CanvasPipes"] = "canvas-pipes";
      ExtensionType2["Asset"] = "asset";
      ExtensionType2["LoadParser"] = "load-parser";
      ExtensionType2["ResolveParser"] = "resolve-parser";
      ExtensionType2["CacheParser"] = "cache-parser";
      ExtensionType2["DetectionParser"] = "detection-parser";
      ExtensionType2["MaskEffect"] = "mask-effect";
      ExtensionType2["BlendMode"] = "blend-mode";
      ExtensionType2["TextureSource"] = "texture-source";
      ExtensionType2["Environment"] = "environment";
      ExtensionType2["ShapeBuilder"] = "shape-builder";
      ExtensionType2["Batcher"] = "batcher";
      return ExtensionType2;
    })(ExtensionType || {});
    normalizeExtension = (ext) => {
      if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
        if (!ext.extension) {
          throw new Error("Extension class must have an extension object");
        }
        const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
        ext = { ...metadata, ref: ext };
      }
      if (typeof ext === "object") {
        ext = { ...ext };
      } else {
        throw new Error("Invalid extension type");
      }
      if (typeof ext.type === "string") {
        ext.type = [ext.type];
      }
      return ext;
    };
    normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
    extensions = {
      /** @ignore */
      _addHandlers: {},
      /** @ignore */
      _removeHandlers: {},
      /** @ignore */
      _queue: {},
      /**
       * Remove extensions from PixiJS.
       * @param extensions - Extensions to be removed. Can be:
       * - Extension class with static `extension` property
       * - Extension format object with `type` and `ref`
       * - Multiple extensions as separate arguments
       * @returns {extensions} this for chaining
       * @example
       * ```ts
       * // Remove a single extension
       * extensions.remove(MyRendererPlugin);
       *
       * // Remove multiple extensions
       * extensions.remove(
       *     MyRendererPlugin,
       *     MySystemPlugin
       * );
       * ```
       * @see {@link ExtensionType} For available extension types
       * @see {@link ExtensionFormat} For extension format details
       */
      remove(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
        });
        return this;
      },
      /**
       * Register new extensions with PixiJS. Extensions can be registered in multiple formats:
       * - As a class with a static `extension` property
       * - As an extension format object
       * - As multiple extensions passed as separate arguments
       * @param extensions - Extensions to add to PixiJS. Each can be:
       * - A class with static `extension` property
       * - An extension format object with `type` and `ref`
       * - Multiple extensions as separate arguments
       * @returns This extensions instance for chaining
       * @example
       * ```ts
       * // Register a simple extension
       * extensions.add(MyRendererPlugin);
       *
       * // Register multiple extensions
       * extensions.add(
       *     MyRendererPlugin,
       *     MySystemPlugin,
       * });
       * ```
       * @see {@link ExtensionType} For available extension types
       * @see {@link ExtensionFormat} For extension format details
       * @see {@link extensions.remove} For removing registered extensions
       */
      add(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type) => {
            const handlers = this._addHandlers;
            const queue = this._queue;
            if (!handlers[type]) {
              queue[type] = queue[type] || [];
              queue[type]?.push(ext);
            } else {
              handlers[type]?.(ext);
            }
          });
        });
        return this;
      },
      /**
       * Internal method to handle extensions by name.
       * @param type - The extension type.
       * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
       * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
       * @returns this for chaining.
       * @internal
       * @ignore
       */
      handle(type, onAdd, onRemove) {
        const addHandlers = this._addHandlers;
        const removeHandlers = this._removeHandlers;
        if (addHandlers[type] || removeHandlers[type]) {
          throw new Error(`Extension type ${type} already has a handler`);
        }
        addHandlers[type] = onAdd;
        removeHandlers[type] = onRemove;
        const queue = this._queue;
        if (queue[type]) {
          queue[type]?.forEach((ext) => onAdd(ext));
          delete queue[type];
        }
        return this;
      },
      /**
       * Handle a type, but using a map by `name` property.
       * @param type - Type of extension to handle.
       * @param map - The object map of named extensions.
       * @returns this for chaining.
       * @ignore
       */
      handleByMap(type, map) {
        return this.handle(
          type,
          (extension) => {
            if (extension.name) {
              map[extension.name] = extension.ref;
            }
          },
          (extension) => {
            if (extension.name) {
              delete map[extension.name];
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions with a `name` property.
       * @param type - Type of extension to handle.
       * @param map - The array of named extensions.
       * @param defaultPriority - Fallback priority if none is defined.
       * @returns this for chaining.
       * @ignore
       */
      handleByNamedList(type, map, defaultPriority = -1) {
        return this.handle(
          type,
          (extension) => {
            const index = map.findIndex((item) => item.name === extension.name);
            if (index >= 0)
              return;
            map.push({ name: extension.name, value: extension.ref });
            map.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
          },
          (extension) => {
            const index = map.findIndex((item) => item.name === extension.name);
            if (index !== -1) {
              map.splice(index, 1);
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions.
       * @param type - Type of extension to handle.
       * @param list - The list of extensions.
       * @param defaultPriority - The default priority to use if none is specified.
       * @returns this for chaining.
       * @ignore
       */
      handleByList(type, list, defaultPriority = -1) {
        return this.handle(
          type,
          (extension) => {
            if (list.includes(extension.ref)) {
              return;
            }
            list.push(extension.ref);
            list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
          },
          (extension) => {
            const index = list.indexOf(extension.ref);
            if (index !== -1) {
              list.splice(index, 1);
            }
          }
        );
      },
      /**
       * Mixin the source object(s) properties into the target class's prototype.
       * Copies all property descriptors from source objects to the target's prototype.
       * @param Target - The target class to mix properties into
       * @param sources - One or more source objects containing properties to mix in
       * @example
       * ```ts
       * // Create a mixin with shared properties
       * const moveable = {
       *     x: 0,
       *     y: 0,
       *     move(x: number, y: number) {
       *         this.x += x;
       *         this.y += y;
       *     }
       * };
       *
       * // Create a mixin with computed properties
       * const scalable = {
       *     scale: 1,
       *     get scaled() {
       *         return this.scale > 1;
       *     }
       * };
       *
       * // Apply mixins to a class
       * extensions.mixin(Sprite, moveable, scalable);
       *
       * // Use mixed-in properties
       * const sprite = new Sprite();
       * sprite.move(10, 20);
       * console.log(sprite.x, sprite.y); // 10, 20
       * ```
       * @remarks
       * - Copies all properties including getters/setters
       * - Does not modify source objects
       * - Preserves property descriptors
       * @see {@link Object.defineProperties} For details on property descriptors
       * @see {@link Object.getOwnPropertyDescriptors} For details on property copying
       */
      mixin(Target, ...sources2) {
        for (const source3 of sources2) {
          Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source3));
        }
      }
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/eventemitter3/index.mjs
var import_index, eventemitter3_default;
var init_eventemitter3 = __esm({
  "node_modules/eventemitter3/index.mjs"() {
    import_index = __toESM(require_eventemitter3(), 1);
    eventemitter3_default = import_index.default;
  }
});

// node_modules/@pixi/colord/index.mjs
var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
var init_colord = __esm({
  "node_modules/@pixi/colord/index.mjs"() {
    r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
    t = function(r2) {
      return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
    };
    n = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
    };
    e = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
    };
    u = function(r2) {
      return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
    };
    a = function(r2) {
      return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
    };
    o = function(r2) {
      return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
    };
    i = /^#([0-9a-f]{3,8})$/i;
    s = function(r2) {
      var t2 = r2.toString(16);
      return t2.length < 2 ? "0" + t2 : t2;
    };
    h = function(r2) {
      var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
      return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
    };
    b = function(r2) {
      var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
      t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
      var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
      return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
    };
    g = function(r2) {
      return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
    };
    d = function(r2) {
      return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
    };
    f = function(r2) {
      return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
      var t2, n2, e2;
    };
    c = function(r2) {
      return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
      var t2, n2, e2, u2;
    };
    l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    y = { string: [[function(r2) {
      var t2 = i.exec(r2);
      return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
    }, "hex"], [function(r2) {
      var t2 = v.exec(r2) || m.exec(r2);
      return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
    }, "rgb"], [function(t2) {
      var n2 = l.exec(t2) || p.exec(t2);
      if (!n2) return null;
      var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
      return f(a2);
    }, "hsl"]], object: [[function(r2) {
      var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
      return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
    }, "rgb"], [function(r2) {
      var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
      if (!t(n2) || !t(e2) || !t(u2)) return null;
      var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
      return f(i2);
    }, "hsl"], [function(r2) {
      var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
      if (!t(n2) || !t(a2) || !t(o2)) return null;
      var h2 = (function(r3) {
        return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
      })({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
      return b(h2);
    }, "hsv"]] };
    N = function(r2, t2) {
      for (var n2 = 0; n2 < t2.length; n2++) {
        var e2 = t2[n2][0](r2);
        if (e2) return [e2, t2[n2][1]];
      }
      return [null, void 0];
    };
    x = function(r2) {
      return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
    };
    M = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
    };
    H = function(r2) {
      return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
    };
    $ = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
    };
    j = (function() {
      function r2(r3) {
        this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
      }
      return r2.prototype.isValid = function() {
        return null !== this.parsed;
      }, r2.prototype.brightness = function() {
        return n(H(this.rgba), 2);
      }, r2.prototype.isDark = function() {
        return H(this.rgba) < 0.5;
      }, r2.prototype.isLight = function() {
        return H(this.rgba) >= 0.5;
      }, r2.prototype.toHex = function() {
        return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
        var r3, t2, e2, u2, a2, i2;
      }, r2.prototype.toRgb = function() {
        return o(this.rgba);
      }, r2.prototype.toRgbString = function() {
        return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
        var r3, t2, n2, e2, u2;
      }, r2.prototype.toHsl = function() {
        return d(c(this.rgba));
      }, r2.prototype.toHslString = function() {
        return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
        var r3, t2, n2, e2, u2;
      }, r2.prototype.toHsv = function() {
        return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
        var r3;
      }, r2.prototype.invert = function() {
        return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
        var r3;
      }, r2.prototype.saturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
      }, r2.prototype.desaturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
      }, r2.prototype.grayscale = function() {
        return w(M(this.rgba, -1));
      }, r2.prototype.lighten = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
      }, r2.prototype.darken = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
      }, r2.prototype.rotate = function(r3) {
        return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
      }, r2.prototype.alpha = function(r3) {
        return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
        var t2;
      }, r2.prototype.hue = function(r3) {
        var t2 = c(this.rgba);
        return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
      }, r2.prototype.isEqual = function(r3) {
        return this.toHex() === w(r3).toHex();
      }, r2;
    })();
    w = function(r2) {
      return r2 instanceof j ? r2 : new j(r2);
    };
    S = [];
    k = function(r2) {
      r2.forEach(function(r3) {
        S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
      });
    };
  }
});

// node_modules/@pixi/colord/plugins/names.mjs
function names_default(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a2) r2[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2) return n2;
    if (null == f3 ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}
var init_names = __esm({
  "node_modules/@pixi/colord/plugins/names.mjs"() {
  }
});

// node_modules/pixi.js/lib/color/Color.mjs
var _Color, Color;
var init_Color = __esm({
  "node_modules/pixi.js/lib/color/Color.mjs"() {
    init_colord();
    init_names();
    k([names_default]);
    _Color = class _Color2 {
      /**
       * @param {ColorSource} value - Optional value to use, if not provided, white is used.
       */
      constructor(value = 16777215) {
        this._value = null;
        this._components = new Float32Array(4);
        this._components.fill(1);
        this._int = 16777215;
        this.value = value;
      }
      /**
       * Get the red component of the color, normalized between 0 and 1.
       * @example
       * ```ts
       * const color = new Color('red');
       * console.log(color.red); // 1
       *
       * const green = new Color('#00ff00');
       * console.log(green.red); // 0
       * ```
       */
      get red() {
        return this._components[0];
      }
      /**
       * Get the green component of the color, normalized between 0 and 1.
       * @example
       * ```ts
       * const color = new Color('lime');
       * console.log(color.green); // 1
       *
       * const red = new Color('#ff0000');
       * console.log(red.green); // 0
       * ```
       */
      get green() {
        return this._components[1];
      }
      /**
       * Get the blue component of the color, normalized between 0 and 1.
       * @example
       * ```ts
       * const color = new Color('blue');
       * console.log(color.blue); // 1
       *
       * const yellow = new Color('#ffff00');
       * console.log(yellow.blue); // 0
       * ```
       */
      get blue() {
        return this._components[2];
      }
      /**
       * Get the alpha component of the color, normalized between 0 and 1.
       * @example
       * ```ts
       * const color = new Color('red');
       * console.log(color.alpha); // 1 (fully opaque)
       *
       * const transparent = new Color('rgba(255, 0, 0, 0.5)');
       * console.log(transparent.alpha); // 0.5 (semi-transparent)
       * ```
       */
      get alpha() {
        return this._components[3];
      }
      /**
       * Sets the color value and returns the instance for chaining.
       *
       * This is a chainable version of setting the `value` property.
       * @param value - The color to set. Accepts various formats:
       * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
       * - RGB/RGBA values (arrays, objects)
       * - CSS color names
       * - HSL/HSLA values
       * - HSV/HSVA values
       * @returns The Color instance for chaining
       * @example
       * ```ts
       * // Basic usage
       * const color = new Color();
       * color.setValue('#ff0000')
       *     .setAlpha(0.5)
       *     .premultiply(0.8);
       *
       * // Different formats
       * color.setValue(0xff0000);          // Hex number
       * color.setValue('#ff0000');         // Hex string
       * color.setValue([1, 0, 0]);         // RGB array
       * color.setValue([1, 0, 0, 0.5]);    // RGBA array
       * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object
       *
       * // Copy from another color
       * const red = new Color('red');
       * color.setValue(red);
       * ```
       * @throws {Error} If the color value is invalid or null
       * @see {@link Color.value} For the underlying value property
       */
      setValue(value) {
        this.value = value;
        return this;
      }
      /**
       * The current color source. This property allows getting and setting the color value
       * while preserving the original format where possible.
       * @remarks
       * When setting:
       * - Setting to a `Color` instance copies its source and components
       * - Setting to other valid sources normalizes and stores the value
       * - Setting to `null` throws an Error
       * - The color remains unchanged if normalization fails
       *
       * When getting:
       * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}
       * - Otherwise returns the original color source
       * @example
       * ```ts
       * // Setting different color formats
       * const color = new Color();
       *
       * color.value = 0xff0000;         // Hex number
       * color.value = '#ff0000';        // Hex string
       * color.value = [1, 0, 0];        // RGB array
       * color.value = [1, 0, 0, 0.5];   // RGBA array
       * color.value = { r: 1, g: 0, b: 0 }; // RGB object
       *
       * // Copying from another color
       * const red = new Color('red');
       * color.value = red;  // Copies red's components
       *
       * // Getting the value
       * console.log(color.value);  // Returns original format
       *
       * // After modifications
       * color.multiply([0.5, 0.5, 0.5]);
       * console.log(color.value);  // Returns null
       * ```
       * @throws {Error} When attempting to set `null`
       */
      set value(value) {
        if (value instanceof _Color2) {
          this._value = this._cloneSource(value._value);
          this._int = value._int;
          this._components.set(value._components);
        } else if (value === null) {
          throw new Error("Cannot set Color#value to null");
        } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
          this._value = this._cloneSource(value);
          this._normalize(this._value);
        }
      }
      get value() {
        return this._value;
      }
      /**
       * Copy a color source internally.
       * @param value - Color source
       */
      _cloneSource(value) {
        if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
          return value;
        } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
          return value.slice(0);
        } else if (typeof value === "object" && value !== null) {
          return { ...value };
        }
        return value;
      }
      /**
       * Equality check for color sources.
       * @param value1 - First color source
       * @param value2 - Second color source
       * @returns `true` if the color sources are equal, `false` otherwise.
       */
      _isSourceEqual(value1, value2) {
        const type1 = typeof value1;
        const type2 = typeof value2;
        if (type1 !== type2) {
          return false;
        } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
          return value1 === value2;
        } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
          if (value1.length !== value2.length) {
            return false;
          }
          return value1.every((v2, i2) => v2 === value2[i2]);
        } else if (value1 !== null && value2 !== null) {
          const keys1 = Object.keys(value1);
          const keys2 = Object.keys(value2);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keys1.every((key) => value1[key] === value2[key]);
        }
        return value1 === value2;
      }
      /**
       * Convert to a RGBA color object with normalized components (0-1).
       * @example
       * ```ts
       * import { Color } from 'pixi.js';
       *
       * // Convert colors to RGBA objects
       * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }
       * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }
       *
       * // With transparency
       * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }
       * ```
       * @returns An RGBA object with normalized components
       */
      toRgba() {
        const [r2, g2, b2, a2] = this._components;
        return { r: r2, g: g2, b: b2, a: a2 };
      }
      /**
       * Convert to a RGB color object with normalized components (0-1).
       *
       * Alpha component is omitted in the output.
       * @example
       * ```ts
       * import { Color } from 'pixi.js';
       *
       * // Convert colors to RGB objects
       * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }
       * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }
       *
       * // Alpha is ignored
       * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }
       * ```
       * @returns An RGB object with normalized components
       */
      toRgb() {
        const [r2, g2, b2] = this._components;
        return { r: r2, g: g2, b: b2 };
      }
      /**
       * Convert to a CSS-style rgba string representation.
       *
       * RGB components are scaled to 0-255 range, alpha remains 0-1.
       * @example
       * ```ts
       * import { Color } from 'pixi.js';
       *
       * // Convert colors to RGBA strings
       * new Color('white').toRgbaString();     // returns "rgba(255,255,255,1)"
       * new Color('#ff0000').toRgbaString();   // returns "rgba(255,0,0,1)"
       *
       * // With transparency
       * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns "rgba(255,0,0,0.5)"
       * ```
       * @returns A CSS-compatible rgba string
       */
      toRgbaString() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return `rgba(${r2},${g2},${b2},${this.alpha})`;
      }
      /**
       * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).
       * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,
       * a cached array will be used and returned.
       * @returns Array containing RGB components as integers between 0-255
       * @example
       * ```ts
       * // Basic usage
       * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]
       * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]
       *
       * // Using custom output array
       * const rgb = new Uint8Array(3);
       * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]
       *
       * // Using different array types
       * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]
       * new Color('red').toUint8RgbArray([]); // [255, 0, 0]
       * ```
       * @remarks
       * - Output values are always clamped between 0-255
       * - Alpha component is not included in output
       * - Reuses internal cache array if no output array provided
       */
      toUint8RgbArray(out2) {
        const [r2, g2, b2] = this._components;
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out2 || (out2 = this._arrayRgb);
        out2[0] = Math.round(r2 * 255);
        out2[1] = Math.round(g2 * 255);
        out2[2] = Math.round(b2 * 255);
        return out2;
      }
      /**
       * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).
       * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
       * a cached array will be used and returned.
       * @returns Array containing RGBA components as floats between 0-1
       * @example
       * ```ts
       * // Basic usage
       * new Color('white').toArray();  // returns [1, 1, 1, 1]
       * new Color('red').toArray();    // returns [1, 0, 0, 1]
       *
       * // With alpha
       * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]
       *
       * // Using custom output array
       * const rgba = new Float32Array(4);
       * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]
       * ```
       * @remarks
       * - Output values are normalized between 0-1
       * - Includes alpha component as the fourth value
       * - Reuses internal cache array if no output array provided
       */
      toArray(out2) {
        if (!this._arrayRgba) {
          this._arrayRgba = [];
        }
        out2 || (out2 = this._arrayRgba);
        const [r2, g2, b2, a2] = this._components;
        out2[0] = r2;
        out2[1] = g2;
        out2[2] = b2;
        out2[3] = a2;
        return out2;
      }
      /**
       * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
       * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
       * a cached array will be used and returned.
       * @returns Array containing RGB components as floats between 0-1
       * @example
       * ```ts
       * // Basic usage
       * new Color('white').toRgbArray(); // returns [1, 1, 1]
       * new Color('red').toRgbArray();   // returns [1, 0, 0]
       *
       * // Using custom output array
       * const rgb = new Float32Array(3);
       * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]
       * ```
       * @remarks
       * - Output values are normalized between 0-1
       * - Alpha component is omitted from output
       * - Reuses internal cache array if no output array provided
       */
      toRgbArray(out2) {
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out2 || (out2 = this._arrayRgb);
        const [r2, g2, b2] = this._components;
        out2[0] = r2;
        out2[1] = g2;
        out2[2] = b2;
        return out2;
      }
      /**
       * Convert to a hexadecimal number.
       * @returns The color as a 24-bit RGB integer
       * @example
       * ```ts
       * // Basic usage
       * new Color('white').toNumber(); // returns 0xffffff
       * new Color('red').toNumber();   // returns 0xff0000
       *
       * // Store as hex
       * const color = new Color('blue');
       * const hex = color.toNumber(); // 0x0000ff
       * ```
       */
      toNumber() {
        return this._int;
      }
      /**
       * Convert to a BGR number.
       *
       * Useful for platforms that expect colors in BGR format.
       * @returns The color as a 24-bit BGR integer
       * @example
       * ```ts
       * // Convert RGB to BGR
       * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
       *
       * // Common use case: platform-specific color format
       * const color = new Color('orange');
       * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels
       * ```
       * @remarks
       * This swaps the red and blue channels compared to the normal RGB format:
       * - RGB 0xRRGGBB becomes BGR 0xBBGGRR
       */
      toBgrNumber() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return (b2 << 16) + (g2 << 8) + r2;
      }
      /**
       * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
       *
       * Useful for platforms that expect colors in little endian byte order.
       * @example
       * ```ts
       * import { Color } from 'pixi.js';
       *
       * // Convert RGB color to little endian format
       * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
       *
       * // Common use cases:
       * const color = new Color('orange');
       * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems
       *
       * // Multiple conversions
       * const colors = {
       *     normal: 0xffcc99,
       *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff
       *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99
       * };
       * ```
       * @remarks
       * - Swaps R and B channels in the color value
       * - RGB 0xRRGGBB becomes 0xBBGGRR
       * - Useful for systems that use little endian byte order
       * - Can be used to convert back and forth between formats
       * @returns The color as a number in little endian format (BBGGRR)
       * @see {@link Color.toBgrNumber} For BGR format without byte swapping
       */
      toLittleEndianNumber() {
        const value = this._int;
        return (value >> 16) + (value & 65280) + ((value & 255) << 16);
      }
      /**
       * Multiply with another color.
       *
       * This action is destructive and modifies the original color.
       * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:
       * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
       * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])
       * - Color objects ({ r: 1, g: 0, b: 0 })
       * - CSS color names ('red', 'blue')
       * @returns this - The Color instance for chaining
       * @example
       * ```ts
       * // Basic multiplication
       * const color = new Color('#ff0000');
       * color.multiply(0x808080); // 50% darker red
       *
       * // With transparency
       * color.multiply([1, 1, 1, 0.5]); // 50% transparent
       *
       * // Chain operations
       * color
       *     .multiply('#808080')
       *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });
       * ```
       * @remarks
       * - Multiplies each RGB component and alpha separately
       * - Values are clamped between 0-1
       * - Original color format is lost (value becomes null)
       * - Operation cannot be undone
       */
      multiply(value) {
        const [r2, g2, b2, a2] = _Color2._temp.setValue(value)._components;
        this._components[0] *= r2;
        this._components[1] *= g2;
        this._components[2] *= b2;
        this._components[3] *= a2;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Converts color to a premultiplied alpha format.
       *
       * This action is destructive and modifies the original color.
       * @param alpha - The alpha value to multiply by (0-1)
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
       * @returns {Color} The Color instance for chaining
       * @example
       * ```ts
       * // Basic premultiplication
       * const color = new Color('red');
       * color.premultiply(0.5); // 50% transparent red with premultiplied RGB
       *
       * // Alpha only (RGB unchanged)
       * color.premultiply(0.5, false); // 50% transparent, original RGB
       *
       * // Chain with other operations
       * color
       *     .multiply(0x808080)
       *     .premultiply(0.5)
       *     .toNumber();
       * ```
       * @remarks
       * - RGB channels are multiplied by alpha when applyToRGB is true
       * - Alpha is always set to the provided value
       * - Values are clamped between 0-1
       * - Original color format is lost (value becomes null)
       * - Operation cannot be undone
       */
      premultiply(alpha, applyToRGB = true) {
        if (applyToRGB) {
          this._components[0] *= alpha;
          this._components[1] *= alpha;
          this._components[2] *= alpha;
        }
        this._components[3] = alpha;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Returns the color as a 32-bit premultiplied alpha integer.
       *
       * Format: 0xAARRGGBB
       * @param {number} alpha - The alpha value to multiply by (0-1)
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
       * @returns {number} The premultiplied color as a 32-bit integer
       * @example
       * ```ts
       * // Convert to premultiplied format
       * const color = new Color('red');
       *
       * // Full opacity (0xFFRRGGBB)
       * color.toPremultiplied(1.0); // 0xFFFF0000
       *
       * // 50% transparency with premultiplied RGB
       * color.toPremultiplied(0.5); // 0x7F7F0000
       *
       * // 50% transparency without RGB premultiplication
       * color.toPremultiplied(0.5, false); // 0x7FFF0000
       * ```
       * @remarks
       * - Returns full opacity (0xFF000000) when alpha is 1.0
       * - Returns 0 when alpha is 0.0 and applyToRGB is true
       * - RGB values are rounded during premultiplication
       */
      toPremultiplied(alpha, applyToRGB = true) {
        if (alpha === 1) {
          return (255 << 24) + this._int;
        }
        if (alpha === 0) {
          return applyToRGB ? 0 : this._int;
        }
        let r2 = this._int >> 16 & 255;
        let g2 = this._int >> 8 & 255;
        let b2 = this._int & 255;
        if (applyToRGB) {
          r2 = r2 * alpha + 0.5 | 0;
          g2 = g2 * alpha + 0.5 | 0;
          b2 = b2 * alpha + 0.5 | 0;
        }
        return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
      }
      /**
       * Convert to a hexadecimal string (6 characters).
       * @returns A CSS-compatible hex color string (e.g., "#ff0000")
       * @example
       * ```ts
       * import { Color } from 'pixi.js';
       *
       * // Basic colors
       * new Color('red').toHex();    // returns "#ff0000"
       * new Color('white').toHex();  // returns "#ffffff"
       * new Color('black').toHex();  // returns "#000000"
       *
       * // From different formats
       * new Color(0xff0000).toHex(); // returns "#ff0000"
       * new Color([1, 0, 0]).toHex(); // returns "#ff0000"
       * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns "#ff0000"
       * ```
       * @remarks
       * - Always returns a 6-character hex string
       * - Includes leading "#" character
       * - Alpha channel is ignored
       * - Values are rounded to nearest hex value
       */
      toHex() {
        const hexString = this._int.toString(16);
        return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
      }
      /**
       * Convert to a hexadecimal string with alpha (8 characters).
       * @returns A CSS-compatible hex color string with alpha (e.g., "#ff0000ff")
       * @example
       * ```ts
       * import { Color } from 'pixi.js';
       *
       * // Fully opaque colors
       * new Color('red').toHexa();   // returns "#ff0000ff"
       * new Color('white').toHexa(); // returns "#ffffffff"
       *
       * // With transparency
       * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns "#ff00007f"
       * new Color([1, 0, 0, 0]).toHexa(); // returns "#ff000000"
       * ```
       * @remarks
       * - Returns an 8-character hex string
       * - Includes leading "#" character
       * - Alpha is encoded in last two characters
       * - Values are rounded to nearest hex value
       */
      toHexa() {
        const alphaValue = Math.round(this._components[3] * 255);
        const alphaString = alphaValue.toString(16);
        return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
      }
      /**
       * Set alpha (transparency) value while preserving color components.
       *
       * Provides a chainable interface for setting alpha.
       * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)
       * @returns The Color instance for chaining
       * @example
       * ```ts
       * // Basic alpha setting
       * const color = new Color('red');
       * color.setAlpha(0.5);  // 50% transparent red
       *
       * // Chain with other operations
       * color
       *     .setValue('#ff0000')
       *     .setAlpha(0.8)    // 80% opaque
       *     .premultiply(0.5); // Further modify alpha
       *
       * // Reset to fully opaque
       * color.setAlpha(1);
       * ```
       * @remarks
       * - Alpha value is clamped between 0-1
       * - Can be chained with other color operations
       */
      setAlpha(alpha) {
        this._components[3] = this._clamp(alpha);
        return this;
      }
      /**
       * Normalize the input value into rgba
       * @param value - Input value
       */
      _normalize(value) {
        let r2;
        let g2;
        let b2;
        let a2;
        if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
          const int = value;
          r2 = (int >> 16 & 255) / 255;
          g2 = (int >> 8 & 255) / 255;
          b2 = (int & 255) / 255;
          a2 = 1;
        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value);
          [r2, g2, b2, a2 = 1] = value;
        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value, 0, 255);
          [r2, g2, b2, a2 = 255] = value;
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
          a2 /= 255;
        } else if (typeof value === "string" || typeof value === "object") {
          if (typeof value === "string") {
            const match = _Color2.HEX_PATTERN.exec(value);
            if (match) {
              value = `#${match[2]}`;
            }
          }
          const color = w(value);
          if (color.isValid()) {
            ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
          }
        }
        if (r2 !== void 0) {
          this._components[0] = r2;
          this._components[1] = g2;
          this._components[2] = b2;
          this._components[3] = a2;
          this._refreshInt();
        } else {
          throw new Error(`Unable to convert color ${value}`);
        }
      }
      /** Refresh the internal color rgb number */
      _refreshInt() {
        this._clamp(this._components);
        const [r2, g2, b2] = this._components;
        this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
      }
      /**
       * Clamps values to a range. Will override original values
       * @param value - Value(s) to clamp
       * @param min - Minimum value
       * @param max - Maximum value
       */
      _clamp(value, min = 0, max = 1) {
        if (typeof value === "number") {
          return Math.min(Math.max(value, min), max);
        }
        value.forEach((v2, i2) => {
          value[i2] = Math.min(Math.max(v2, min), max);
        });
        return value;
      }
      /**
       * Check if a value can be interpreted as a valid color format.
       * Supports all color formats that can be used with the Color class.
       * @param value - Value to check
       * @returns True if the value can be used as a color
       * @example
       * ```ts
       * import { Color } from 'pixi.js';
       *
       * // CSS colors and hex values
       * Color.isColorLike('red');          // true
       * Color.isColorLike('#ff0000');      // true
       * Color.isColorLike(0xff0000);       // true
       *
       * // Arrays (RGB/RGBA)
       * Color.isColorLike([1, 0, 0]);      // true
       * Color.isColorLike([1, 0, 0, 0.5]); // true
       *
       * // TypedArrays
       * Color.isColorLike(new Float32Array([1, 0, 0]));          // true
       * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true
       * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true
       *
       * // Object formats
       * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)
       * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)
       * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)
       * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)
       * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)
       * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)
       *
       * // Color instances
       * Color.isColorLike(new Color('red')); // true
       *
       * // Invalid values
       * Color.isColorLike(null);           // false
       * Color.isColorLike(undefined);      // false
       * Color.isColorLike({});             // false
       * Color.isColorLike([]);             // false
       * Color.isColorLike('not-a-color');  // false
       * ```
       * @remarks
       * Checks for the following formats:
       * - Numbers (0x000000 to 0xffffff)
       * - CSS color strings
       * - RGB/RGBA arrays and objects
       * - HSL/HSLA objects
       * - HSV/HSVA objects
       * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)
       * - Color instances
       * @see {@link ColorSource} For supported color format types
       * @see {@link Color.setValue} For setting color values
       * @category utility
       */
      static isColorLike(value) {
        return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color2 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
      }
    };
    _Color.shared = new _Color();
    _Color._temp = new _Color();
    _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    Color = _Color;
  }
});

// node_modules/pixi.js/lib/culling/cullingMixin.mjs
var cullingMixin;
var init_cullingMixin = __esm({
  "node_modules/pixi.js/lib/culling/cullingMixin.mjs"() {
    "use strict";
    cullingMixin = {
      cullArea: null,
      cullable: false,
      cullableChildren: true
    };
  }
});

// node_modules/pixi.js/lib/maths/misc/const.mjs
var PI_2, RAD_TO_DEG, DEG_TO_RAD;
var init_const = __esm({
  "node_modules/pixi.js/lib/maths/misc/const.mjs"() {
    "use strict";
    PI_2 = Math.PI * 2;
    RAD_TO_DEG = 180 / Math.PI;
    DEG_TO_RAD = Math.PI / 180;
  }
});

// node_modules/pixi.js/lib/maths/point/Point.mjs
var Point, tempPoint;
var init_Point = __esm({
  "node_modules/pixi.js/lib/maths/point/Point.mjs"() {
    "use strict";
    Point = class _Point {
      /**
       * Creates a new `Point`
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(x2 = 0, y2 = 0) {
        this.x = 0;
        this.y = 0;
        this.x = x2;
        this.y = y2;
      }
      /**
       * Creates a clone of this point, which is a new instance with the same `x` and `y` values.
       * @example
       * ```ts
       * // Basic point cloning
       * const original = new Point(100, 200);
       * const copy = original.clone();
       *
       * // Clone and modify
       * const modified = original.clone();
       * modified.set(300, 400);
       *
       * // Verify independence
       * console.log(original); // Point(100, 200)
       * console.log(modified); // Point(300, 400)
       * ```
       * @remarks
       * - Creates new Point instance
       * - Deep copies x and y values
       * - Independent from original
       * - Useful for preserving values
       * @returns A clone of this point
       * @see {@link Point.copyFrom} For copying into existing point
       * @see {@link Point.copyTo} For copying to existing point
       */
      clone() {
        return new _Point(this.x, this.y);
      }
      /**
       * Copies x and y from the given point into this point.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Point(100, 200);
       * const target = new Point();
       * target.copyFrom(source);
       *
       * // Copy and chain operations
       * const point = new Point()
       *     .copyFrom(source)
       *     .set(x + 50, y + 50);
       *
       * // Copy from any PointData
       * const data = { x: 10, y: 20 };
       * point.copyFrom(data);
       * ```
       * @param p - The point to copy from
       * @returns The point instance itself
       * @see {@link Point.copyTo} For copying to another point
       * @see {@link Point.clone} For creating new point copy
       */
      copyFrom(p2) {
        this.set(p2.x, p2.y);
        return this;
      }
      /**
       * Copies this point's x and y into the given point.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Point(100, 200);
       * const target = new Point();
       * source.copyTo(target);
       * ```
       * @param p - The point to copy to. Can be any type that is or extends `PointLike`
       * @returns The point (`p`) with values updated
       * @see {@link Point.copyFrom} For copying from another point
       * @see {@link Point.clone} For creating new point copy
       */
      copyTo(p2) {
        p2.set(this.x, this.y);
        return p2;
      }
      /**
       * Checks if another point is equal to this point.
       *
       * Compares x and y values using strict equality.
       * @example
       * ```ts
       * // Basic equality check
       * const p1 = new Point(100, 200);
       * const p2 = new Point(100, 200);
       * console.log(p1.equals(p2)); // true
       *
       * // Compare with PointData
       * const data = { x: 100, y: 200 };
       * console.log(p1.equals(data)); // true
       *
       * // Check different points
       * const p3 = new Point(200, 300);
       * console.log(p1.equals(p3)); // false
       * ```
       * @param p - The point to check
       * @returns `true` if both `x` and `y` are equal
       * @see {@link Point.copyFrom} For making points equal
       * @see {@link PointData} For point data interface
       */
      equals(p2) {
        return p2.x === this.x && p2.y === this.y;
      }
      /**
       * Sets the point to a new x and y position.
       *
       * If y is omitted, both x and y will be set to x.
       * @example
       * ```ts
       * // Basic position setting
       * const point = new Point();
       * point.set(100, 200);
       *
       * // Set both x and y to same value
       * point.set(50); // x=50, y=50
       *
       * // Chain with other operations
       * point
       *     .set(10, 20)
       *     .copyTo(otherPoint);
       * ```
       * @param x - Position on the x axis
       * @param y - Position on the y axis, defaults to x
       * @returns The point instance itself
       * @see {@link Point.copyFrom} For copying from another point
       * @see {@link Point.equals} For comparing positions
       */
      set(x2 = 0, y2 = x2) {
        this.x = x2;
        this.y = y2;
        return this;
      }
      toString() {
        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
      }
      /**
       * A static Point object with `x` and `y` values of `0`.
       *
       * This shared instance is reset to zero values when accessed.
       *
       * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.
       * @example
       * ```ts
       * // Use for temporary calculations
       * const tempPoint = Point.shared;
       * tempPoint.set(100, 200);
       * matrix.apply(tempPoint);
       *
       * // Will be reset to (0,0) on next access
       * const fresh = Point.shared; // x=0, y=0
       * ```
       * @readonly
       * @returns A fresh zeroed point for temporary use
       * @see {@link Point.constructor} For creating new points
       * @see {@link PointData} For basic point interface
       */
      static get shared() {
        tempPoint.x = 0;
        tempPoint.y = 0;
        return tempPoint;
      }
    };
    tempPoint = new Point();
  }
});

// node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
var Matrix, tempMatrix, identityMatrix;
var init_Matrix = __esm({
  "node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
    init_const();
    init_Point();
    Matrix = class _Matrix {
      /**
       * @param a - x scale
       * @param b - y skew
       * @param c - x skew
       * @param d - y scale
       * @param tx - x translation
       * @param ty - y translation
       */
      constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
        this.array = null;
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d2;
        this.tx = tx;
        this.ty = ty;
      }
      /**
       * Creates a Matrix object based on the given array.
       * Populates matrix components from a flat array in column-major order.
       *
       * > [!NOTE] Array mapping order:
       * > ```
       * > array[0] = a  (x scale)
       * > array[1] = b  (y skew)
       * > array[2] = tx (x translation)
       * > array[3] = c  (x skew)
       * > array[4] = d  (y scale)
       * > array[5] = ty (y translation)
       * > ```
       * @example
       * ```ts
       * // Create matrix from array
       * const matrix = new Matrix();
       * matrix.fromArray([
       *     2, 0,  100,  // a, b, tx
       *     0, 2,  100   // c, d, ty
       * ]);
       *
       * // Create matrix from typed array
       * const float32Array = new Float32Array([
       *     1, 0, 0,     // Scale x1, no skew
       *     0, 1, 0      // No skew, scale x1
       * ]);
       * matrix.fromArray(float32Array);
       * ```
       * @param array - The array to populate the matrix from
       * @see {@link Matrix.toArray} For converting matrix to array
       * @see {@link Matrix.set} For setting values directly
       */
      fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      }
      /**
       * Sets the matrix properties directly.
       * All matrix components can be set in one call.
       * @example
       * ```ts
       * // Set to identity matrix
       * matrix.set(1, 0, 0, 1, 0, 0);
       *
       * // Set to scale matrix
       * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x
       *
       * // Set to translation matrix
       * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50
       * ```
       * @param a - Scale on x axis
       * @param b - Shear on y axis
       * @param c - Shear on x axis
       * @param d - Scale on y axis
       * @param tx - Translation on x axis
       * @param ty - Translation on y axis
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.identity} For resetting to identity
       * @see {@link Matrix.fromArray} For setting from array
       */
      set(a2, b2, c2, d2, tx, ty) {
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d2;
        this.tx = tx;
        this.ty = ty;
        return this;
      }
      /**
       * Creates an array from the current Matrix object.
       *
       * > [!NOTE] The array format is:
       * > ```
       * > Non-transposed:
       * > [a, c, tx,
       * > b, d, ty,
       * > 0, 0, 1]
       * >
       * > Transposed:
       * > [a, b, 0,
       * > c, d, 0,
       * > tx,ty,1]
       * > ```
       * @example
       * ```ts
       * // Basic array conversion
       * const matrix = new Matrix(2, 0, 0, 2, 100, 100);
       * const array = matrix.toArray();
       *
       * // Using existing array
       * const float32Array = new Float32Array(9);
       * matrix.toArray(false, float32Array);
       *
       * // Get transposed array
       * const transposed = matrix.toArray(true);
       * ```
       * @param transpose - Whether to transpose the matrix
       * @param out - Optional Float32Array to store the result
       * @returns The array containing the matrix values
       * @see {@link Matrix.fromArray} For creating matrix from array
       * @see {@link Matrix.array} For cached array storage
       */
      toArray(transpose, out2) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        const array = out2 || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      }
      /**
       * Get a new position with the current transformation applied.
       *
       * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
       * @example
       * ```ts
       * // Basic point transformation
       * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
       * const point = new Point(10, 20);
       * const transformed = matrix.apply(point);
       *
       * // Reuse existing point
       * const output = new Point();
       * matrix.apply(point, output);
       * ```
       * @param pos - The origin point to transform
       * @param newPos - Optional point to store the result
       * @returns The transformed point
       * @see {@link Matrix.applyInverse} For inverse transformation
       * @see {@link Point} For point operations
       */
      apply(pos, newPos) {
        newPos = newPos || new Point();
        const x2 = pos.x;
        const y2 = pos.y;
        newPos.x = this.a * x2 + this.c * y2 + this.tx;
        newPos.y = this.b * x2 + this.d * y2 + this.ty;
        return newPos;
      }
      /**
       * Get a new position with the inverse of the current transformation applied.
       *
       * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
       * @example
       * ```ts
       * // Basic inverse transformation
       * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
       * const worldPoint = new Point(150, 100);
       * const localPoint = matrix.applyInverse(worldPoint);
       *
       * // Reuse existing point
       * const output = new Point();
       * matrix.applyInverse(worldPoint, output);
       *
       * // Convert mouse position to local space
       * const mousePoint = new Point(mouseX, mouseY);
       * const localMouse = matrix.applyInverse(mousePoint);
       * ```
       * @param pos - The origin point to inverse-transform
       * @param newPos - Optional point to store the result
       * @returns The inverse-transformed point
       * @see {@link Matrix.apply} For forward transformation
       * @see {@link Matrix.invert} For getting inverse matrix
       */
      applyInverse(pos, newPos) {
        newPos = newPos || new Point();
        const a2 = this.a;
        const b2 = this.b;
        const c2 = this.c;
        const d2 = this.d;
        const tx = this.tx;
        const ty = this.ty;
        const id = 1 / (a2 * d2 + c2 * -b2);
        const x2 = pos.x;
        const y2 = pos.y;
        newPos.x = d2 * id * x2 + -c2 * id * y2 + (ty * c2 - tx * d2) * id;
        newPos.y = a2 * id * y2 + -b2 * id * x2 + (-ty * a2 + tx * b2) * id;
        return newPos;
      }
      /**
       * Translates the matrix on the x and y axes.
       * Adds to the position values while preserving scale, rotation and skew.
       * @example
       * ```ts
       * // Basic translation
       * const matrix = new Matrix();
       * matrix.translate(100, 50); // Move right 100, down 50
       *
       * // Chain with other transformations
       * matrix
       *     .scale(2, 2)
       *     .translate(100, 0)
       *     .rotate(Math.PI / 4);
       * ```
       * @param x - How much to translate on the x axis
       * @param y - How much to translate on the y axis
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.set} For setting position directly
       * @see {@link Matrix.setTransform} For complete transform setup
       */
      translate(x2, y2) {
        this.tx += x2;
        this.ty += y2;
        return this;
      }
      /**
       * Applies a scale transformation to the matrix.
       * Multiplies the scale values with existing matrix components.
       * @example
       * ```ts
       * // Basic scaling
       * const matrix = new Matrix();
       * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically
       *
       * // Chain with other transformations
       * matrix
       *     .translate(100, 100)
       *     .scale(2, 2)     // Scales after translation
       *     .rotate(Math.PI / 4);
       * ```
       * @param x - The amount to scale horizontally
       * @param y - The amount to scale vertically
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.setTransform} For setting scale directly
       * @see {@link Matrix.append} For combining transformations
       */
      scale(x2, y2) {
        this.a *= x2;
        this.d *= y2;
        this.c *= x2;
        this.b *= y2;
        this.tx *= x2;
        this.ty *= y2;
        return this;
      }
      /**
       * Applies a rotation transformation to the matrix.
       *
       * Rotates around the origin (0,0) by the given angle in radians.
       * @example
       * ```ts
       * // Basic rotation
       * const matrix = new Matrix();
       * matrix.rotate(Math.PI / 4); // Rotate 45 degrees
       *
       * // Chain with other transformations
       * matrix
       *     .translate(100, 100) // Move to rotation center
       *     .rotate(Math.PI)     // Rotate 180 degrees
       *     .scale(2, 2);        // Scale after rotation
       *
       * // Common angles
       * matrix.rotate(Math.PI / 2);  // 90 degrees
       * matrix.rotate(Math.PI);      // 180 degrees
       * matrix.rotate(Math.PI * 2);  // 360 degrees
       * ```
       * @remarks
       * - Rotates around origin point (0,0)
       * - Affects position if translation was set
       * - Uses counter-clockwise rotation
       * - Order of operations matters when chaining
       * @param angle - The angle in radians
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.setTransform} For setting rotation directly
       * @see {@link Matrix.append} For combining transformations
       */
      rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const a1 = this.a;
        const c1 = this.c;
        const tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      }
      /**
       * Appends the given Matrix to this Matrix.
       * Combines two matrices by multiplying them together: this = this * matrix
       * @example
       * ```ts
       * // Basic matrix combination
       * const matrix = new Matrix();
       * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);
       * matrix.append(other);
       * ```
       * @remarks
       * - Order matters: A.append(B) !== B.append(A)
       * - Modifies current matrix
       * - Preserves transformation order
       * - Commonly used for combining transforms
       * @param matrix - The matrix to append
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.prepend} For prepending transformations
       * @see {@link Matrix.appendFrom} For appending two external matrices
       */
      append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      }
      /**
       * Appends two matrices and sets the result to this matrix.
       * Performs matrix multiplication: this = A * B
       * @example
       * ```ts
       * // Basic matrix multiplication
       * const result = new Matrix();
       * const matrixA = new Matrix().scale(2, 2);
       * const matrixB = new Matrix().rotate(Math.PI / 4);
       * result.appendFrom(matrixA, matrixB);
       * ```
       * @remarks
       * - Order matters: A * B !== B * A
       * - Creates a new transformation from two others
       * - More efficient than append() for multiple operations
       * - Does not modify input matrices
       * @param a - The first matrix to multiply
       * @param b - The second matrix to multiply
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.append} For single matrix combination
       * @see {@link Matrix.prepend} For reverse order multiplication
       */
      appendFrom(a2, b2) {
        const a1 = a2.a;
        const b1 = a2.b;
        const c1 = a2.c;
        const d1 = a2.d;
        const tx = a2.tx;
        const ty = a2.ty;
        const a22 = b2.a;
        const b22 = b2.b;
        const c2 = b2.c;
        const d2 = b2.d;
        this.a = a1 * a22 + b1 * c2;
        this.b = a1 * b22 + b1 * d2;
        this.c = c1 * a22 + d1 * c2;
        this.d = c1 * b22 + d1 * d2;
        this.tx = tx * a22 + ty * c2 + b2.tx;
        this.ty = tx * b22 + ty * d2 + b2.ty;
        return this;
      }
      /**
       * Sets the matrix based on all the available properties.
       * Combines position, scale, rotation, skew and pivot in a single operation.
       * @example
       * ```ts
       * // Basic transform setup
       * const matrix = new Matrix();
       * matrix.setTransform(
       *     100, 100,    // position
       *     0, 0,        // pivot
       *     2, 2,        // scale
       *     Math.PI / 4, // rotation (45 degrees)
       *     0, 0         // skew
       * );
       * ```
       * @remarks
       * - Updates all matrix components at once
       * - More efficient than separate transform calls
       * - Uses radians for rotation and skew
       * - Pivot affects rotation center
       * @param x - Position on the x axis
       * @param y - Position on the y axis
       * @param pivotX - Pivot on the x axis
       * @param pivotY - Pivot on the y axis
       * @param scaleX - Scale on the x axis
       * @param scaleY - Scale on the y axis
       * @param rotation - Rotation in radians
       * @param skewX - Skew on the x axis
       * @param skewY - Skew on the y axis
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.decompose} For extracting transform properties
       * @see {@link TransformableObject} For transform data structure
       */
      setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x2 - (pivotX * this.a + pivotY * this.c);
        this.ty = y2 - (pivotX * this.b + pivotY * this.d);
        return this;
      }
      /**
       * Prepends the given Matrix to this Matrix.
       * Combines two matrices by multiplying them together: this = matrix * this
       * @example
       * ```ts
       * // Basic matrix prepend
       * const matrix = new Matrix().scale(2, 2);
       * const other = new Matrix().translate(100, 0);
       * matrix.prepend(other); // Translation happens before scaling
       * ```
       * @remarks
       * - Order matters: A.prepend(B) !== B.prepend(A)
       * - Modifies current matrix
       * - Reverses transformation order compared to append()
       * @param matrix - The matrix to prepend
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.append} For appending transformations
       * @see {@link Matrix.appendFrom} For combining external matrices
       */
      prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          const a1 = this.a;
          const c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      }
      /**
       * Decomposes the matrix into its individual transform components.
       * Extracts position, scale, rotation and skew values from the matrix.
       * @example
       * ```ts
       * // Basic decomposition
       * const matrix = new Matrix()
       *     .translate(100, 100)
       *     .rotate(Math.PI / 4)
       *     .scale(2, 2);
       *
       * const transform = {
       *     position: new Point(),
       *     scale: new Point(),
       *     pivot: new Point(),
       *     skew: new Point(),
       *     rotation: 0
       * };
       *
       * matrix.decompose(transform);
       * console.log(transform.position); // Point(100, 100)
       * console.log(transform.rotation); // ~0.785 (PI/4)
       * console.log(transform.scale); // Point(2, 2)
       * ```
       * @remarks
       * - Handles combined transformations
       * - Accounts for pivot points
       * - Chooses between rotation/skew based on transform type
       * - Uses radians for rotation and skew
       * @param transform - The transform object to store the decomposed values
       * @returns The transform with the newly applied properties
       * @see {@link Matrix.setTransform} For composing from components
       * @see {@link TransformableObject} For transform structure
       */
      decompose(transform) {
        const a2 = this.a;
        const b2 = this.b;
        const c2 = this.c;
        const d2 = this.d;
        const pivot = transform.pivot;
        const skewX = -Math.atan2(-c2, d2);
        const skewY = Math.atan2(b2, a2);
        const delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform.rotation = skewY;
          transform.skew.x = transform.skew.y = 0;
        } else {
          transform.rotation = 0;
          transform.skew.x = skewX;
          transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
        transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
        transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
        transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
        return transform;
      }
      /**
       * Inverts this matrix.
       * Creates the matrix that when multiplied with this matrix results in an identity matrix.
       * @example
       * ```ts
       * // Basic matrix inversion
       * const matrix = new Matrix()
       *     .translate(100, 50)
       *     .scale(2, 2);
       *
       * matrix.invert(); // Now transforms in opposite direction
       *
       * // Verify inversion
       * const point = new Point(50, 50);
       * const transformed = matrix.apply(point);
       * const original = matrix.invert().apply(transformed);
       * // original ≈ point
       * ```
       * @remarks
       * - Modifies the current matrix
       * - Useful for reversing transformations
       * - Cannot invert matrices with zero determinant
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.identity} For resetting to identity
       * @see {@link Matrix.applyInverse} For inverse transformations
       */
      invert() {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        const tx1 = this.tx;
        const n2 = a1 * d1 - b1 * c1;
        this.a = d1 / n2;
        this.b = -b1 / n2;
        this.c = -c1 / n2;
        this.d = a1 / n2;
        this.tx = (c1 * this.ty - d1 * tx1) / n2;
        this.ty = -(a1 * this.ty - b1 * tx1) / n2;
        return this;
      }
      /**
       * Checks if this matrix is an identity matrix.
       *
       * An identity matrix has no transformations applied (default state).
       * @example
       * ```ts
       * // Check if matrix is identity
       * const matrix = new Matrix();
       * console.log(matrix.isIdentity()); // true
       *
       * // Check after transformations
       * matrix.translate(100, 0);
       * console.log(matrix.isIdentity()); // false
       *
       * // Reset and verify
       * matrix.identity();
       * console.log(matrix.isIdentity()); // true
       * ```
       * @remarks
       * - Verifies a = 1, d = 1 (no scale)
       * - Verifies b = 0, c = 0 (no skew)
       * - Verifies tx = 0, ty = 0 (no translation)
       * @returns True if matrix has no transformations
       * @see {@link Matrix.identity} For resetting to identity
       * @see {@link Matrix.IDENTITY} For constant identity matrix
       */
      isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
      }
      /**
       * Resets this Matrix to an identity (default) matrix.
       * Sets all components to their default values: scale=1, no skew, no translation.
       * @example
       * ```ts
       * // Reset transformed matrix
       * const matrix = new Matrix()
       *     .scale(2, 2)
       *     .rotate(Math.PI / 4);
       * matrix.identity(); // Back to default state
       *
       * // Chain after reset
       * matrix
       *     .identity()
       *     .translate(100, 100)
       *     .scale(2, 2);
       *
       * // Compare with identity constant
       * const isDefault = matrix.equals(Matrix.IDENTITY);
       * ```
       * @remarks
       * - Sets a=1, d=1 (default scale)
       * - Sets b=0, c=0 (no skew)
       * - Sets tx=0, ty=0 (no translation)
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.IDENTITY} For constant identity matrix
       * @see {@link Matrix.isIdentity} For checking identity state
       */
      identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      }
      /**
       * Creates a new Matrix object with the same values as this one.
       * @returns A copy of this matrix. Good for chaining method calls.
       */
      clone() {
        const matrix = new _Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Creates a new Matrix object with the same values as this one.
       * @param matrix
       * @example
       * ```ts
       * // Basic matrix cloning
       * const matrix = new Matrix()
       *     .translate(100, 100)
       *     .rotate(Math.PI / 4);
       * const copy = matrix.clone();
       *
       * // Clone and modify
       * const modified = matrix.clone()
       *     .scale(2, 2);
       *
       * // Compare matrices
       * console.log(matrix.equals(copy));     // true
       * console.log(matrix.equals(modified)); // false
       * ```
       * @returns A copy of this matrix. Good for chaining method calls.
       * @see {@link Matrix.copyTo} For copying to existing matrix
       * @see {@link Matrix.copyFrom} For copying from another matrix
       */
      copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the matrix to be the same as the ones in given matrix.
       * @example
       * ```ts
       * // Basic matrix copying
       * const source = new Matrix()
       *     .translate(100, 100)
       *     .rotate(Math.PI / 4);
       * const target = new Matrix();
       * target.copyFrom(source);
       * ```
       * @param matrix - The matrix to copy from
       * @returns This matrix. Good for chaining method calls.
       * @see {@link Matrix.clone} For creating new matrix copy
       * @see {@link Matrix.copyTo} For copying to another matrix
       */
      copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      }
      /**
       * Checks if this matrix equals another matrix.
       * Compares all components for exact equality.
       * @example
       * ```ts
       * // Basic equality check
       * const m1 = new Matrix();
       * const m2 = new Matrix();
       * console.log(m1.equals(m2)); // true
       *
       * // Compare transformed matrices
       * const transform = new Matrix()
       *     .translate(100, 100)
       * const clone = new Matrix()
       *     .scale(2, 2);
       * console.log(transform.equals(clone)); // false
       * ```
       * @param matrix - The matrix to compare to
       * @returns True if matrices are identical
       * @see {@link Matrix.copyFrom} For copying matrix values
       * @see {@link Matrix.isIdentity} For identity comparison
       */
      equals(matrix) {
        return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
      }
      toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      }
      /**
       * A default (identity) matrix with no transformations applied.
       *
       * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.
       * @example
       * ```ts
       * // Get identity matrix reference
       * const identity = Matrix.IDENTITY;
       * console.log(identity.isIdentity()); // true
       *
       * // Compare with identity
       * const matrix = new Matrix();
       * console.log(matrix.equals(Matrix.IDENTITY)); // true
       *
       * // Create new matrix instead of modifying IDENTITY
       * const transform = new Matrix()
       *     .copyFrom(Matrix.IDENTITY)
       *     .translate(100, 100);
       * ```
       * @readonly
       * @returns A read-only identity matrix
       * @see {@link Matrix.shared} For temporary calculations
       * @see {@link Matrix.identity} For resetting matrices
       */
      static get IDENTITY() {
        return identityMatrix.identity();
      }
      /**
       * A static Matrix that can be used to avoid creating new objects.
       * Will always ensure the matrix is reset to identity when requested.
       *
       * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.
       * @example
       * ```ts
       * // Use for temporary calculations
       * const tempMatrix = Matrix.shared;
       * tempMatrix.translate(100, 100).rotate(Math.PI / 4);
       * const point = tempMatrix.apply({ x: 10, y: 20 });
       *
       * // Will be reset to identity on next access
       * const fresh = Matrix.shared; // Back to identity
       * ```
       * @remarks
       * - Always returns identity matrix
       * - Safe to modify temporarily
       * - Not safe to store references
       * - Useful for one-off calculations
       * @readonly
       * @returns A fresh identity matrix for temporary use
       * @see {@link Matrix.IDENTITY} For immutable identity matrix
       * @see {@link Matrix.identity} For resetting matrices
       */
      static get shared() {
        return tempMatrix.identity();
      }
    };
    tempMatrix = new Matrix();
    identityMatrix = new Matrix();
  }
});

// node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
var ObservablePoint;
var init_ObservablePoint = __esm({
  "node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
    "use strict";
    ObservablePoint = class _ObservablePoint {
      /**
       * Creates a new `ObservablePoint`
       * @param observer - Observer to pass to listen for change events.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(observer, x2, y2) {
        this._x = x2 || 0;
        this._y = y2 || 0;
        this._observer = observer;
      }
      /**
       * Creates a clone of this point.
       * @example
       * ```ts
       * // Basic cloning
       * const point = new ObservablePoint(observer, 100, 200);
       * const copy = point.clone();
       *
       * // Clone with new observer
       * const newObserver = {
       *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)
       * };
       * const watched = point.clone(newObserver);
       *
       * // Verify independence
       * watched.set(300, 400); // Only triggers new observer
       * ```
       * @param observer - Optional observer to pass to the new observable point
       * @returns A copy of this observable point
       * @see {@link ObservablePoint.copyFrom} For copying into existing point
       * @see {@link Observer} For observer interface details
       */
      clone(observer) {
        return new _ObservablePoint(observer ?? this._observer, this._x, this._y);
      }
      /**
       * Sets the point to a new x and y position.
       *
       * If y is omitted, both x and y will be set to x.
       * @example
       * ```ts
       * // Basic position setting
       * const point = new ObservablePoint(observer);
       * point.set(100, 200);
       *
       * // Set both x and y to same value
       * point.set(50); // x=50, y=50
       * ```
       * @param x - Position on the x axis
       * @param y - Position on the y axis, defaults to x
       * @returns The point instance itself
       * @see {@link ObservablePoint.copyFrom} For copying from another point
       * @see {@link ObservablePoint.equals} For comparing positions
       */
      set(x2 = 0, y2 = x2) {
        if (this._x !== x2 || this._y !== y2) {
          this._x = x2;
          this._y = y2;
          this._observer._onUpdate(this);
        }
        return this;
      }
      /**
       * Copies x and y from the given point into this point.
       * @example
       * ```ts
       * // Basic copying
       * const source = new ObservablePoint(observer, 100, 200);
       * const target = new ObservablePoint();
       * target.copyFrom(source);
       *
       * // Copy and chain operations
       * const point = new ObservablePoint()
       *     .copyFrom(source)
       *     .set(x + 50, y + 50);
       *
       * // Copy from any PointData
       * const data = { x: 10, y: 20 };
       * point.copyFrom(data);
       * ```
       * @param p - The point to copy from
       * @returns The point instance itself
       * @see {@link ObservablePoint.copyTo} For copying to another point
       * @see {@link ObservablePoint.clone} For creating new point copy
       */
      copyFrom(p2) {
        if (this._x !== p2.x || this._y !== p2.y) {
          this._x = p2.x;
          this._y = p2.y;
          this._observer._onUpdate(this);
        }
        return this;
      }
      /**
       * Copies this point's x and y into the given point.
       * @example
       * ```ts
       * // Basic copying
       * const source = new ObservablePoint(100, 200);
       * const target = new ObservablePoint();
       * source.copyTo(target);
       * ```
       * @param p - The point to copy to. Can be any type that is or extends `PointLike`
       * @returns The point (`p`) with values updated
       * @see {@link ObservablePoint.copyFrom} For copying from another point
       * @see {@link ObservablePoint.clone} For creating new point copy
       */
      copyTo(p2) {
        p2.set(this._x, this._y);
        return p2;
      }
      /**
       * Checks if another point is equal to this point.
       *
       * Compares x and y values using strict equality.
       * @example
       * ```ts
       * // Basic equality check
       * const p1 = new ObservablePoint(100, 200);
       * const p2 = new ObservablePoint(100, 200);
       * console.log(p1.equals(p2)); // true
       *
       * // Compare with PointData
       * const data = { x: 100, y: 200 };
       * console.log(p1.equals(data)); // true
       *
       * // Check different points
       * const p3 = new ObservablePoint(200, 300);
       * console.log(p1.equals(p3)); // false
       * ```
       * @param p - The point to check
       * @returns `true` if both `x` and `y` are equal
       * @see {@link ObservablePoint.copyFrom} For making points equal
       * @see {@link PointData} For point data interface
       */
      equals(p2) {
        return p2.x === this._x && p2.y === this._y;
      }
      toString() {
        return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
      }
      /**
       * Position of the observable point on the x axis.
       * Triggers observer callback when value changes.
       * @example
       * ```ts
       * // Basic x position
       * const point = new ObservablePoint(observer);
       * point.x = 100; // Triggers observer
       *
       * // Use in calculations
       * const width = rightPoint.x - leftPoint.x;
       * ```
       * @default 0
       */
      get x() {
        return this._x;
      }
      set x(value) {
        if (this._x !== value) {
          this._x = value;
          this._observer._onUpdate(this);
        }
      }
      /**
       * Position of the observable point on the y axis.
       * Triggers observer callback when value changes.
       * @example
       * ```ts
       * // Basic y position
       * const point = new ObservablePoint(observer);
       * point.y = 200; // Triggers observer
       *
       * // Use in calculations
       * const height = bottomPoint.y - topPoint.y;
       * ```
       * @default 0
       */
      get y() {
        return this._y;
      }
      set y(value) {
        if (this._y !== value) {
          this._y = value;
          this._observer._onUpdate(this);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/data/uid.mjs
function uid(name = "default") {
  if (uidCache[name] === void 0) {
    uidCache[name] = -1;
  }
  return ++uidCache[name];
}
var uidCache;
var init_uid = __esm({
  "node_modules/pixi.js/lib/utils/data/uid.mjs"() {
    "use strict";
    uidCache = {
      default: -1
    };
  }
});

// node_modules/pixi.js/lib/utils/logging/deprecation.mjs
var warnings, v8_0_0, v8_3_4, deprecationState, deprecation;
var init_deprecation = __esm({
  "node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
    "use strict";
    warnings = /* @__PURE__ */ new Set();
    v8_0_0 = "8.0.0";
    v8_3_4 = "8.3.4";
    deprecationState = {
      quiet: false,
      noColor: false
    };
    deprecation = (version, message, ignoreDepth = 3) => {
      if (deprecationState.quiet || warnings.has(message))
        return;
      let stack = new Error().stack;
      const deprecationMessage = `${message}
Deprecated since v${version}`;
      const useGroup = typeof console.groupCollapsed === "function" && !deprecationState.noColor;
      if (typeof stack === "undefined") {
        console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
      } else {
        stack = stack.split("\n").splice(ignoreDepth).join("\n");
        if (useGroup) {
          console.groupCollapsed(
            "%cPixiJS Deprecation Warning: %c%s",
            "color:#614108;background:#fffbe6",
            "font-weight:normal;color:#614108;background:#fffbe6",
            deprecationMessage
          );
          console.warn(stack);
          console.groupEnd();
        } else {
          console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
          console.warn(stack);
        }
      }
      warnings.add(message);
    };
    Object.defineProperties(deprecation, {
      quiet: {
        get: () => deprecationState.quiet,
        set: (value) => {
          deprecationState.quiet = value;
        },
        enumerable: true,
        configurable: false
      },
      noColor: {
        get: () => deprecationState.noColor,
        set: (value) => {
          deprecationState.noColor = value;
        },
        enumerable: true,
        configurable: false
      }
    });
  }
});

// node_modules/pixi.js/lib/utils/logging/warn.mjs
function warn(...args) {
  if (warnCount === maxWarnings)
    return;
  warnCount++;
  if (warnCount === maxWarnings) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}
var warnCount, maxWarnings;
var init_warn = __esm({
  "node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
    "use strict";
    warnCount = 0;
    maxWarnings = 500;
  }
});

// node_modules/pixi.js/lib/utils/pool/GlobalResourceRegistry.mjs
var GlobalResourceRegistry;
var init_GlobalResourceRegistry = __esm({
  "node_modules/pixi.js/lib/utils/pool/GlobalResourceRegistry.mjs"() {
    "use strict";
    GlobalResourceRegistry = {
      /**
       * Set of registered pools and cleanable objects.
       * @private
       */
      _registeredResources: /* @__PURE__ */ new Set(),
      /**
       * Registers a pool or cleanable object for cleanup.
       * @param {Cleanable} pool - The pool or object to register.
       */
      register(pool) {
        this._registeredResources.add(pool);
      },
      /**
       * Unregisters a pool or cleanable object from cleanup.
       * @param {Cleanable} pool - The pool or object to unregister.
       */
      unregister(pool) {
        this._registeredResources.delete(pool);
      },
      /** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */
      release() {
        this._registeredResources.forEach((pool) => pool.clear());
      },
      /**
       * Gets the number of registered pools and cleanable objects.
       * @returns {number} The count of registered items.
       */
      get registeredCount() {
        return this._registeredResources.size;
      },
      /**
       * Checks if a specific pool or cleanable object is registered.
       * @param {Cleanable} pool - The pool or object to check.
       * @returns {boolean} True if the item is registered, false otherwise.
       */
      isRegistered(pool) {
        return this._registeredResources.has(pool);
      },
      /**
       * Removes all registrations without clearing the pools.
       * Useful if you want to reset the collector without affecting the pools.
       */
      reset() {
        this._registeredResources.clear();
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/pool/Pool.mjs
var Pool;
var init_Pool = __esm({
  "node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
    "use strict";
    Pool = class {
      /**
       * Constructs a new Pool.
       * @param ClassType - The constructor of the items in the pool.
       * @param {number} [initialSize] - The initial size of the pool.
       */
      constructor(ClassType, initialSize) {
        this._pool = [];
        this._count = 0;
        this._index = 0;
        this._classType = ClassType;
        if (initialSize) {
          this.prepopulate(initialSize);
        }
      }
      /**
       * Prepopulates the pool with a given number of items.
       * @param total - The number of items to add to the pool.
       */
      prepopulate(total) {
        for (let i2 = 0; i2 < total; i2++) {
          this._pool[this._index++] = new this._classType();
        }
        this._count += total;
      }
      /**
       * Gets an item from the pool. Calls the item's `init` method if it exists.
       * If there are no items left in the pool, a new one will be created.
       * @param {unknown} [data] - Optional data to pass to the item's constructor.
       * @returns {T} The item from the pool.
       */
      get(data) {
        let item;
        if (this._index > 0) {
          item = this._pool[--this._index];
        } else {
          item = new this._classType();
        }
        item.init?.(data);
        return item;
      }
      /**
       * Returns an item to the pool. Calls the item's `reset` method if it exists.
       * @param {T} item - The item to return to the pool.
       */
      return(item) {
        item.reset?.();
        this._pool[this._index++] = item;
      }
      /**
       * Gets the number of items in the pool.
       * @readonly
       */
      get totalSize() {
        return this._count;
      }
      /**
       * Gets the number of items in the pool that are free to use without needing to create more.
       * @readonly
       */
      get totalFree() {
        return this._index;
      }
      /**
       * Gets the number of items in the pool that are currently in use.
       * @readonly
       */
      get totalUsed() {
        return this._count - this._index;
      }
      /** clears the pool */
      clear() {
        if (this._pool.length > 0 && this._pool[0].destroy) {
          for (let i2 = 0; i2 < this._index; i2++) {
            this._pool[i2].destroy();
          }
        }
        this._pool.length = 0;
        this._count = 0;
        this._index = 0;
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
var PoolGroupClass, BigPool;
var init_PoolGroup = __esm({
  "node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
    init_GlobalResourceRegistry();
    init_Pool();
    PoolGroupClass = class {
      constructor() {
        this._poolsByClass = /* @__PURE__ */ new Map();
      }
      /**
       * Prepopulates a specific pool with a given number of items.
       * @template T The type of items in the pool. Must extend PoolItem.
       * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
       * @param {number} total - The number of items to add to the pool.
       */
      prepopulate(Class, total) {
        const classPool = this.getPool(Class);
        classPool.prepopulate(total);
      }
      /**
       * Gets an item from a specific pool.
       * @template T The type of items in the pool. Must extend PoolItem.
       * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
       * @param {unknown} [data] - Optional data to pass to the item's constructor.
       * @returns {T} The item from the pool.
       */
      get(Class, data) {
        const pool = this.getPool(Class);
        return pool.get(data);
      }
      /**
       * Returns an item to its respective pool.
       * @param {PoolItem} item - The item to return to the pool.
       */
      return(item) {
        const pool = this.getPool(item.constructor);
        pool.return(item);
      }
      /**
       * Gets a specific pool based on the class type.
       * @template T The type of items in the pool. Must extend PoolItem.
       * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
       * @returns {Pool<T>} The pool of the given class type.
       */
      getPool(ClassType) {
        if (!this._poolsByClass.has(ClassType)) {
          this._poolsByClass.set(ClassType, new Pool(ClassType));
        }
        return this._poolsByClass.get(ClassType);
      }
      /** gets the usage stats of each pool in the system */
      stats() {
        const stats = {};
        this._poolsByClass.forEach((pool) => {
          const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
          stats[name] = {
            free: pool.totalFree,
            used: pool.totalUsed,
            size: pool.totalSize
          };
        });
        return stats;
      }
      /** Clears all pools in the group. This will reset all pools and free their resources. */
      clear() {
        this._poolsByClass.forEach((pool) => pool.clear());
        this._poolsByClass.clear();
      }
    };
    BigPool = new PoolGroupClass();
    GlobalResourceRegistry.register(BigPool);
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs
var cacheAsTextureMixin;
var init_cacheAsTextureMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs"() {
    init_deprecation();
    cacheAsTextureMixin = {
      get isCachedAsTexture() {
        return !!this.renderGroup?.isCachedAsTexture;
      },
      cacheAsTexture(val) {
        if (typeof val === "boolean" && val === false) {
          this.disableRenderGroup();
        } else {
          this.enableRenderGroup();
          this.renderGroup.enableCacheAsTexture(val === true ? {} : val);
        }
      },
      updateCacheTexture() {
        this.renderGroup?.updateCacheTexture();
      },
      get cacheAsBitmap() {
        return this.isCachedAsTexture;
      },
      set cacheAsBitmap(val) {
        deprecation("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead.");
        this.cacheAsTexture(val);
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/data/removeItems.mjs
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i2;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i2 = startIdx; i2 < len; ++i2) {
    arr[i2] = arr[i2 + removeCount];
  }
  arr.length = len;
}
var init_removeItems = __esm({
  "node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
var childrenHelperMixin;
var init_childrenHelperMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
    init_removeItems();
    init_deprecation();
    childrenHelperMixin = {
      allowChildren: true,
      removeChildren(beginIndex = 0, endIndex) {
        const end = endIndex ?? this.children.length;
        const range = end - beginIndex;
        const removed = [];
        if (range > 0 && range <= end) {
          for (let i2 = end - 1; i2 >= beginIndex; i2--) {
            const child = this.children[i2];
            if (!child)
              continue;
            removed.push(child);
            child.parent = null;
          }
          removeItems(this.children, beginIndex, end);
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.removeChildren(removed);
          }
          for (let i2 = 0; i2 < removed.length; ++i2) {
            const child = removed[i2];
            child.parentRenderLayer?.detach(child);
            this.emit("childRemoved", child, this, i2);
            removed[i2].emit("removed", this);
          }
          if (removed.length > 0) {
            this._didViewChangeTick++;
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return removed;
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      },
      removeChildAt(index) {
        const child = this.getChildAt(index);
        return this.removeChild(child);
      },
      getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`getChildAt: Index (${index}) does not exist.`);
        }
        return this.children[index];
      },
      setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
        }
        this.getChildIndex(child);
        this.addChildAt(child, index);
      },
      getChildIndex(child) {
        const index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error("The supplied Container must be a child of the caller");
        }
        return index;
      },
      addChildAt(child, index) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
        }
        const { children } = this;
        if (index < 0 || index > children.length) {
          throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
        }
        if (child.parent) {
          const currentIndex = child.parent.children.indexOf(child);
          if (child.parent === this && currentIndex === index) {
            return child;
          }
          if (currentIndex !== -1) {
            child.parent.children.splice(currentIndex, 1);
          }
        }
        if (index === children.length) {
          children.push(child);
        } else {
          children.splice(index, 0, child);
        }
        child.parent = this;
        child.didChange = true;
        child._updateFlags = 15;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.addChild(child);
        }
        if (this.sortableChildren)
          this.sortDirty = true;
        this.emit("childAdded", child, this, index);
        child.emit("added", this);
        return child;
      },
      swapChildren(child, child2) {
        if (child === child2) {
          return;
        }
        const index1 = this.getChildIndex(child);
        const index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
        this._didContainerChangeTick++;
      },
      removeFromParent() {
        this.parent?.removeChild(this);
      },
      reparentChild(...child) {
        if (child.length === 1) {
          return this.reparentChildAt(child[0], this.children.length);
        }
        child.forEach((c2) => this.reparentChildAt(c2, this.children.length));
        return child[0];
      },
      reparentChildAt(child, index) {
        if (child.parent === this) {
          this.setChildIndex(child, index);
          return child;
        }
        const childMat = child.worldTransform.clone();
        child.removeFromParent();
        this.addChildAt(child, index);
        const newMatrix = this.worldTransform.clone();
        newMatrix.invert();
        childMat.prepend(newMatrix);
        child.setFromMatrix(childMat);
        return child;
      },
      replaceChild(oldChild, newChild) {
        oldChild.updateLocalTransform();
        this.addChildAt(newChild, this.getChildIndex(oldChild));
        newChild.setFromMatrix(oldChild.localTransform);
        newChild.updateLocalTransform();
        this.removeChild(oldChild);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs
var collectRenderablesMixin;
var init_collectRenderablesMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs"() {
    "use strict";
    collectRenderablesMixin = {
      collectRenderables(instructionSet, renderer, currentLayer) {
        if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild)
          return;
        if (this.sortableChildren) {
          this.sortChildren();
        }
        if (this.isSimple) {
          this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
        } else if (this.renderGroup) {
          renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
        } else {
          this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);
        }
      },
      collectRenderablesSimple(instructionSet, renderer, currentLayer) {
        const children = this.children;
        const length = children.length;
        for (let i2 = 0; i2 < length; i2++) {
          children[i2].collectRenderables(instructionSet, renderer, currentLayer);
        }
      },
      collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {
        const { renderPipes: renderPipes3 } = renderer;
        for (let i2 = 0; i2 < this.effects.length; i2++) {
          const effect = this.effects[i2];
          const pipe = renderPipes3[effect.pipe];
          pipe.push(effect, this, instructionSet);
        }
        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
        for (let i2 = this.effects.length - 1; i2 >= 0; i2--) {
          const effect = this.effects[i2];
          const pipe = renderPipes3[effect.pipe];
          pipe.pop(effect, this, instructionSet);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/filters/FilterEffect.mjs
var FilterEffect;
var init_FilterEffect = __esm({
  "node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
    "use strict";
    FilterEffect = class {
      constructor() {
        this.pipe = "filter";
        this.priority = 1;
      }
      destroy() {
        for (let i2 = 0; i2 < this.filters.length; i2++) {
          this.filters[i2].destroy();
        }
        this.filters = null;
        this.filterArea = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
var MaskEffectManagerClass, MaskEffectManager;
var init_MaskEffectManager = __esm({
  "node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
    init_Extensions();
    init_PoolGroup();
    MaskEffectManagerClass = class {
      constructor() {
        this._effectClasses = [];
        this._tests = [];
        this._initialized = false;
      }
      init() {
        if (this._initialized)
          return;
        this._initialized = true;
        this._effectClasses.forEach((test) => {
          this.add({
            test: test.test,
            maskClass: test
          });
        });
      }
      add(test) {
        this._tests.push(test);
      }
      getMaskEffect(item) {
        if (!this._initialized)
          this.init();
        for (let i2 = 0; i2 < this._tests.length; i2++) {
          const test = this._tests[i2];
          if (test.test(item)) {
            return BigPool.get(test.maskClass, item);
          }
        }
        return item;
      }
      returnMaskEffect(effect) {
        BigPool.return(effect);
      }
    };
    MaskEffectManager = new MaskEffectManagerClass();
    extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
var effectsMixin;
var init_effectsMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
    init_FilterEffect();
    init_MaskEffectManager();
    effectsMixin = {
      _maskEffect: null,
      _maskOptions: {
        inverse: false
      },
      _filterEffect: null,
      effects: [],
      _markStructureAsChanged() {
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
      },
      addEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index !== -1)
          return;
        this.effects.push(effect);
        this.effects.sort((a2, b2) => a2.priority - b2.priority);
        this._markStructureAsChanged();
        this._updateIsSimple();
      },
      removeEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index === -1)
          return;
        this.effects.splice(index, 1);
        this._markStructureAsChanged();
        this._updateIsSimple();
      },
      set mask(value) {
        const effect = this._maskEffect;
        if (effect?.mask === value)
          return;
        if (effect) {
          this.removeEffect(effect);
          MaskEffectManager.returnMaskEffect(effect);
          this._maskEffect = null;
        }
        if (value === null || value === void 0)
          return;
        this._maskEffect = MaskEffectManager.getMaskEffect(value);
        this.addEffect(this._maskEffect);
      },
      get mask() {
        return this._maskEffect?.mask;
      },
      setMask(options) {
        this._maskOptions = {
          ...this._maskOptions,
          ...options
        };
        if (options.mask) {
          this.mask = options.mask;
        }
        this._markStructureAsChanged();
      },
      set filters(value) {
        if (!Array.isArray(value) && value)
          value = [value];
        const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
        value = value;
        const hasFilters = value?.length > 0;
        const hadFilters = effect.filters?.length > 0;
        const didChange = hasFilters !== hadFilters;
        value = Array.isArray(value) ? value.slice(0) : value;
        effect.filters = Object.freeze(value);
        if (didChange) {
          if (hasFilters) {
            this.addEffect(effect);
          } else {
            this.removeEffect(effect);
            effect.filters = value ?? null;
          }
        }
      },
      get filters() {
        return this._filterEffect?.filters;
      },
      set filterArea(value) {
        this._filterEffect || (this._filterEffect = new FilterEffect());
        this._filterEffect.filterArea = value;
      },
      get filterArea() {
        return this._filterEffect?.filterArea;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
var findMixin;
var init_findMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
    init_deprecation();
    findMixin = {
      label: null,
      get name() {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        return this.label;
      },
      set name(value) {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        this.label = value;
      },
      getChildByName(name, deep = false) {
        return this.getChildByLabel(name, deep);
      },
      getChildByLabel(label, deep = false) {
        const children = this.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.label === label || label instanceof RegExp && label.test(child.label))
            return child;
        }
        if (deep) {
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            const found = child.getChildByLabel(label, true);
            if (found) {
              return found;
            }
          }
        }
        return null;
      },
      getChildrenByLabel(label, deep = false, out2 = []) {
        const children = this.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.label === label || label instanceof RegExp && label.test(child.label)) {
            out2.push(child);
          }
        }
        if (deep) {
          for (let i2 = 0; i2 < children.length; i2++) {
            children[i2].getChildrenByLabel(label, true, out2);
          }
        }
        return out2;
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
var tempPoints, Rectangle;
var init_Rectangle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
    init_Point();
    tempPoints = [new Point(), new Point(), new Point(), new Point()];
    Rectangle = class _Rectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rectangle
       * @param y - The Y coordinate of the upper-left corner of the rectangle
       * @param width - The overall width of the rectangle
       * @param height - The overall height of the rectangle
       */
      constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
        this.type = "rectangle";
        this.x = Number(x2);
        this.y = Number(y2);
        this.width = Number(width);
        this.height = Number(height);
      }
      /**
       * Returns the left edge (x-coordinate) of the rectangle.
       * @example
       * ```ts
       * // Get left edge position
       * const rect = new Rectangle(100, 100, 200, 150);
       * console.log(rect.left); // 100
       *
       * // Use in alignment calculations
       * sprite.x = rect.left + padding;
       *
       * // Compare positions
       * if (point.x > rect.left) {
       *     console.log('Point is right of rectangle');
       * }
       * ```
       * @readonly
       * @returns The x-coordinate of the left edge
       * @see {@link Rectangle.right} For right edge position
       * @see {@link Rectangle.x} For direct x-coordinate access
       */
      get left() {
        return this.x;
      }
      /**
       * Returns the right edge (x + width) of the rectangle.
       * @example
       * ```ts
       * // Get right edge position
       * const rect = new Rectangle(100, 100, 200, 150);
       * console.log(rect.right); // 300
       *
       * // Align to right edge
       * sprite.x = rect.right - sprite.width;
       *
       * // Check boundaries
       * if (point.x < rect.right) {
       *     console.log('Point is inside right bound');
       * }
       * ```
       * @readonly
       * @returns The x-coordinate of the right edge
       * @see {@link Rectangle.left} For left edge position
       * @see {@link Rectangle.width} For width value
       */
      get right() {
        return this.x + this.width;
      }
      /**
       * Returns the top edge (y-coordinate) of the rectangle.
       * @example
       * ```ts
       * // Get top edge position
       * const rect = new Rectangle(100, 100, 200, 150);
       * console.log(rect.top); // 100
       *
       * // Position above rectangle
       * sprite.y = rect.top - sprite.height;
       *
       * // Check vertical position
       * if (point.y > rect.top) {
       *     console.log('Point is below top edge');
       * }
       * ```
       * @readonly
       * @returns The y-coordinate of the top edge
       * @see {@link Rectangle.bottom} For bottom edge position
       * @see {@link Rectangle.y} For direct y-coordinate access
       */
      get top() {
        return this.y;
      }
      /**
       * Returns the bottom edge (y + height) of the rectangle.
       * @example
       * ```ts
       * // Get bottom edge position
       * const rect = new Rectangle(100, 100, 200, 150);
       * console.log(rect.bottom); // 250
       *
       * // Stack below rectangle
       * sprite.y = rect.bottom + margin;
       *
       * // Check vertical bounds
       * if (point.y < rect.bottom) {
       *     console.log('Point is above bottom edge');
       * }
       * ```
       * @readonly
       * @returns The y-coordinate of the bottom edge
       * @see {@link Rectangle.top} For top edge position
       * @see {@link Rectangle.height} For height value
       */
      get bottom() {
        return this.y + this.height;
      }
      /**
       * Determines whether the Rectangle is empty (has no area).
       * @example
       * ```ts
       * // Check zero dimensions
       * const rect = new Rectangle(100, 100, 0, 50);
       * console.log(rect.isEmpty()); // true
       * ```
       * @returns True if the rectangle has no area
       * @see {@link Rectangle.width} For width value
       * @see {@link Rectangle.height} For height value
       */
      isEmpty() {
        return this.left === this.right || this.top === this.bottom;
      }
      /**
       * A constant empty rectangle. This is a new object every time the property is accessed.
       * @example
       * ```ts
       * // Get fresh empty rectangle
       * const empty = Rectangle.EMPTY;
       * console.log(empty.isEmpty()); // true
       * ```
       * @returns A new empty rectangle instance
       * @see {@link Rectangle.isEmpty} For empty state testing
       */
      static get EMPTY() {
        return new _Rectangle(0, 0, 0, 0);
      }
      /**
       * Creates a clone of this Rectangle
       * @example
       * ```ts
       * // Basic cloning
       * const original = new Rectangle(100, 100, 200, 150);
       * const copy = original.clone();
       *
       * // Clone and modify
       * const modified = original.clone();
       * modified.width *= 2;
       * modified.height += 50;
       *
       * // Verify independence
       * console.log(original.width);  // 200
       * console.log(modified.width);  // 400
       * ```
       * @returns A copy of the rectangle
       * @see {@link Rectangle.copyFrom} For copying into existing rectangle
       * @see {@link Rectangle.copyTo} For copying to another rectangle
       */
      clone() {
        return new _Rectangle(this.x, this.y, this.width, this.height);
      }
      /**
       * Converts a Bounds object to a Rectangle object.
       * @example
       * ```ts
       * // Convert bounds to rectangle
       * const bounds = container.getBounds();
       * const rect = new Rectangle().copyFromBounds(bounds);
       * ```
       * @param bounds - The bounds to copy and convert to a rectangle
       * @returns Returns itself
       * @see {@link Bounds} For bounds object structure
       * @see {@link Rectangle.getBounds} For getting rectangle bounds
       */
      copyFromBounds(bounds) {
        this.x = bounds.minX;
        this.y = bounds.minY;
        this.width = bounds.maxX - bounds.minX;
        this.height = bounds.maxY - bounds.minY;
        return this;
      }
      /**
       * Copies another rectangle to this one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Rectangle(100, 100, 200, 150);
       * const target = new Rectangle();
       * target.copyFrom(source);
       *
       * // Chain with other operations
       * const rect = new Rectangle()
       *     .copyFrom(source)
       *     .pad(10);
       * ```
       * @param rectangle - The rectangle to copy from
       * @returns Returns itself
       * @see {@link Rectangle.copyTo} For copying to another rectangle
       * @see {@link Rectangle.clone} For creating new rectangle copy
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Rectangle(100, 100, 200, 150);
       * const target = new Rectangle();
       * source.copyTo(target);
       *
       * // Chain with other operations
       * const result = source
       *     .copyTo(new Rectangle())
       *     .getBounds();
       * ```
       * @param rectangle - The rectangle to copy to
       * @returns Returns given parameter
       * @see {@link Rectangle.copyFrom} For copying from another rectangle
       * @see {@link Rectangle.clone} For creating new rectangle copy
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rectangle
       * @example
       * ```ts
       * // Basic containment check
       * const rect = new Rectangle(100, 100, 200, 150);
       * const isInside = rect.contains(150, 125); // true
       * // Check edge cases
       * console.log(rect.contains(100, 100)); // true (on edge)
       * console.log(rect.contains(300, 250)); // false (outside)
       * ```
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Rectangle
       * @see {@link Rectangle.containsRect} For rectangle containment
       * @see {@link Rectangle.strokeContains} For checking stroke intersection
       */
      contains(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 < this.x + this.width) {
          if (y2 >= this.y && y2 < this.y + this.height) {
            return true;
          }
        }
        return false;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
       * @example
       * ```ts
       * // Basic stroke check
       * const rect = new Rectangle(100, 100, 200, 150);
       * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
       *
       * // Check with different alignments
       * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
       * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
       * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
       * ```
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
       * @returns Whether the x/y coordinates are within this rectangle's stroke
       * @see {@link Rectangle.contains} For checking fill containment
       * @see {@link Rectangle.getBounds} For getting stroke bounds
       */
      strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
        const { width, height } = this;
        if (width <= 0 || height <= 0)
          return false;
        const _x = this.x;
        const _y = this.y;
        const strokeWidthOuter = strokeWidth * (1 - alignment);
        const strokeWidthInner = strokeWidth - strokeWidthOuter;
        const outerLeft = _x - strokeWidthOuter;
        const outerRight = _x + width + strokeWidthOuter;
        const outerTop = _y - strokeWidthOuter;
        const outerBottom = _y + height + strokeWidthOuter;
        const innerLeft = _x + strokeWidthInner;
        const innerRight = _x + width - strokeWidthInner;
        const innerTop = _y + strokeWidthInner;
        const innerBottom = _y + height - strokeWidthInner;
        return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
      }
      /**
       * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
       * Returns true only if the area of the intersection is >0, this means that Rectangles
       * sharing a side are not overlapping. Another side effect is that an arealess rectangle
       * (width or height equal to zero) can't intersect any other rectangle.
       * @param {Rectangle} other - The Rectangle to intersect with `this`.
       * @param {Matrix} transform - The transformation matrix of `other`.
       * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
       */
      /**
       * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
       *
       * Returns true only if the area of the intersection is greater than 0.
       * This means that rectangles sharing only a side are not considered intersecting.
       * @example
       * ```ts
       * // Basic intersection check
       * const rect1 = new Rectangle(0, 0, 100, 100);
       * const rect2 = new Rectangle(50, 50, 100, 100);
       * console.log(rect1.intersects(rect2)); // true
       *
       * // With transformation matrix
       * const matrix = new Matrix();
       * matrix.rotate(Math.PI / 4); // 45 degrees
       * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation
       *
       * // Edge cases
       * const zeroWidth = new Rectangle(0, 0, 0, 100);
       * console.log(rect1.intersects(zeroWidth)); // false (no area)
       * ```
       * @remarks
       * - Returns true only if intersection area is > 0
       * - Rectangles sharing only a side are not intersecting
       * - Zero-area rectangles cannot intersect anything
       * - Supports optional transformation matrix
       * @param other - The Rectangle to intersect with `this`
       * @param transform - Optional transformation matrix of `other`
       * @returns True if the transformed `other` Rectangle intersects with `this`
       * @see {@link Rectangle.containsRect} For containment testing
       * @see {@link Rectangle.contains} For point testing
       */
      intersects(other, transform) {
        if (!transform) {
          const x02 = this.x < other.x ? other.x : this.x;
          const x12 = this.right > other.right ? other.right : this.right;
          if (x12 <= x02) {
            return false;
          }
          const y02 = this.y < other.y ? other.y : this.y;
          const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
          return y12 > y02;
        }
        const x0 = this.left;
        const x1 = this.right;
        const y0 = this.top;
        const y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
          return false;
        }
        const lt = tempPoints[0].set(other.left, other.top);
        const lb = tempPoints[1].set(other.left, other.bottom);
        const rt = tempPoints[2].set(other.right, other.top);
        const rb = tempPoints[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
          return false;
        }
        const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
        if (s2 === 0) {
          return false;
        }
        transform.apply(lt, lt);
        transform.apply(lb, lb);
        transform.apply(rt, rt);
        transform.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
          return false;
        }
        const nx = s2 * (lb.y - lt.y);
        const ny = s2 * (lt.x - lb.x);
        const n00 = nx * x0 + ny * y0;
        const n10 = nx * x1 + ny * y0;
        const n01 = nx * x0 + ny * y1;
        const n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
          return false;
        }
        const mx = s2 * (lt.y - rt.y);
        const my = s2 * (rt.x - lt.x);
        const m00 = mx * x0 + my * y0;
        const m10 = mx * x1 + my * y0;
        const m01 = mx * x0 + my * y1;
        const m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
          return false;
        }
        return true;
      }
      /**
       * Pads the rectangle making it grow in all directions.
       *
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @example
       * ```ts
       * // Basic padding
       * const rect = new Rectangle(100, 100, 200, 150);
       * rect.pad(10); // Adds 10px padding on all sides
       *
       * // Different horizontal and vertical padding
       * const uiRect = new Rectangle(0, 0, 100, 50);
       * uiRect.pad(20, 10); // 20px horizontal, 10px vertical
       * ```
       * @remarks
       * - Adjusts x/y by subtracting padding
       * - Increases width/height by padding * 2
       * - Common in UI layout calculations
       * - Chainable with other methods
       * @param paddingX - The horizontal padding amount
       * @param paddingY - The vertical padding amount
       * @returns Returns itself
       * @see {@link Rectangle.enlarge} For growing to include another rectangle
       * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
       */
      pad(paddingX = 0, paddingY = paddingX) {
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      }
      /**
       * Fits this rectangle around the passed one.
       * @example
       * ```ts
       * // Basic fitting
       * const container = new Rectangle(0, 0, 100, 100);
       * const content = new Rectangle(25, 25, 200, 200);
       * content.fit(container); // Clips to container bounds
       * ```
       * @param rectangle - The rectangle to fit around
       * @returns Returns itself
       * @see {@link Rectangle.enlarge} For growing to include another rectangle
       * @see {@link Rectangle.pad} For adding padding around the rectangle
       */
      fit(rectangle) {
        const x1 = Math.max(this.x, rectangle.x);
        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.max(this.y, rectangle.y);
        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      }
      /**
       * Enlarges rectangle so that its corners lie on a grid defined by resolution.
       * @example
       * ```ts
       * // Basic grid alignment
       * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);
       * rect.ceil(); // Aligns to whole pixels
       *
       * // Custom resolution grid
       * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);
       * uiRect.ceil(0.5); // Aligns to half pixels
       *
       * // Use with precision value
       * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);
       * preciseRect.ceil(1, 0.01); // Handles small decimal variations
       * ```
       * @param resolution - The grid size to align to (1 = whole pixels)
       * @param eps - Small number to prevent floating point errors
       * @returns Returns itself
       * @see {@link Rectangle.fit} For constraining to bounds
       * @see {@link Rectangle.enlarge} For growing dimensions
       */
      ceil(resolution = 1, eps = 1e-3) {
        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
        return this;
      }
      /**
       * Scales the rectangle's dimensions and position by the specified factors.
       * @example
       * ```ts
       * const rect = new Rectangle(50, 50, 100, 100);
       *
       * // Scale uniformly
       * rect.scale(0.5, 0.5);
       * // rect is now: x=25, y=25, width=50, height=50
       *
       * // non-uniformly
       * rect.scale(0.5, 1);
       * // rect is now: x=25, y=50, width=50, height=100
       * ```
       * @param x - The factor by which to scale the horizontal properties (x, width).
       * @param y - The factor by which to scale the vertical properties (y, height).
       * @returns Returns itself
       */
      scale(x2, y2 = x2) {
        this.x *= x2;
        this.y *= y2;
        this.width *= x2;
        this.height *= y2;
        return this;
      }
      /**
       * Enlarges this rectangle to include the passed rectangle.
       * @example
       * ```ts
       * // Basic enlargement
       * const rect = new Rectangle(50, 50, 100, 100);
       * const other = new Rectangle(0, 0, 200, 75);
       * rect.enlarge(other);
       * // rect is now: x=0, y=0, width=200, height=150
       *
       * // Use for bounding box calculation
       * const bounds = new Rectangle();
       * objects.forEach((obj) => {
       *     bounds.enlarge(obj.getBounds());
       * });
       * ```
       * @param rectangle - The rectangle to include
       * @returns Returns itself
       * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
       * @see {@link Rectangle.pad} For adding padding around the rectangle
       */
      enlarge(rectangle) {
        const x1 = Math.min(this.x, rectangle.x);
        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.min(this.y, rectangle.y);
        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      }
      /**
       * Returns the framing rectangle of the rectangle as a Rectangle object
       * @example
       * ```ts
       * // Basic bounds retrieval
       * const rect = new Rectangle(100, 100, 200, 150);
       * const bounds = rect.getBounds();
       *
       * // Reuse existing rectangle
       * const out = new Rectangle();
       * rect.getBounds(out);
       * ```
       * @param out - Optional rectangle to store the result
       * @returns The framing rectangle
       * @see {@link Rectangle.copyFrom} For direct copying
       * @see {@link Rectangle.clone} For creating new copy
       */
      getBounds(out2) {
        out2 || (out2 = new _Rectangle());
        out2.copyFrom(this);
        return out2;
      }
      /**
       * Determines whether another Rectangle is fully contained within this Rectangle.
       *
       * Rectangles that occupy the same space are considered to be containing each other.
       *
       * Rectangles without area (width or height equal to zero) can't contain anything,
       * not even other arealess rectangles.
       * @example
       * ```ts
       * // Check if one rectangle contains another
       * const container = new Rectangle(0, 0, 100, 100);
       * const inner = new Rectangle(25, 25, 50, 50);
       *
       * console.log(container.containsRect(inner)); // true
       *
       * // Check overlapping rectangles
       * const partial = new Rectangle(75, 75, 50, 50);
       * console.log(container.containsRect(partial)); // false
       *
       * // Zero-area rectangles
       * const empty = new Rectangle(0, 0, 0, 100);
       * console.log(container.containsRect(empty)); // false
       * ```
       * @param other - The Rectangle to check for containment
       * @returns True if other is fully contained within this Rectangle
       * @see {@link Rectangle.contains} For point containment
       * @see {@link Rectangle.intersects} For overlap testing
       */
      containsRect(other) {
        if (this.width <= 0 || this.height <= 0)
          return false;
        const x1 = other.x;
        const y1 = other.y;
        const x2 = other.x + other.width;
        const y2 = other.y + other.height;
        return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
      }
      /**
       * Sets the position and dimensions of the rectangle.
       * @example
       * ```ts
       * // Basic usage
       * const rect = new Rectangle();
       * rect.set(100, 100, 200, 150);
       *
       * // Chain with other operations
       * const bounds = new Rectangle()
       *     .set(0, 0, 100, 100)
       *     .pad(10);
       * ```
       * @param x - The X coordinate of the upper-left corner of the rectangle
       * @param y - The Y coordinate of the upper-left corner of the rectangle
       * @param width - The overall width of the rectangle
       * @param height - The overall height of the rectangle
       * @returns Returns itself for method chaining
       * @see {@link Rectangle.copyFrom} For copying from another rectangle
       * @see {@link Rectangle.clone} For creating a new copy
       */
      set(x2, y2, width, height) {
        this.x = x2;
        this.y = y2;
        this.width = width;
        this.height = height;
        return this;
      }
      toString() {
        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
var defaultMatrix, Bounds;
var init_Bounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
    init_Matrix();
    init_Rectangle();
    defaultMatrix = new Matrix();
    Bounds = class _Bounds {
      /**
       * Creates a new Bounds object.
       * @param minX - The minimum X coordinate of the bounds.
       * @param minY - The minimum Y coordinate of the bounds.
       * @param maxX - The maximum X coordinate of the bounds.
       * @param maxY - The maximum Y coordinate of the bounds.
       */
      constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.matrix = defaultMatrix;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      /**
       * Checks if bounds are empty, meaning either width or height is zero or negative.
       * Empty bounds occur when min values exceed max values on either axis.
       * @example
       * ```ts
       * const bounds = new Bounds();
       *
       * // Check if newly created bounds are empty
       * console.log(bounds.isEmpty()); // true, default bounds are empty
       *
       * // Add frame and check again
       * bounds.addFrame(0, 0, 100, 100);
       * console.log(bounds.isEmpty()); // false, bounds now have area
       *
       * // Clear bounds
       * bounds.clear();
       * console.log(bounds.isEmpty()); // true, bounds are empty again
       * ```
       * @returns True if bounds are empty (have no area)
       * @see {@link Bounds#clear} For resetting bounds
       * @see {@link Bounds#isValid} For checking validity
       */
      isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
      }
      /**
       * The bounding rectangle representation of these bounds.
       * Lazily creates and updates a Rectangle instance based on the current bounds.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       *
       * // Get rectangle representation
       * const rect = bounds.rectangle;
       * console.log(rect.x, rect.y, rect.width, rect.height);
       *
       * // Use for hit testing
       * if (bounds.rectangle.contains(mouseX, mouseY)) {
       *     console.log('Mouse is inside bounds!');
       * }
       * ```
       * @see {@link Rectangle} For rectangle methods
       * @see {@link Bounds.isEmpty} For bounds validation
       */
      get rectangle() {
        if (!this._rectangle) {
          this._rectangle = new Rectangle();
        }
        const rectangle = this._rectangle;
        if (this.minX > this.maxX || this.minY > this.maxY) {
          rectangle.x = 0;
          rectangle.y = 0;
          rectangle.width = 0;
          rectangle.height = 0;
        } else {
          rectangle.copyFromBounds(this);
        }
        return rectangle;
      }
      /**
       * Clears the bounds and resets all coordinates to their default values.
       * Resets the transformation matrix back to identity.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * console.log(bounds.isEmpty()); // false
       * // Clear the bounds
       * bounds.clear();
       * console.log(bounds.isEmpty()); // true
       * ```
       * @returns This bounds object for chaining
       */
      clear() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.matrix = defaultMatrix;
        return this;
      }
      /**
       * Sets the bounds directly using coordinate values.
       * Provides a way to set all bounds values at once.
       * @example
       * ```ts
       * const bounds = new Bounds();
       * bounds.set(0, 0, 100, 100);
       * ```
       * @param x0 - Left X coordinate of frame
       * @param y0 - Top Y coordinate of frame
       * @param x1 - Right X coordinate of frame
       * @param y1 - Bottom Y coordinate of frame
       * @see {@link Bounds#addFrame} For matrix-aware bounds setting
       * @see {@link Bounds#clear} For resetting bounds
       */
      set(x0, y0, x1, y1) {
        this.minX = x0;
        this.minY = y0;
        this.maxX = x1;
        this.maxY = y1;
      }
      /**
       * Adds a rectangular frame to the bounds, optionally transformed by a matrix.
       * Updates the bounds to encompass the new frame coordinates.
       * @example
       * ```ts
       * const bounds = new Bounds();
       * bounds.addFrame(0, 0, 100, 100);
       *
       * // Add transformed frame
       * const matrix = new Matrix()
       *     .translate(50, 50)
       *     .rotate(Math.PI / 4);
       * bounds.addFrame(0, 0, 100, 100, matrix);
       * ```
       * @param x0 - Left X coordinate of frame
       * @param y0 - Top Y coordinate of frame
       * @param x1 - Right X coordinate of frame
       * @param y1 - Bottom Y coordinate of frame
       * @param matrix - Optional transformation matrix
       * @see {@link Bounds#addRect} For adding Rectangle objects
       * @see {@link Bounds#addBounds} For adding other Bounds
       */
      addFrame(x0, y0, x1, y1, matrix) {
        matrix || (matrix = this.matrix);
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d2 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        let x2 = a2 * x0 + c2 * y0 + tx;
        let y2 = b2 * x0 + d2 * y0 + ty;
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        x2 = a2 * x1 + c2 * y0 + tx;
        y2 = b2 * x1 + d2 * y0 + ty;
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        x2 = a2 * x0 + c2 * y1 + tx;
        y2 = b2 * x0 + d2 * y1 + ty;
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        x2 = a2 * x1 + c2 * y1 + tx;
        y2 = b2 * x1 + d2 * y1 + ty;
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      /**
       * Adds a rectangle to the bounds, optionally transformed by a matrix.
       * Updates the bounds to encompass the given rectangle.
       * @example
       * ```ts
       * const bounds = new Bounds();
       * // Add simple rectangle
       * const rect = new Rectangle(0, 0, 100, 100);
       * bounds.addRect(rect);
       *
       * // Add transformed rectangle
       * const matrix = new Matrix()
       *     .translate(50, 50)
       *     .rotate(Math.PI / 4);
       * bounds.addRect(rect, matrix);
       * ```
       * @param rect - The rectangle to be added
       * @param matrix - Optional transformation matrix
       * @see {@link Bounds#addFrame} For adding raw coordinates
       * @see {@link Bounds#addBounds} For adding other bounds
       */
      addRect(rect, matrix) {
        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
      }
      /**
       * Adds another bounds object to this one, optionally transformed by a matrix.
       * Expands the bounds to include the given bounds' area.
       * @example
       * ```ts
       * const bounds = new Bounds();
       *
       * // Add child bounds
       * const childBounds = sprite.getBounds();
       * bounds.addBounds(childBounds);
       *
       * // Add transformed bounds
       * const matrix = new Matrix()
       *     .scale(2, 2);
       * bounds.addBounds(childBounds, matrix);
       * ```
       * @param bounds - The bounds to be added
       * @param matrix - Optional transformation matrix
       * @see {@link Bounds#addFrame} For adding raw coordinates
       * @see {@link Bounds#addRect} For adding rectangles
       */
      addBounds(bounds, matrix) {
        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
      }
      /**
       * Adds other Bounds as a mask, creating an intersection of the two bounds.
       * Only keeps the overlapping region between current bounds and mask bounds.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * // Create mask bounds
       * const mask = new Bounds();
       * mask.addFrame(50, 50, 150, 150);
       * // Apply mask - results in bounds of (50,50,100,100)
       * bounds.addBoundsMask(mask);
       * ```
       * @param mask - The Bounds to use as a mask
       * @see {@link Bounds#addBounds} For union operation
       * @see {@link Bounds#fit} For fitting to rectangle
       */
      addBoundsMask(mask) {
        this.minX = this.minX > mask.minX ? this.minX : mask.minX;
        this.minY = this.minY > mask.minY ? this.minY : mask.minY;
        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
      }
      /**
       * Applies a transformation matrix to the bounds, updating its coordinates.
       * Transforms all corners of the bounds using the given matrix.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * // Apply translation
       * const translateMatrix = new Matrix()
       *     .translate(50, 50);
       * bounds.applyMatrix(translateMatrix);
       * ```
       * @param matrix - The matrix to apply to the bounds
       * @see {@link Matrix} For matrix operations
       * @see {@link Bounds#addFrame} For adding transformed frames
       */
      applyMatrix(matrix) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix;
        let x2 = a2 * minX + c2 * minY + tx;
        let y2 = b2 * minX + d2 * minY + ty;
        this.minX = x2;
        this.minY = y2;
        this.maxX = x2;
        this.maxY = y2;
        x2 = a2 * maxX + c2 * minY + tx;
        y2 = b2 * maxX + d2 * minY + ty;
        this.minX = x2 < this.minX ? x2 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x2 > this.maxX ? x2 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x2 = a2 * minX + c2 * maxY + tx;
        y2 = b2 * minX + d2 * maxY + ty;
        this.minX = x2 < this.minX ? x2 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x2 > this.maxX ? x2 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x2 = a2 * maxX + c2 * maxY + tx;
        y2 = b2 * maxX + d2 * maxY + ty;
        this.minX = x2 < this.minX ? x2 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x2 > this.maxX ? x2 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
      }
      /**
       * Resizes the bounds object to fit within the given rectangle.
       * Clips the bounds if they extend beyond the rectangle's edges.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 200, 200);
       * // Fit within viewport
       * const viewport = new Rectangle(50, 50, 100, 100);
       * bounds.fit(viewport);
       * // bounds are now (50, 50, 150, 150)
       * ```
       * @param rect - The rectangle to fit within
       * @returns This bounds object for chaining
       * @see {@link Bounds#addBoundsMask} For intersection
       * @see {@link Bounds#pad} For expanding bounds
       */
      fit(rect) {
        if (this.minX < rect.left)
          this.minX = rect.left;
        if (this.maxX > rect.right)
          this.maxX = rect.right;
        if (this.minY < rect.top)
          this.minY = rect.top;
        if (this.maxY > rect.bottom)
          this.maxY = rect.bottom;
        return this;
      }
      /**
       * Resizes the bounds object to include the given bounds.
       * Similar to fit() but works with raw coordinate values instead of a Rectangle.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 200, 200);
       * // Fit to specific coordinates
       * bounds.fitBounds(50, 150, 50, 150);
       * // bounds are now (50, 50, 150, 150)
       * ```
       * @param left - The left value of the bounds
       * @param right - The right value of the bounds
       * @param top - The top value of the bounds
       * @param bottom - The bottom value of the bounds
       * @returns This bounds object for chaining
       * @see {@link Bounds#fit} For fitting to Rectangle
       * @see {@link Bounds#addBoundsMask} For intersection
       */
      fitBounds(left, right, top, bottom) {
        if (this.minX < left)
          this.minX = left;
        if (this.maxX > right)
          this.maxX = right;
        if (this.minY < top)
          this.minY = top;
        if (this.maxY > bottom)
          this.maxY = bottom;
        return this;
      }
      /**
       * Pads bounds object, making it grow in all directions.
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       *
       * // Add equal padding
       * bounds.pad(10);
       * // bounds are now (-10, -10, 110, 110)
       *
       * // Add different padding for x and y
       * bounds.pad(20, 10);
       * // bounds are now (-30, -20, 130, 120)
       * ```
       * @param paddingX - The horizontal padding amount
       * @param paddingY - The vertical padding amount
       * @returns This bounds object for chaining
       * @see {@link Bounds#fit} For constraining bounds
       * @see {@link Bounds#scale} For uniform scaling
       */
      pad(paddingX, paddingY = paddingX) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
        return this;
      }
      /**
       * Ceils the bounds by rounding up max values and rounding down min values.
       * Useful for pixel-perfect calculations and avoiding fractional pixels.
       * @example
       * ```ts
       * const bounds = new Bounds();
       * bounds.set(10.2, 10.9, 50.1, 50.8);
       *
       * // Round to whole pixels
       * bounds.ceil();
       * // bounds are now (10, 10, 51, 51)
       * ```
       * @returns This bounds object for chaining
       * @see {@link Bounds#scale} For size adjustments
       * @see {@link Bounds#fit} For constraining bounds
       */
      ceil() {
        this.minX = Math.floor(this.minX);
        this.minY = Math.floor(this.minY);
        this.maxX = Math.ceil(this.maxX);
        this.maxY = Math.ceil(this.maxY);
        return this;
      }
      /**
       * Creates a new Bounds instance with the same values.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       *
       * // Create a copy
       * const copy = bounds.clone();
       *
       * // Original and copy are independent
       * bounds.pad(10);
       * console.log(copy.width === bounds.width); // false
       * ```
       * @returns A new Bounds instance with the same values
       * @see {@link Bounds#copyFrom} For reusing existing bounds
       */
      clone() {
        return new _Bounds(this.minX, this.minY, this.maxX, this.maxY);
      }
      /**
       * Scales the bounds by the given values, adjusting all edges proportionally.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       *
       * // Scale uniformly
       * bounds.scale(2);
       * // bounds are now (0, 0, 200, 200)
       *
       * // Scale non-uniformly
       * bounds.scale(0.5, 2);
       * // bounds are now (0, 0, 100, 400)
       * ```
       * @param x - The X value to scale by
       * @param y - The Y value to scale by (defaults to x)
       * @returns This bounds object for chaining
       * @see {@link Bounds#pad} For adding padding
       * @see {@link Bounds#fit} For constraining size
       */
      scale(x2, y2 = x2) {
        this.minX *= x2;
        this.minY *= y2;
        this.maxX *= x2;
        this.maxY *= y2;
        return this;
      }
      /**
       * The x position of the bounds in local space.
       * Setting this value will move the bounds while maintaining its width.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * // Get x position
       * console.log(bounds.x); // 0
       *
       * // Move bounds horizontally
       * bounds.x = 50;
       * console.log(bounds.minX, bounds.maxX); // 50, 150
       *
       * // Width stays the same
       * console.log(bounds.width); // Still 100
       * ```
       */
      get x() {
        return this.minX;
      }
      set x(value) {
        const width = this.maxX - this.minX;
        this.minX = value;
        this.maxX = value + width;
      }
      /**
       * The y position of the bounds in local space.
       * Setting this value will move the bounds while maintaining its height.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * // Get y position
       * console.log(bounds.y); // 0
       *
       * // Move bounds vertically
       * bounds.y = 50;
       * console.log(bounds.minY, bounds.maxY); // 50, 150
       *
       * // Height stays the same
       * console.log(bounds.height); // Still 100
       * ```
       */
      get y() {
        return this.minY;
      }
      set y(value) {
        const height = this.maxY - this.minY;
        this.minY = value;
        this.maxY = value + height;
      }
      /**
       * The width value of the bounds.
       * Represents the distance between minX and maxX coordinates.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * // Get width
       * console.log(bounds.width); // 100
       * // Resize width
       * bounds.width = 200;
       * console.log(bounds.maxX - bounds.minX); // 200
       * ```
       */
      get width() {
        return this.maxX - this.minX;
      }
      set width(value) {
        this.maxX = this.minX + value;
      }
      /**
       * The height value of the bounds.
       * Represents the distance between minY and maxY coordinates.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * // Get height
       * console.log(bounds.height); // 100
       * // Resize height
       * bounds.height = 150;
       * console.log(bounds.maxY - bounds.minY); // 150
       * ```
       */
      get height() {
        return this.maxY - this.minY;
      }
      set height(value) {
        this.maxY = this.minY + value;
      }
      /**
       * The left edge coordinate of the bounds.
       * Alias for minX.
       * @example
       * ```ts
       * const bounds = new Bounds(50, 0, 150, 100);
       * console.log(bounds.left); // 50
       * console.log(bounds.left === bounds.minX); // true
       * ```
       * @readonly
       */
      get left() {
        return this.minX;
      }
      /**
       * The right edge coordinate of the bounds.
       * Alias for maxX.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * console.log(bounds.right); // 100
       * console.log(bounds.right === bounds.maxX); // true
       * ```
       * @readonly
       */
      get right() {
        return this.maxX;
      }
      /**
       * The top edge coordinate of the bounds.
       * Alias for minY.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 25, 100, 125);
       * console.log(bounds.top); // 25
       * console.log(bounds.top === bounds.minY); // true
       * ```
       * @readonly
       */
      get top() {
        return this.minY;
      }
      /**
       * The bottom edge coordinate of the bounds.
       * Alias for maxY.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 200);
       * console.log(bounds.bottom); // 200
       * console.log(bounds.bottom === bounds.maxY); // true
       * ```
       * @readonly
       */
      get bottom() {
        return this.maxY;
      }
      /**
       * Whether the bounds has positive width and height.
       * Checks if both dimensions are greater than zero.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * // Check if bounds are positive
       * console.log(bounds.isPositive); // true
       *
       * // Negative bounds
       * bounds.maxX = bounds.minX;
       * console.log(bounds.isPositive); // false, width is 0
       * ```
       * @readonly
       * @see {@link Bounds#isEmpty} For checking empty state
       * @see {@link Bounds#isValid} For checking validity
       */
      get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
      }
      /**
       * Whether the bounds has valid coordinates.
       * Checks if the bounds has been initialized with real values.
       * @example
       * ```ts
       * const bounds = new Bounds();
       * console.log(bounds.isValid); // false, default state
       *
       * // Set valid bounds
       * bounds.addFrame(0, 0, 100, 100);
       * console.log(bounds.isValid); // true
       * ```
       * @readonly
       * @see {@link Bounds#isEmpty} For checking empty state
       * @see {@link Bounds#isPositive} For checking dimensions
       */
      get isValid() {
        return this.minX + this.minY !== Infinity;
      }
      /**
       * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.
       * Used for efficiently updating bounds from raw vertex data.
       * @example
       * ```ts
       * const bounds = new Bounds();
       *
       * // Add vertices from geometry
       * const vertices = new Float32Array([
       *     0, 0,    // Vertex 1
       *     100, 0,  // Vertex 2
       *     100, 100 // Vertex 3
       * ]);
       * bounds.addVertexData(vertices, 0, 6);
       *
       * // Add transformed vertices
       * const matrix = new Matrix()
       *     .translate(50, 50)
       *     .rotate(Math.PI / 4);
       * bounds.addVertexData(vertices, 0, 6, matrix);
       *
       * // Add subset of vertices
       * bounds.addVertexData(vertices, 2, 4); // Only second vertex
       * ```
       * @param vertexData - The array of vertices to add
       * @param beginOffset - Starting index in the vertex array
       * @param endOffset - Ending index in the vertex array (excluded)
       * @param matrix - Optional transformation matrix
       * @see {@link Bounds#addFrame} For adding rectangular frames
       * @see {@link Matrix} For transformation details
       */
      addVertexData(vertexData, beginOffset, endOffset, matrix) {
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        matrix || (matrix = this.matrix);
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d2 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
          const localX = vertexData[i2];
          const localY = vertexData[i2 + 1];
          const x2 = a2 * localX + c2 * localY + tx;
          const y2 = b2 * localX + d2 * localY + ty;
          minX = x2 < minX ? x2 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      /**
       * Checks if a point is contained within the bounds.
       * Returns true if the point's coordinates fall within the bounds' area.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * // Basic point check
       * console.log(bounds.containsPoint(50, 50)); // true
       * console.log(bounds.containsPoint(150, 150)); // false
       *
       * // Check edges
       * console.log(bounds.containsPoint(0, 0));   // true, includes edges
       * console.log(bounds.containsPoint(100, 100)); // true, includes edges
       * ```
       * @param x - x coordinate to check
       * @param y - y coordinate to check
       * @returns True if the point is inside the bounds
       * @see {@link Bounds#isPositive} For valid bounds check
       * @see {@link Bounds#rectangle} For Rectangle representation
       */
      containsPoint(x2, y2) {
        if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
          return true;
        }
        return false;
      }
      /**
       * Returns a string representation of the bounds.
       * Useful for debugging and logging bounds information.
       * @example
       * ```ts
       * const bounds = new Bounds(0, 0, 100, 100);
       * console.log(bounds.toString()); // "[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]"
       * ```
       * @returns A string describing the bounds
       * @see {@link Bounds#copyFrom} For copying bounds
       * @see {@link Bounds#clone} For creating a new instance
       */
      toString() {
        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
      }
      /**
       * Copies the bounds from another bounds object.
       * Useful for reusing bounds objects and avoiding allocations.
       * @example
       * ```ts
       * const sourceBounds = new Bounds(0, 0, 100, 100);
       * // Copy bounds
       * const targetBounds = new Bounds();
       * targetBounds.copyFrom(sourceBounds);
       * ```
       * @param bounds - The bounds to copy from
       * @returns This bounds object for chaining
       * @see {@link Bounds#clone} For creating new instances
       */
      copyFrom(bounds) {
        this.minX = bounds.minX;
        this.minY = bounds.minY;
        this.maxX = bounds.maxX;
        this.maxY = bounds.maxY;
        return this;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
var matrixPool, boundsPool;
var init_matrixAndBoundsPool = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs"() {
    init_Matrix();
    init_PoolGroup();
    init_Bounds();
    matrixPool = BigPool.getPool(Matrix);
    boundsPool = BigPool.getPool(Bounds);
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs
var tempMatrix2, getFastGlobalBoundsMixin;
var init_getFastGlobalBoundsMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs"() {
    init_Matrix();
    init_Bounds();
    init_matrixAndBoundsPool();
    tempMatrix2 = new Matrix();
    getFastGlobalBoundsMixin = {
      getFastGlobalBounds(factorRenderLayers, bounds) {
        bounds || (bounds = new Bounds());
        bounds.clear();
        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);
        if (!bounds.isValid) {
          bounds.set(0, 0, 0, 0);
        }
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        bounds.applyMatrix(renderGroup.worldTransform);
        return bounds;
      },
      _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {
        let localBounds = bounds;
        if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer)
          return;
        if (this.localDisplayStatus !== 7 || !this.measurable) {
          return;
        }
        const manageEffects = !!this.effects.length;
        if (this.renderGroup || manageEffects) {
          localBounds = boundsPool.get().clear();
        }
        if (this.boundsArea) {
          bounds.addRect(this.boundsArea, this.worldTransform);
        } else {
          if (this.renderPipeId) {
            const viewBounds = this.bounds;
            localBounds.addFrame(
              viewBounds.minX,
              viewBounds.minY,
              viewBounds.maxX,
              viewBounds.maxY,
              this.groupTransform
            );
          }
          const children = this.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            children[i2]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);
          }
        }
        if (manageEffects) {
          let advanced = false;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          for (let i2 = 0; i2 < this.effects.length; i2++) {
            if (this.effects[i2].addBounds) {
              if (!advanced) {
                advanced = true;
                localBounds.applyMatrix(renderGroup.worldTransform);
              }
              this.effects[i2].addBounds(localBounds, true);
            }
          }
          if (advanced) {
            localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix2).invert());
          }
          bounds.addBounds(localBounds);
          boundsPool.return(localBounds);
        } else if (this.renderGroup) {
          bounds.addBounds(localBounds, this.relativeGroupTransform);
          boundsPool.return(localBounds);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  let pooledMatrix;
  if (target.parent) {
    if (!skipUpdateTransform) {
      pooledMatrix = matrixPool.get().identity();
      parentTransform = updateTransformBackwards(target, pooledMatrix);
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (pooledMatrix) {
    matrixPool.return(pooledMatrix);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    target.updateLocalTransform();
    worldTransform = matrixPool.get();
    worldTransform.appendFrom(target.localTransform, parentTransform);
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, worldTransform);
  } else {
    const renderableBounds = target.bounds;
    if (renderableBounds && !renderableBounds.isEmpty()) {
      bounds.matrix = worldTransform;
      bounds.addBounds(renderableBounds);
    }
    for (let i2 = 0; i2 < target.children.length; i2++) {
      _getGlobalBounds(target.children[i2], bounds, worldTransform, skipUpdateTransform);
    }
  }
  if (preserveBounds) {
    for (let i2 = 0; i2 < target.effects.length; i2++) {
      target.effects[i2].addBounds?.(bounds);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  if (!skipUpdateTransform) {
    matrixPool.return(worldTransform);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent = target.parent;
  if (parent) {
    updateTransformBackwards(parent, parentTransform);
    parent.updateLocalTransform();
    parentTransform.append(parent.localTransform);
  }
  return parentTransform;
}
var init_getGlobalBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
    init_Matrix();
    init_matrixAndBoundsPool();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs
function multiplyHexColors(color1, color2) {
  if (color1 === 16777215 || !color2)
    return color2;
  if (color2 === 16777215 || !color1)
    return color1;
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r3 = r1 * r2 / 255 | 0;
  const g3 = g1 * g2 / 255 | 0;
  const b3 = b1 * b2 / 255 | 0;
  return (r3 << 16) + (g3 << 8) + b3;
}
var init_multiplyHexColors = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs
function multiplyColors(localBGRColor, parentBGRColor) {
  if (localBGRColor === WHITE_BGR) {
    return parentBGRColor;
  }
  if (parentBGRColor === WHITE_BGR) {
    return localBGRColor;
  }
  return multiplyHexColors(localBGRColor, parentBGRColor);
}
var WHITE_BGR;
var init_multiplyColors = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs"() {
    init_multiplyHexColors();
    WHITE_BGR = 16777215;
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs
function bgr2rgb(color) {
  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);
}
var getGlobalMixin;
var init_getGlobalMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs"() {
    init_Matrix();
    init_getGlobalBounds();
    init_matrixAndBoundsPool();
    init_multiplyColors();
    getGlobalMixin = {
      getGlobalAlpha(skipUpdate) {
        if (skipUpdate) {
          if (this.renderGroup) {
            return this.renderGroup.worldAlpha;
          }
          if (this.parentRenderGroup) {
            return this.parentRenderGroup.worldAlpha * this.alpha;
          }
          return this.alpha;
        }
        let alpha = this.alpha;
        let current = this.parent;
        while (current) {
          alpha *= current.alpha;
          current = current.parent;
        }
        return alpha;
      },
      getGlobalTransform(matrix = new Matrix(), skipUpdate) {
        if (skipUpdate) {
          return matrix.copyFrom(this.worldTransform);
        }
        this.updateLocalTransform();
        const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());
        matrix.appendFrom(this.localTransform, parentTransform);
        matrixPool.return(parentTransform);
        return matrix;
      },
      getGlobalTint(skipUpdate) {
        if (skipUpdate) {
          if (this.renderGroup) {
            return bgr2rgb(this.renderGroup.worldColor);
          }
          if (this.parentRenderGroup) {
            return bgr2rgb(
              multiplyColors(this.localColor, this.parentRenderGroup.worldColor)
            );
          }
          return this.tint;
        }
        let color = this.localColor;
        let parent = this.parent;
        while (parent) {
          color = multiplyColors(color, parent.localColor);
          parent = parent.parent;
        }
        return bgr2rgb(color);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
  _getLocalBounds(target, bounds, relativeMatrix, target, true);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
  let relativeTransform;
  if (!isRoot) {
    if (!target.visible || !target.measurable)
      return;
    target.updateLocalTransform();
    const localTransform = target.localTransform;
    relativeTransform = matrixPool.get();
    relativeTransform.appendFrom(localTransform, parentTransform);
  } else {
    relativeTransform = matrixPool.get();
    relativeTransform = parentTransform.copyTo(relativeTransform);
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, relativeTransform);
  } else {
    if (target.renderPipeId) {
      bounds.matrix = relativeTransform;
      bounds.addBounds(target.bounds);
    }
    const children = target.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      _getLocalBounds(children[i2], bounds, relativeTransform, rootContainer, false);
    }
  }
  if (preserveBounds) {
    for (let i2 = 0; i2 < target.effects.length; i2++) {
      target.effects[i2].addLocalBounds?.(bounds, rootContainer);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  matrixPool.return(relativeTransform);
}
var init_getLocalBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
    init_Matrix();
    init_matrixAndBoundsPool();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs
function checkChildrenDidChange(container, previousData) {
  const children = container.children;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    const uid3 = child.uid;
    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
    const index = previousData.index;
    if (previousData.data[index] !== uid3 || previousData.data[index + 1] !== didChange) {
      previousData.data[previousData.index] = uid3;
      previousData.data[previousData.index + 1] = didChange;
      previousData.didChange = true;
    }
    previousData.index = index + 2;
    if (child.children.length) {
      checkChildrenDidChange(child, previousData);
    }
  }
  return previousData.didChange;
}
var init_checkChildrenDidChange = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
var tempMatrix3, measureMixin;
var init_measureMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
    init_Matrix();
    init_Bounds();
    init_getGlobalBounds();
    init_getLocalBounds();
    init_checkChildrenDidChange();
    tempMatrix3 = new Matrix();
    measureMixin = {
      _localBoundsCacheId: -1,
      _localBoundsCacheData: null,
      _setWidth(value, localWidth) {
        const sign2 = Math.sign(this.scale.x) || 1;
        if (localWidth !== 0) {
          this.scale.x = value / localWidth * sign2;
        } else {
          this.scale.x = sign2;
        }
      },
      _setHeight(value, localHeight) {
        const sign2 = Math.sign(this.scale.y) || 1;
        if (localHeight !== 0) {
          this.scale.y = value / localHeight * sign2;
        } else {
          this.scale.y = sign2;
        }
      },
      getLocalBounds() {
        if (!this._localBoundsCacheData) {
          this._localBoundsCacheData = {
            data: [],
            index: 1,
            didChange: false,
            localBounds: new Bounds()
          };
        }
        const localBoundsCacheData = this._localBoundsCacheData;
        localBoundsCacheData.index = 1;
        localBoundsCacheData.didChange = false;
        if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
          localBoundsCacheData.didChange = true;
          localBoundsCacheData.data[0] = this._didViewChangeTick;
        }
        checkChildrenDidChange(this, localBoundsCacheData);
        if (localBoundsCacheData.didChange) {
          getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix3);
        }
        return localBoundsCacheData.localBounds;
      },
      getBounds(skipUpdate, bounds) {
        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
var onRenderMixin;
var init_onRenderMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
    "use strict";
    onRenderMixin = {
      _onRender: null,
      set onRender(func) {
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (!func) {
          if (this._onRender) {
            renderGroup?.removeOnRender(this);
          }
          this._onRender = null;
          return;
        }
        if (!this._onRender) {
          renderGroup?.addOnRender(this);
        }
        this._onRender = func;
      },
      get onRender() {
        return this._onRender;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
function sortChildren(a2, b2) {
  return a2._zIndex - b2._zIndex;
}
var sortMixin;
var init_sortMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
    "use strict";
    sortMixin = {
      _zIndex: 0,
      sortDirty: false,
      sortableChildren: false,
      get zIndex() {
        return this._zIndex;
      },
      set zIndex(value) {
        if (this._zIndex === value)
          return;
        this._zIndex = value;
        this.depthOfChildModified();
      },
      depthOfChildModified() {
        if (this.parent) {
          this.parent.sortableChildren = true;
          this.parent.sortDirty = true;
        }
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
      },
      sortChildren() {
        if (!this.sortDirty)
          return;
        this.sortDirty = false;
        this.children.sort(sortChildren);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
var toLocalGlobalMixin;
var init_toLocalGlobalMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
    init_Point();
    init_matrixAndBoundsPool();
    toLocalGlobalMixin = {
      getGlobalPosition(point = new Point(), skipUpdate = false) {
        if (this.parent) {
          this.parent.toGlobal(this._position, point, skipUpdate);
        } else {
          point.x = this._position.x;
          point.y = this._position.y;
        }
        return point;
      },
      toGlobal(position, point, skipUpdate = false) {
        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
        point = globalMatrix.apply(position, point);
        matrixPool.return(globalMatrix);
        return point;
      },
      toLocal(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
        point = globalMatrix.applyInverse(position, point);
        matrixPool.return(globalMatrix);
        return point;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
var InstructionSet;
var init_InstructionSet = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
    init_uid();
    InstructionSet = class {
      constructor() {
        this.uid = uid("instructionSet");
        this.instructions = [];
        this.instructionSize = 0;
        this.renderables = [];
        this.gcTick = 0;
      }
      /** reset the instruction set so it can be reused set size back to 0 */
      reset() {
        this.instructionSize = 0;
      }
      /**
       * Destroy the instruction set, clearing the instructions and renderables.
       * @internal
       */
      destroy() {
        this.instructions.length = 0;
        this.renderables.length = 0;
        this.renderPipes = null;
        this.gcTick = 0;
      }
      /**
       * Add an instruction to the set
       * @param instruction - add an instruction to the set
       */
      add(instruction) {
        this.instructions[this.instructionSize++] = instruction;
      }
      /**
       * Log the instructions to the console (for debugging)
       * @internal
       */
      log() {
        this.instructions.length = this.instructionSize;
        console.table(this.instructions, ["type", "action"]);
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/misc/pow2.mjs
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
var init_pow2 = __esm({
  "node_modules/pixi.js/lib/maths/misc/pow2.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
function definedProps(obj) {
  const result = {};
  for (const key in obj) {
    if (obj[key] !== void 0) {
      result[key] = obj[key];
    }
  }
  return result;
}
var init_definedProps = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
function createResourceIdFromString(value) {
  const id = idHash[value];
  if (id === void 0) {
    idHash[value] = uid("resource");
  }
  return id;
}
var idHash, _TextureStyle, TextureStyle;
var init_TextureStyle = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
    init_eventemitter3();
    init_uid();
    init_deprecation();
    idHash = /* @__PURE__ */ Object.create(null);
    _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
      /**
       * @param options - options for the style
       */
      constructor(options = {}) {
        super();
        this._resourceType = "textureSampler";
        this._touched = 0;
        this._maxAnisotropy = 1;
        this.destroyed = false;
        options = { ..._TextureStyle2.defaultOptions, ...options };
        this.addressMode = options.addressMode;
        this.addressModeU = options.addressModeU ?? this.addressModeU;
        this.addressModeV = options.addressModeV ?? this.addressModeV;
        this.addressModeW = options.addressModeW ?? this.addressModeW;
        this.scaleMode = options.scaleMode;
        this.magFilter = options.magFilter ?? this.magFilter;
        this.minFilter = options.minFilter ?? this.minFilter;
        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
        this.lodMinClamp = options.lodMinClamp;
        this.lodMaxClamp = options.lodMaxClamp;
        this.compare = options.compare;
        this.maxAnisotropy = options.maxAnisotropy ?? 1;
      }
      set addressMode(value) {
        this.addressModeU = value;
        this.addressModeV = value;
        this.addressModeW = value;
      }
      /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
      get addressMode() {
        return this.addressModeU;
      }
      set wrapMode(value) {
        deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
        this.addressMode = value;
      }
      get wrapMode() {
        return this.addressMode;
      }
      set scaleMode(value) {
        this.magFilter = value;
        this.minFilter = value;
        this.mipmapFilter = value;
      }
      /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
      get scaleMode() {
        return this.magFilter;
      }
      /** Specifies the maximum anisotropy value clamp used by the sampler. */
      set maxAnisotropy(value) {
        this._maxAnisotropy = Math.min(value, 16);
        if (this._maxAnisotropy > 1) {
          this.scaleMode = "linear";
        }
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      // TODO - move this to WebGL?
      get _resourceId() {
        return this._sharedResourceId || this._generateResourceId();
      }
      update() {
        this.emit("change", this);
        this._sharedResourceId = null;
      }
      _generateResourceId() {
        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        this._sharedResourceId = createResourceIdFromString(bigKey);
        return this._resourceId;
      }
      /** Destroys the style */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        this.emit("change", this);
        this.removeAllListeners();
      }
    };
    _TextureStyle.defaultOptions = {
      addressMode: "clamp-to-edge",
      scaleMode: "linear"
    };
    TextureStyle = _TextureStyle;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
var _TextureSource, TextureSource;
var init_TextureSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
    init_eventemitter3();
    init_pow2();
    init_definedProps();
    init_uid();
    init_TextureStyle();
    _TextureSource = class _TextureSource2 extends eventemitter3_default {
      /**
       * @param options - options for creating a new TextureSource
       */
      constructor(options = {}) {
        super();
        this.options = options;
        this.uid = uid("textureSource");
        this._resourceType = "textureSource";
        this._resourceId = uid("resource");
        this.uploadMethodId = "unknown";
        this._resolution = 1;
        this.pixelWidth = 1;
        this.pixelHeight = 1;
        this.width = 1;
        this.height = 1;
        this.sampleCount = 1;
        this.mipLevelCount = 1;
        this.autoGenerateMipmaps = false;
        this.format = "rgba8unorm";
        this.dimension = "2d";
        this.antialias = false;
        this._touched = 0;
        this._batchTick = -1;
        this._textureBindLocation = -1;
        options = { ..._TextureSource2.defaultOptions, ...options };
        this.label = options.label ?? "";
        this.resource = options.resource;
        this.autoGarbageCollect = options.autoGarbageCollect;
        this._resolution = options.resolution;
        if (options.width) {
          this.pixelWidth = options.width * this._resolution;
        } else {
          this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
        }
        if (options.height) {
          this.pixelHeight = options.height * this._resolution;
        } else {
          this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
        }
        this.width = this.pixelWidth / this._resolution;
        this.height = this.pixelHeight / this._resolution;
        this.format = options.format;
        this.dimension = options.dimensions;
        this.mipLevelCount = options.mipLevelCount;
        this.autoGenerateMipmaps = options.autoGenerateMipmaps;
        this.sampleCount = options.sampleCount;
        this.antialias = options.antialias;
        this.alphaMode = options.alphaMode;
        this.style = new TextureStyle(definedProps(options));
        this.destroyed = false;
        this._refreshPOT();
      }
      /** returns itself */
      get source() {
        return this;
      }
      /** the style of the texture */
      get style() {
        return this._style;
      }
      set style(value) {
        if (this.style === value)
          return;
        this._style?.off("change", this._onStyleChange, this);
        this._style = value;
        this._style?.on("change", this._onStyleChange, this);
        this._onStyleChange();
      }
      /** Specifies the maximum anisotropy value clamp used by the sampler. */
      set maxAnisotropy(value) {
        this._style.maxAnisotropy = value;
      }
      get maxAnisotropy() {
        return this._style.maxAnisotropy;
      }
      /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
      get addressMode() {
        return this._style.addressMode;
      }
      set addressMode(value) {
        this._style.addressMode = value;
      }
      /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
      get repeatMode() {
        return this._style.addressMode;
      }
      set repeatMode(value) {
        this._style.addressMode = value;
      }
      /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
      get magFilter() {
        return this._style.magFilter;
      }
      set magFilter(value) {
        this._style.magFilter = value;
      }
      /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
      get minFilter() {
        return this._style.minFilter;
      }
      set minFilter(value) {
        this._style.minFilter = value;
      }
      /** Specifies behavior for sampling between mipmap levels. */
      get mipmapFilter() {
        return this._style.mipmapFilter;
      }
      set mipmapFilter(value) {
        this._style.mipmapFilter = value;
      }
      /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
      get lodMinClamp() {
        return this._style.lodMinClamp;
      }
      set lodMinClamp(value) {
        this._style.lodMinClamp = value;
      }
      /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
      get lodMaxClamp() {
        return this._style.lodMaxClamp;
      }
      set lodMaxClamp(value) {
        this._style.lodMaxClamp = value;
      }
      _onStyleChange() {
        this.emit("styleChange", this);
      }
      /** call this if you have modified the texture outside of the constructor */
      update() {
        if (this.resource) {
          const resolution = this._resolution;
          const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
          if (didResize)
            return;
        }
        this.emit("update", this);
      }
      /** Destroys this texture source */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        this.emit("change", this);
        if (this._style) {
          this._style.destroy();
          this._style = null;
        }
        this.uploadMethodId = null;
        this.resource = null;
        this.removeAllListeners();
      }
      /**
       * This will unload the Texture source from the GPU. This will free up the GPU memory
       * As soon as it is required fore rendering, it will be re-uploaded.
       */
      unload() {
        this._resourceId = uid("resource");
        this.emit("change", this);
        this.emit("unload", this);
      }
      /** the width of the resource. This is the REAL pure number, not accounting resolution   */
      get resourceWidth() {
        const { resource } = this;
        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
      }
      /** the height of the resource. This is the REAL pure number, not accounting resolution */
      get resourceHeight() {
        const { resource } = this;
        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
      }
      /**
       * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
       * but will the size of the texture when rendered.
       *
       * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
       * density will have increased)
       */
      get resolution() {
        return this._resolution;
      }
      set resolution(resolution) {
        if (this._resolution === resolution)
          return;
        this._resolution = resolution;
        this.width = this.pixelWidth / resolution;
        this.height = this.pixelHeight / resolution;
      }
      /**
       * Resize the texture, this is handy if you want to use the texture as a render texture
       * @param width - the new width of the texture
       * @param height - the new height of the texture
       * @param resolution - the new resolution of the texture
       * @returns - if the texture was resized
       */
      resize(width, height, resolution) {
        resolution || (resolution = this._resolution);
        width || (width = this.width);
        height || (height = this.height);
        const newPixelWidth = Math.round(width * resolution);
        const newPixelHeight = Math.round(height * resolution);
        this.width = newPixelWidth / resolution;
        this.height = newPixelHeight / resolution;
        this._resolution = resolution;
        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
          return false;
        }
        this._refreshPOT();
        this.pixelWidth = newPixelWidth;
        this.pixelHeight = newPixelHeight;
        this.emit("resize", this);
        this._resourceId = uid("resource");
        this.emit("change", this);
        return true;
      }
      /**
       * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
       * This is only important for RenderTexture instances, as standard Texture instances will have their
       * mipmaps generated on upload. You should call this method after you make any change to the texture
       *
       * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
       * We want you, the developer to specify when this action should happen.
       *
       * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
       */
      updateMipmaps() {
        if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
          this.emit("updateMipmaps", this);
        }
      }
      set wrapMode(value) {
        this._style.wrapMode = value;
      }
      get wrapMode() {
        return this._style.wrapMode;
      }
      set scaleMode(value) {
        this._style.scaleMode = value;
      }
      /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
      get scaleMode() {
        return this._style.scaleMode;
      }
      /**
       * Refresh check for isPowerOfTwo texture based on size
       * @private
       */
      _refreshPOT() {
        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
      }
      static test(_resource) {
        throw new Error("Unimplemented");
      }
    };
    _TextureSource.defaultOptions = {
      resolution: 1,
      format: "bgra8unorm",
      alphaMode: "premultiply-alpha-on-upload",
      dimensions: "2d",
      mipLevelCount: 1,
      autoGenerateMipmaps: false,
      sampleCount: 1,
      antialias: false,
      autoGarbageCollect: false
    };
    TextureSource = _TextureSource;
  }
});

// node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
function init() {
  for (let i2 = 0; i2 < 16; i2++) {
    const row = [];
    rotationCayley.push(row);
    for (let j2 = 0; j2 < 16; j2++) {
      const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
      const _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
      const _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
      const _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
      for (let k2 = 0; k2 < 16; k2++) {
        if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
          row.push(k2);
          break;
        }
      }
    }
  }
  for (let i2 = 0; i2 < 16; i2++) {
    const mat = new Matrix();
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
    rotationMatrices.push(mat);
  }
}
var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
var init_groupD8 = __esm({
  "node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
    init_Matrix();
    ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    rotationCayley = [];
    rotationMatrices = [];
    signum = Math.sign;
    init();
    groupD8 = {
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 0°       | East      |
       * @group groupD8
       * @type {GD8Symmetry}
       */
      E: 0,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 45°↻     | Southeast |
       * @group groupD8
       * @type {GD8Symmetry}
       */
      SE: 1,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 90°↻     | South     |
       * @group groupD8
       * @type {GD8Symmetry}
       */
      S: 2,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 135°↻    | Southwest |
       * @group groupD8
       * @type {GD8Symmetry}
       */
      SW: 3,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 180°     | West      |
       * @group groupD8
       * @type {GD8Symmetry}
       */
      W: 4,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -135°/225°↻ | Northwest    |
       * @group groupD8
       * @type {GD8Symmetry}
       */
      NW: 5,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -90°/270°↻  | North        |
       * @group groupD8
       * @type {GD8Symmetry}
       */
      N: 6,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -45°/315°↻  | Northeast    |
       * @group groupD8
       * @type {GD8Symmetry}
       */
      NE: 7,
      /**
       * Reflection about Y-axis.
       * @group groupD8
       * @type {GD8Symmetry}
       */
      MIRROR_VERTICAL: 8,
      /**
       * Reflection about the main diagonal.
       * @group groupD8
       * @type {GD8Symmetry}
       */
      MAIN_DIAGONAL: 10,
      /**
       * Reflection about X-axis.
       * @group groupD8
       * @type {GD8Symmetry}
       */
      MIRROR_HORIZONTAL: 12,
      /**
       * Reflection about reverse diagonal.
       * @group groupD8
       * @type {GD8Symmetry}
       */
      REVERSE_DIAGONAL: 14,
      /**
       * @group groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the U-axis
       *    after rotating the axes.
       */
      uX: (ind) => ux[ind],
      /**
       * @group groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the U-axis
       *    after rotating the axes.
       */
      uY: (ind) => uy[ind],
      /**
       * @group groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the V-axis
       *    after rotating the axes.
       */
      vX: (ind) => vx[ind],
      /**
       * @group groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the V-axis
       *    after rotating the axes.
       */
      vY: (ind) => vy[ind],
      /**
       * @group groupD8
       * @param {GD8Symmetry} rotation - symmetry whose opposite
       *   is needed. Only rotations have opposite symmetries while
       *   reflections don't.
       * @returns {GD8Symmetry} The opposite symmetry of `rotation`
       */
      inv: (rotation) => {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      /**
       * Composes the two D8 operations.
       *
       * Taking `^` as reflection:
       *
       * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
       * |-------|-----|-----|-----|-----|------|-------|-------|-------|
       * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
       * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
       * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
       * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
       * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
       * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
       * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
       * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
       *
       * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
       * @group groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation, which
       *   is the row in the above cayley table.
       * @param {GD8Symmetry} rotationFirst - First operation, which
       *   is the column in the above cayley table.
       * @returns {GD8Symmetry} Composed operation
       */
      add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
      /**
       * Reverse of `add`.
       * @group groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation
       * @param {GD8Symmetry} rotationFirst - First operation
       * @returns {GD8Symmetry} Result
       */
      sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
      /**
       * Adds 180 degrees to rotation, which is a commutative
       * operation.
       * @group groupD8
       * @param {number} rotation - The number to rotate.
       * @returns {number} Rotated number
       */
      rotate180: (rotation) => rotation ^ 4,
      /**
       * Checks if the rotation angle is vertical, i.e. south
       * or north. It doesn't work for reflections.
       * @group groupD8
       * @param {GD8Symmetry} rotation - The number to check.
       * @returns {boolean} Whether or not the direction is vertical
       */
      isVertical: (rotation) => (rotation & 3) === 2,
      // rotation % 4 === 2
      /**
       * Approximates the vector `V(dx,dy)` into one of the
       * eight directions provided by `groupD8`.
       * @group groupD8
       * @param {number} dx - X-component of the vector
       * @param {number} dy - Y-component of the vector
       * @returns {GD8Symmetry} Approximation of the vector into
       *  one of the eight symmetries.
       */
      byDirection: (dx, dy) => {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD8.S;
          }
          return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD8.E;
          }
          return groupD8.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD8.SE;
          }
          return groupD8.SW;
        } else if (dx > 0) {
          return groupD8.NE;
        }
        return groupD8.NW;
      },
      /**
       * Helps sprite to compensate texture packer rotation.
       * @group groupD8
       * @param {Matrix} matrix - sprite world matrix
       * @param {GD8Symmetry} rotation - The rotation factor to use.
       * @param {number} tx - sprite anchoring
       * @param {number} ty - sprite anchoring
       */
      matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
        const mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      },
      /**
       * Transforms rectangle coordinates based on texture packer rotation.
       * Used when texture atlas pages are rotated and coordinates need to be adjusted.
       * @group groupD8
       * @param {RectangleLike} rect - Rectangle with original coordinates to transform
       * @param {RectangleLike} sourceFrame - Source texture frame (includes offset and dimensions)
       * @param {GD8Symmetry} rotation - The groupD8 rotation value
       * @param {Rectangle} out - Rectangle to store the result
       * @returns {Rectangle} Transformed coordinates (includes source frame offset)
       */
      transformRectCoords: (rect, sourceFrame, rotation, out2) => {
        const { x: x2, y: y2, width, height } = rect;
        const { x: frameX, y: frameY, width: frameWidth, height: frameHeight } = sourceFrame;
        if (rotation === groupD8.E) {
          out2.set(x2 + frameX, y2 + frameY, width, height);
          return out2;
        } else if (rotation === groupD8.S) {
          return out2.set(
            frameWidth - y2 - height + frameX,
            x2 + frameY,
            height,
            width
          );
        } else if (rotation === groupD8.W) {
          return out2.set(
            frameWidth - x2 - width + frameX,
            frameHeight - y2 - height + frameY,
            width,
            height
          );
        } else if (rotation === groupD8.N) {
          return out2.set(
            y2 + frameX,
            frameHeight - x2 - width + frameY,
            height,
            width
          );
        }
        return out2.set(x2 + frameX, y2 + frameY, width, height);
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/misc/NOOP.mjs
var NOOP;
var init_NOOP = __esm({
  "node_modules/pixi.js/lib/utils/misc/NOOP.mjs"() {
    "use strict";
    NOOP = () => {
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
var BufferImageSource;
var init_BufferImageSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
    init_Extensions();
    init_TextureSource();
    BufferImageSource = class extends TextureSource {
      constructor(options) {
        const buffer = options.resource || new Float32Array(options.width * options.height * 4);
        let format = options.format;
        if (!format) {
          if (buffer instanceof Float32Array) {
            format = "rgba32float";
          } else if (buffer instanceof Int32Array) {
            format = "rgba32uint";
          } else if (buffer instanceof Uint32Array) {
            format = "rgba32uint";
          } else if (buffer instanceof Int16Array) {
            format = "rgba16uint";
          } else if (buffer instanceof Uint16Array) {
            format = "rgba16uint";
          } else if (buffer instanceof Int8Array) {
            format = "bgra8unorm";
          } else {
            format = "bgra8unorm";
          }
        }
        super({
          ...options,
          resource: buffer,
          format
        });
        this.uploadMethodId = "buffer";
      }
      static test(resource) {
        return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
      }
    };
    BufferImageSource.extension = ExtensionType.TextureSource;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
var tempMat, TextureMatrix;
var init_TextureMatrix = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
    init_Matrix();
    tempMat = new Matrix();
    TextureMatrix = class {
      /**
       * @param texture - observed texture
       * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
       */
      constructor(texture, clampMargin) {
        this.mapCoord = new Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        if (typeof clampMargin === "undefined") {
          this.clampMargin = texture.width < 10 ? 0 : 0.5;
        } else {
          this.clampMargin = clampMargin;
        }
        this.isSimple = false;
        this.texture = texture;
      }
      /** Texture property. */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this.texture === value)
          return;
        this._texture?.removeListener("update", this.update, this);
        this._texture = value;
        this._texture.addListener("update", this.update, this);
        this.update();
      }
      /**
       * Multiplies uvs array to transform
       * @param uvs - mesh uvs
       * @param [out=uvs] - output
       * @returns - output
       */
      multiplyUvs(uvs, out2) {
        if (out2 === void 0) {
          out2 = uvs;
        }
        const mat = this.mapCoord;
        for (let i2 = 0; i2 < uvs.length; i2 += 2) {
          const x2 = uvs[i2];
          const y2 = uvs[i2 + 1];
          out2[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
          out2[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
        }
        return out2;
      }
      /**
       * Updates matrices if texture was changed
       * @returns - whether or not it was updated
       */
      update() {
        const tex = this._texture;
        this._updateID++;
        const uvs = tex.uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        const orig = tex.orig;
        const trim = tex.trim;
        if (trim) {
          tempMat.set(
            orig.width / trim.width,
            0,
            0,
            orig.height / trim.height,
            -trim.x / trim.width,
            -trim.y / trim.height
          );
          this.mapCoord.append(tempMat);
        }
        const texBase = tex.source;
        const frame = this.uClampFrame;
        const margin = this.clampMargin / texBase._resolution;
        const offset = this.clampOffset / texBase._resolution;
        frame[0] = (tex.frame.x + margin + offset) / texBase.width;
        frame[1] = (tex.frame.y + margin + offset) / texBase.height;
        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
        this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
        return true;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
var Texture;
var init_Texture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
    init_eventemitter3();
    init_groupD8();
    init_Rectangle();
    init_uid();
    init_deprecation();
    init_NOOP();
    init_BufferImageSource();
    init_TextureSource();
    init_TextureMatrix();
    Texture = class extends eventemitter3_default {
      /**
       * @param {TextureOptions} options - Options for the texture
       */
      constructor({
        source: source3,
        label,
        frame,
        orig,
        trim,
        defaultAnchor,
        defaultBorders,
        rotate,
        dynamic
      } = {}) {
        super();
        this.uid = uid("texture");
        this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
        this.frame = new Rectangle();
        this.noFrame = false;
        this.dynamic = false;
        this.isTexture = true;
        this.label = label;
        this.source = source3?.source ?? new TextureSource();
        this.noFrame = !frame;
        if (frame) {
          this.frame.copyFrom(frame);
        } else {
          const { width, height } = this._source;
          this.frame.width = width;
          this.frame.height = height;
        }
        this.orig = orig || this.frame;
        this.trim = trim;
        this.rotate = rotate ?? 0;
        this.defaultAnchor = defaultAnchor;
        this.defaultBorders = defaultBorders;
        this.destroyed = false;
        this.dynamic = dynamic || false;
        this.updateUvs();
      }
      set source(value) {
        if (this._source) {
          this._source.off("resize", this.update, this);
        }
        this._source = value;
        value.on("resize", this.update, this);
        this.emit("update", this);
      }
      /** the underlying source of the texture (equivalent of baseTexture in v7) */
      get source() {
        return this._source;
      }
      /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
      get textureMatrix() {
        if (!this._textureMatrix) {
          this._textureMatrix = new TextureMatrix(this);
        }
        return this._textureMatrix;
      }
      /** The width of the Texture in pixels. */
      get width() {
        return this.orig.width;
      }
      /** The height of the Texture in pixels. */
      get height() {
        return this.orig.height;
      }
      /** Call this function when you have modified the frame of this texture. */
      updateUvs() {
        const { uvs, frame } = this;
        const { width, height } = this._source;
        const nX = frame.x / width;
        const nY = frame.y / height;
        const nW = frame.width / width;
        const nH = frame.height / height;
        let rotate = this.rotate;
        if (rotate) {
          const w2 = nW / 2;
          const h2 = nH / 2;
          const cX = nX + w2;
          const cY = nY + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          uvs.x0 = cX + w2 * groupD8.uX(rotate);
          uvs.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x1 = cX + w2 * groupD8.uX(rotate);
          uvs.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x2 = cX + w2 * groupD8.uX(rotate);
          uvs.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x3 = cX + w2 * groupD8.uX(rotate);
          uvs.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          uvs.x0 = nX;
          uvs.y0 = nY;
          uvs.x1 = nX + nW;
          uvs.y1 = nY;
          uvs.x2 = nX + nW;
          uvs.y2 = nY + nH;
          uvs.x3 = nX;
          uvs.y3 = nY + nH;
        }
      }
      /**
       * Destroys this texture
       * @param destroySource - Destroy the source when the texture is destroyed.
       */
      destroy(destroySource = false) {
        if (this._source) {
          if (destroySource) {
            this._source.destroy();
            this._source = null;
          }
        }
        this._textureMatrix = null;
        this.destroyed = true;
        this.emit("destroy", this);
        this.removeAllListeners();
      }
      /**
       * Call this if you have modified the `texture outside` of the constructor.
       *
       * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
       */
      update() {
        if (this.noFrame) {
          this.frame.width = this._source.width;
          this.frame.height = this._source.height;
        }
        this.updateUvs();
        this.emit("update", this);
      }
      /** @deprecated since 8.0.0 */
      get baseTexture() {
        deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
        return this._source;
      }
    };
    Texture.EMPTY = new Texture({
      label: "EMPTY",
      source: new TextureSource({
        label: "EMPTY"
      })
    });
    Texture.EMPTY.destroy = NOOP;
    Texture.WHITE = new Texture({
      source: new BufferImageSource({
        resource: new Uint8Array([255, 255, 255, 255]),
        width: 1,
        height: 1,
        alphaMode: "premultiply-alpha-on-upload",
        label: "WHITE"
      }),
      label: "WHITE"
    });
    Texture.WHITE.destroy = NOOP;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
var count, TexturePoolClass, TexturePool;
var init_TexturePool = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
    init_pow2();
    init_GlobalResourceRegistry();
    init_TextureSource();
    init_Texture();
    init_TextureStyle();
    count = 0;
    TexturePoolClass = class {
      /**
       * @param textureOptions - options that will be passed to BaseRenderTexture constructor
       * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
       */
      constructor(textureOptions) {
        this._poolKeyHash = /* @__PURE__ */ Object.create(null);
        this._texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
        this.textureStyle = new TextureStyle(this.textureOptions);
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       * @param antialias
       */
      createTexture(pixelWidth, pixelHeight, antialias) {
        const textureSource = new TextureSource({
          ...this.textureOptions,
          width: pixelWidth,
          height: pixelHeight,
          resolution: 1,
          antialias,
          autoGarbageCollect: false
        });
        return new Texture({
          source: textureSource,
          label: `texturePool_${count++}`
        });
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param frameWidth - The minimum width of the render texture.
       * @param frameHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @param antialias
       * @returns The new render texture.
       */
      getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
        po2Width = nextPow2(po2Width);
        po2Height = nextPow2(po2Height);
        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
        if (!this._texturePool[key]) {
          this._texturePool[key] = [];
        }
        let texture = this._texturePool[key].pop();
        if (!texture) {
          texture = this.createTexture(po2Width, po2Height, antialias);
        }
        texture.source._resolution = resolution;
        texture.source.width = po2Width / resolution;
        texture.source.height = po2Height / resolution;
        texture.source.pixelWidth = po2Width;
        texture.source.pixelHeight = po2Height;
        texture.frame.x = 0;
        texture.frame.y = 0;
        texture.frame.width = frameWidth;
        texture.frame.height = frameHeight;
        texture.updateUvs();
        this._poolKeyHash[texture.uid] = key;
        return texture;
      }
      /**
       * Gets extra texture of the same size as input renderTexture
       * @param texture - The texture to check what size it is.
       * @param antialias - Whether to use antialias.
       * @returns A texture that is a power of two
       */
      getSameSizeTexture(texture, antialias = false) {
        const source3 = texture.source;
        return this.getOptimalTexture(texture.width, texture.height, source3._resolution, antialias);
      }
      /**
       * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.
       * useful if you modified the style of the texture after getting it from the pool.
       * @param renderTexture - The renderTexture to free
       * @param resetStyle - Whether to reset the style of the texture to the default texture style
       */
      returnTexture(renderTexture, resetStyle = false) {
        const key = this._poolKeyHash[renderTexture.uid];
        if (resetStyle) {
          renderTexture.source.style = this.textureStyle;
        }
        this._texturePool[key].push(renderTexture);
      }
      /**
       * Clears the pool.
       * @param destroyTextures - Destroy all stored textures.
       */
      clear(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (const i2 in this._texturePool) {
            const textures = this._texturePool[i2];
            if (textures) {
              for (let j2 = 0; j2 < textures.length; j2++) {
                textures[j2].destroy(true);
              }
            }
          }
        }
        this._texturePool = {};
      }
    };
    TexturePool = new TexturePoolClass();
    GlobalResourceRegistry.register(TexturePool);
  }
});

// node_modules/pixi.js/lib/scene/container/RenderGroup.mjs
var RenderGroup;
var init_RenderGroup = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderGroup.mjs"() {
    init_Matrix();
    init_InstructionSet();
    init_TexturePool();
    RenderGroup = class {
      constructor() {
        this.renderPipeId = "renderGroup";
        this.root = null;
        this.canBundle = false;
        this.renderGroupParent = null;
        this.renderGroupChildren = [];
        this.worldTransform = new Matrix();
        this.worldColorAlpha = 4294967295;
        this.worldColor = 16777215;
        this.worldAlpha = 1;
        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
        this.updateTick = 0;
        this.gcTick = 0;
        this.childrenRenderablesToUpdate = { list: [], index: 0 };
        this.structureDidChange = true;
        this.instructionSet = new InstructionSet();
        this._onRenderContainers = [];
        this.textureNeedsUpdate = true;
        this.isCachedAsTexture = false;
        this._matrixDirty = 7;
      }
      init(root) {
        this.root = root;
        if (root._onRender)
          this.addOnRender(root);
        root.didChange = true;
        const children = root.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          child._updateFlags = 15;
          this.addChild(child);
        }
      }
      enableCacheAsTexture(options = {}) {
        this.textureOptions = options;
        this.isCachedAsTexture = true;
        this.textureNeedsUpdate = true;
      }
      disableCacheAsTexture() {
        this.isCachedAsTexture = false;
        if (this.texture) {
          TexturePool.returnTexture(this.texture, true);
          this.texture = null;
        }
      }
      updateCacheTexture() {
        this.textureNeedsUpdate = true;
        const cachedParent = this._parentCacheAsTextureRenderGroup;
        if (cachedParent && !cachedParent.textureNeedsUpdate) {
          cachedParent.updateCacheTexture();
        }
      }
      reset() {
        this.renderGroupChildren.length = 0;
        for (const i2 in this.childrenToUpdate) {
          const childrenAtDepth = this.childrenToUpdate[i2];
          childrenAtDepth.list.fill(null);
          childrenAtDepth.index = 0;
        }
        this.childrenRenderablesToUpdate.index = 0;
        this.childrenRenderablesToUpdate.list.fill(null);
        this.root = null;
        this.updateTick = 0;
        this.structureDidChange = true;
        this._onRenderContainers.length = 0;
        this.renderGroupParent = null;
        this.disableCacheAsTexture();
      }
      get localTransform() {
        return this.root.localTransform;
      }
      addRenderGroupChild(renderGroupChild) {
        if (renderGroupChild.renderGroupParent) {
          renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
        }
        renderGroupChild.renderGroupParent = this;
        this.renderGroupChildren.push(renderGroupChild);
      }
      _removeRenderGroupChild(renderGroupChild) {
        const index = this.renderGroupChildren.indexOf(renderGroupChild);
        if (index > -1) {
          this.renderGroupChildren.splice(index, 1);
        }
        renderGroupChild.renderGroupParent = null;
      }
      addChild(child) {
        this.structureDidChange = true;
        child.parentRenderGroup = this;
        child.updateTick = -1;
        if (child.parent === this.root) {
          child.relativeRenderGroupDepth = 1;
        } else {
          child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
        }
        child.didChange = true;
        this.onChildUpdate(child);
        if (child.renderGroup) {
          this.addRenderGroupChild(child.renderGroup);
          return;
        }
        if (child._onRender)
          this.addOnRender(child);
        const children = child.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          this.addChild(children[i2]);
        }
      }
      removeChild(child) {
        this.structureDidChange = true;
        if (child._onRender) {
          if (!child.renderGroup) {
            this.removeOnRender(child);
          }
        }
        child.parentRenderGroup = null;
        if (child.renderGroup) {
          this._removeRenderGroupChild(child.renderGroup);
          return;
        }
        const children = child.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          this.removeChild(children[i2]);
        }
      }
      removeChildren(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          this.removeChild(children[i2]);
        }
      }
      onChildUpdate(child) {
        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
        if (!childrenToUpdate) {
          childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
            index: 0,
            list: []
          };
        }
        childrenToUpdate.list[childrenToUpdate.index++] = child;
      }
      updateRenderable(renderable) {
        if (renderable.globalDisplayStatus < 7)
          return;
        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
        renderable.didViewUpdate = false;
      }
      onChildViewUpdate(child) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
      }
      get isRenderable() {
        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
      }
      /**
       * adding a container to the onRender list will make sure the user function
       * passed in to the user defined 'onRender` callBack
       * @param container - the container to add to the onRender list
       */
      addOnRender(container) {
        this._onRenderContainers.push(container);
      }
      removeOnRender(container) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
      }
      runOnRender(renderer) {
        for (let i2 = 0; i2 < this._onRenderContainers.length; i2++) {
          this._onRenderContainers[i2]._onRender(renderer);
        }
      }
      destroy() {
        this.disableCacheAsTexture();
        this.renderGroupParent = null;
        this.root = null;
        this.childrenRenderablesToUpdate = null;
        this.childrenToUpdate = null;
        this.renderGroupChildren = null;
        this._onRenderContainers = null;
        this.instructionSet = null;
      }
      getChildren(out2 = []) {
        const children = this.root.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          this._getChildren(children[i2], out2);
        }
        return out2;
      }
      _getChildren(container, out2 = []) {
        out2.push(container);
        if (container.renderGroup)
          return out2;
        const children = container.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          this._getChildren(children[i2], out2);
        }
        return out2;
      }
      invalidateMatrices() {
        this._matrixDirty = 7;
      }
      /**
       * Returns the inverse of the world transform matrix.
       * @returns {Matrix} The inverse of the world transform matrix.
       */
      get inverseWorldTransform() {
        if ((this._matrixDirty & 1) === 0)
          return this._inverseWorldTransform;
        this._matrixDirty &= ~1;
        this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());
        return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
      }
      /**
       * Returns the inverse of the texture offset transform matrix.
       * @returns {Matrix} The inverse of the texture offset transform matrix.
       */
      get textureOffsetInverseTransform() {
        if ((this._matrixDirty & 2) === 0)
          return this._textureOffsetInverseTransform;
        this._matrixDirty &= ~2;
        this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());
        return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(
          -this._textureBounds.x,
          -this._textureBounds.y
        );
      }
      /**
       * Returns the inverse of the parent texture transform matrix.
       * This is used to properly transform coordinates when rendering into cached textures.
       * @returns {Matrix} The inverse of the parent texture transform matrix.
       */
      get inverseParentTextureTransform() {
        if ((this._matrixDirty & 4) === 0)
          return this._inverseParentTextureTransform;
        this._matrixDirty &= ~4;
        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
        if (parentCacheAsTexture) {
          this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());
          return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(
            -parentCacheAsTexture._textureBounds.x,
            -parentCacheAsTexture._textureBounds.y
          );
        }
        return this.worldTransform;
      }
      /**
       * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.
       * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.
       * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,
       * or null if no parent is cached as texture.
       */
      get cacheToLocalTransform() {
        if (this.isCachedAsTexture) {
          return this.textureOffsetInverseTransform;
        }
        if (!this._parentCacheAsTextureRenderGroup)
          return null;
        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs
function assignWithIgnore(target, options, ignore = {}) {
  for (const key in options) {
    if (!ignore[key] && options[key] !== void 0) {
      target[key] = options[key];
    }
  }
}
var init_assignWithIgnore = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/Container.mjs
var defaultSkew, defaultPivot, defaultScale, defaultOrigin, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, Container;
var init_Container = __esm({
  "node_modules/pixi.js/lib/scene/container/Container.mjs"() {
    init_eventemitter3();
    init_Color();
    init_cullingMixin();
    init_Extensions();
    init_Matrix();
    init_const();
    init_ObservablePoint();
    init_uid();
    init_deprecation();
    init_warn();
    init_PoolGroup();
    init_cacheAsTextureMixin();
    init_childrenHelperMixin();
    init_collectRenderablesMixin();
    init_effectsMixin();
    init_findMixin();
    init_getFastGlobalBoundsMixin();
    init_getGlobalMixin();
    init_measureMixin();
    init_onRenderMixin();
    init_sortMixin();
    init_toLocalGlobalMixin();
    init_RenderGroup();
    init_assignWithIgnore();
    defaultSkew = new ObservablePoint(null);
    defaultPivot = new ObservablePoint(null);
    defaultScale = new ObservablePoint(null, 1, 1);
    defaultOrigin = new ObservablePoint(null);
    UPDATE_COLOR = 1;
    UPDATE_BLEND = 2;
    UPDATE_VISIBLE = 4;
    Container = class _Container extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uid = uid("renderable");
        this._updateFlags = 15;
        this.renderGroup = null;
        this.parentRenderGroup = null;
        this.parentRenderGroupIndex = 0;
        this.didChange = false;
        this.didViewUpdate = false;
        this.relativeRenderGroupDepth = 0;
        this.children = [];
        this.parent = null;
        this.includeInBuild = true;
        this.measurable = true;
        this.isSimple = true;
        this.parentRenderLayer = null;
        this.updateTick = -1;
        this.localTransform = new Matrix();
        this.relativeGroupTransform = new Matrix();
        this.groupTransform = this.relativeGroupTransform;
        this.destroyed = false;
        this._position = new ObservablePoint(this, 0, 0);
        this._scale = defaultScale;
        this._pivot = defaultPivot;
        this._origin = defaultOrigin;
        this._skew = defaultSkew;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._rotation = 0;
        this.localColor = 16777215;
        this.localAlpha = 1;
        this.groupAlpha = 1;
        this.groupColor = 16777215;
        this.groupColorAlpha = 4294967295;
        this.localBlendMode = "inherit";
        this.groupBlendMode = "normal";
        this.localDisplayStatus = 7;
        this.globalDisplayStatus = 7;
        this._didContainerChangeTick = 0;
        this._didViewChangeTick = 0;
        this._didLocalTransformChangeId = -1;
        this.effects = [];
        assignWithIgnore(this, options, {
          children: true,
          parent: true,
          effects: true
        });
        options.children?.forEach((child) => this.addChild(child));
        options.parent?.addChild(this);
      }
      /**
       * Mixes all enumerable properties and methods from a source object to Container.
       * @param source - The source of properties and methods to mix in.
       * @deprecated since 8.8.0
       */
      static mixin(source3) {
        deprecation("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead.");
        extensions.mixin(_Container, source3);
      }
      // = 'default';
      /**
       * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
       * @deprecated since 8.2.6
       * @ignore
       */
      set _didChangeId(value) {
        this._didViewChangeTick = value >> 12 & 4095;
        this._didContainerChangeTick = value & 4095;
      }
      /** @ignore */
      get _didChangeId() {
        return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
      }
      /**
       * Adds one or more children to the container.
       * The children will be rendered as part of this container's display list.
       * @example
       * ```ts
       * // Add a single child
       * container.addChild(sprite);
       *
       * // Add multiple children
       * container.addChild(background, player, foreground);
       *
       * // Add with type checking
       * const sprite = container.addChild<Sprite>(new Sprite(texture));
       * sprite.tint = 'red';
       * ```
       * @param children - The Container(s) to add to the container
       * @returns The first child that was added
       * @see {@link Container#removeChild} For removing children
       * @see {@link Container#addChildAt} For adding at specific index
       */
      addChild(...children) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
        }
        if (children.length > 1) {
          for (let i2 = 0; i2 < children.length; i2++) {
            this.addChild(children[i2]);
          }
          return children[0];
        }
        const child = children[0];
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (child.parent === this) {
          this.children.splice(this.children.indexOf(child), 1);
          this.children.push(child);
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          return child;
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        this.children.push(child);
        if (this.sortableChildren)
          this.sortDirty = true;
        child.parent = this;
        child.didChange = true;
        child._updateFlags = 15;
        if (renderGroup) {
          renderGroup.addChild(child);
        }
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
        this._didViewChangeTick++;
        if (child._zIndex !== 0) {
          child.depthOfChildModified();
        }
        return child;
      }
      /**
       * Removes one or more children from the container.
       * When removing multiple children, events will be triggered for each child in sequence.
       * @example
       * ```ts
       * // Remove a single child
       * const removed = container.removeChild(sprite);
       *
       * // Remove multiple children
       * const bg = container.removeChild(background, player, userInterface);
       *
       * // Remove with type checking
       * const sprite = container.removeChild<Sprite>(childSprite);
       * sprite.texture = newTexture;
       * ```
       * @param children - The Container(s) to remove
       * @returns The first child that was removed
       * @see {@link Container#addChild} For adding children
       * @see {@link Container#removeChildren} For removing multiple children
       */
      removeChild(...children) {
        if (children.length > 1) {
          for (let i2 = 0; i2 < children.length; i2++) {
            this.removeChild(children[i2]);
          }
          return children[0];
        }
        const child = children[0];
        const index = this.children.indexOf(child);
        if (index > -1) {
          this._didViewChangeTick++;
          this.children.splice(index, 1);
          if (this.renderGroup) {
            this.renderGroup.removeChild(child);
          } else if (this.parentRenderGroup) {
            this.parentRenderGroup.removeChild(child);
          }
          if (child.parentRenderLayer) {
            child.parentRenderLayer.detach(child);
          }
          child.parent = null;
          this.emit("childRemoved", child, this, index);
          child.emit("removed", this);
        }
        return child;
      }
      /** @ignore */
      _onUpdate(point) {
        if (point) {
          if (point === this._skew) {
            this._updateSkew();
          }
        }
        this._didContainerChangeTick++;
        if (this.didChange)
          return;
        this.didChange = true;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.onChildUpdate(this);
        }
      }
      set isRenderGroup(value) {
        if (!!this.renderGroup === value)
          return;
        if (value) {
          this.enableRenderGroup();
        } else {
          this.disableRenderGroup();
        }
      }
      /**
       * Returns true if this container is a render group.
       * This means that it will be rendered as a separate pass, with its own set of instructions
       * @advanced
       */
      get isRenderGroup() {
        return !!this.renderGroup;
      }
      /**
       * Calling this enables a render group for this container.
       * This means it will be rendered as a separate set of instructions.
       * The transform of the container will also be handled on the GPU rather than the CPU.
       * @advanced
       */
      enableRenderGroup() {
        if (this.renderGroup)
          return;
        const parentRenderGroup = this.parentRenderGroup;
        parentRenderGroup?.removeChild(this);
        this.renderGroup = BigPool.get(RenderGroup, this);
        this.groupTransform = Matrix.IDENTITY;
        parentRenderGroup?.addChild(this);
        this._updateIsSimple();
      }
      /**
       * This will disable the render group for this container.
       * @advanced
       */
      disableRenderGroup() {
        if (!this.renderGroup)
          return;
        const parentRenderGroup = this.parentRenderGroup;
        parentRenderGroup?.removeChild(this);
        BigPool.return(this.renderGroup);
        this.renderGroup = null;
        this.groupTransform = this.relativeGroupTransform;
        parentRenderGroup?.addChild(this);
        this._updateIsSimple();
      }
      /** @ignore */
      _updateIsSimple() {
        this.isSimple = !this.renderGroup && this.effects.length === 0;
      }
      /**
       * Current transform of the object based on world (parent) factors.
       *
       * This matrix represents the absolute transformation in the scene graph.
       * @example
       * ```ts
       * // Get world position
       * const worldPos = container.worldTransform;
       * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);
       * ```
       * @readonly
       * @see {@link Container#localTransform} For local space transform
       */
      get worldTransform() {
        this._worldTransform || (this._worldTransform = new Matrix());
        if (this.renderGroup) {
          this._worldTransform.copyFrom(this.renderGroup.worldTransform);
        } else if (this.parentRenderGroup) {
          this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
        }
        return this._worldTransform;
      }
      /**
       * The position of the container on the x axis relative to the local coordinates of the parent.
       *
       * An alias to position.x
       * @example
       * ```ts
       * // Basic position
       * container.x = 100;
       * ```
       */
      get x() {
        return this._position.x;
      }
      set x(value) {
        this._position.x = value;
      }
      /**
       * The position of the container on the y axis relative to the local coordinates of the parent.
       *
       * An alias to position.y
       * @example
       * ```ts
       * // Basic position
       * container.y = 200;
       * ```
       */
      get y() {
        return this._position.y;
      }
      set y(value) {
        this._position.y = value;
      }
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @example
       * ```ts
       * // Basic position setting
       * container.position.set(100, 200);
       * container.position.set(100); // Sets both x and y to 100
       * // Using point data
       * container.position = { x: 50, y: 75 };
       * ```
       * @since 4.0.0
       */
      get position() {
        return this._position;
      }
      set position(value) {
        this._position.copyFrom(value);
      }
      /**
       * The rotation of the object in radians.
       *
       * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
       * > rotation is in radians, angle is in degrees.
       * @example
       * ```ts
       * // Basic rotation
       * container.rotation = Math.PI / 4; // 45 degrees
       *
       * // Convert from degrees
       * const degrees = 45;
       * container.rotation = degrees * Math.PI / 180;
       *
       * // Rotate around center
       * container.pivot.set(container.width / 2, container.height / 2);
       * container.rotation = Math.PI; // 180 degrees
       *
       * // Rotate around center with origin
       * container.origin.set(container.width / 2, container.height / 2);
       * container.rotation = Math.PI; // 180 degrees
       * ```
       */
      get rotation() {
        return this._rotation;
      }
      set rotation(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this._onUpdate(this._skew);
        }
      }
      /**
       * The angle of the object in degrees.
       *
       * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
       * > rotation is in radians, angle is in degrees.
       * @example
       * ```ts
       * // Basic angle rotation
       * sprite.angle = 45; // 45 degrees
       *
       * // Rotate around center
       * sprite.pivot.set(sprite.width / 2, sprite.height / 2);
       * sprite.angle = 180; // Half rotation
       *
       * // Rotate around center with origin
       * sprite.origin.set(sprite.width / 2, sprite.height / 2);
       * sprite.angle = 180; // Half rotation
       *
       * // Reset rotation
       * sprite.angle = 0;
       * ```
       */
      get angle() {
        return this.rotation * RAD_TO_DEG;
      }
      set angle(value) {
        this.rotation = value * DEG_TO_RAD;
      }
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space.
       * The `position` is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @example
       * ```ts
       * // Rotate around center
       * container.pivot.set(container.width / 2, container.height / 2);
       * container.rotation = Math.PI; // Rotates around center
       * ```
       * @since 4.0.0
       */
      get pivot() {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        return this._pivot;
      }
      set pivot(value) {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
          if (this._origin !== defaultOrigin) {
            warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
          }
        }
        typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
      }
      /**
       * The skew factor for the object in radians. Skewing is a transformation that distorts
       * the object by rotating it differently at each point, creating a non-uniform shape.
       * @example
       * ```ts
       * // Basic skewing
       * container.skew.set(0.5, 0); // Skew horizontally
       * container.skew.set(0, 0.5); // Skew vertically
       *
       * // Skew with point data
       * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew
       *
       * // Reset skew
       * container.skew.set(0, 0);
       *
       * // Animate skew
       * app.ticker.add(() => {
       *     // Create wave effect
       *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;
       * });
       *
       * // Combine with rotation
       * container.rotation = Math.PI / 4; // 45 degrees
       * container.skew.set(0.2, 0.2); // Skew the rotated object
       * ```
       * @since 4.0.0
       * @type {ObservablePoint} Point-like object with x/y properties in radians
       * @default {x: 0, y: 0}
       */
      get skew() {
        if (this._skew === defaultSkew) {
          this._skew = new ObservablePoint(this, 0, 0);
        }
        return this._skew;
      }
      set skew(value) {
        if (this._skew === defaultSkew) {
          this._skew = new ObservablePoint(this, 0, 0);
        }
        this._skew.copyFrom(value);
      }
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @example
       * ```ts
       * // Basic scaling
       * container.scale.set(2, 2); // Scales to double size
       * container.scale.set(2); // Scales uniformly to double size
       * container.scale = 2; // Scales uniformly to double size
       * // Scale to a specific width and height
       * container.setSize(200, 100); // Sets width to 200 and height to 100
       * ```
       * @since 4.0.0
       */
      get scale() {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 1, 1);
        }
        return this._scale;
      }
      set scale(value) {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 0, 0);
        }
        if (typeof value === "string") {
          value = parseFloat(value);
        }
        typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
      }
      /**
       * @experimental
       * The origin point around which the container rotates and scales without affecting its position.
       * Unlike pivot, changing the origin will not move the container's position.
       * @example
       * ```ts
       * // Rotate around center point
       * container.origin.set(container.width / 2, container.height / 2);
       * container.rotation = Math.PI; // Rotates around center
       *
       * // Reset origin
       * container.origin.set(0, 0);
       * ```
       */
      get origin() {
        if (this._origin === defaultOrigin) {
          this._origin = new ObservablePoint(this, 0, 0);
        }
        return this._origin;
      }
      set origin(value) {
        if (this._origin === defaultOrigin) {
          this._origin = new ObservablePoint(this, 0, 0);
          if (this._pivot !== defaultPivot) {
            warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
          }
        }
        typeof value === "number" ? this._origin.set(value) : this._origin.copyFrom(value);
      }
      /**
       * The width of the Container, setting this will actually modify the scale to achieve the value set.
       * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.
       * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
       * as it is more optimized by not recalculating the local bounds twice.
       * @example
       * ```ts
       * // Basic width setting
       * container.width = 100;
       * // Optimized width setting
       * container.setSize(100, 100);
       * ```
       */
      get width() {
        return Math.abs(this.scale.x * this.getLocalBounds().width);
      }
      set width(value) {
        const localWidth = this.getLocalBounds().width;
        this._setWidth(value, localWidth);
      }
      /**
       * The height of the Container,
       * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.
       * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
       * as it is more optimized by not recalculating the local bounds twice.
       * @example
       * ```ts
       * // Basic height setting
       * container.height = 200;
       * // Optimized height setting
       * container.setSize(100, 200);
       * ```
       */
      get height() {
        return Math.abs(this.scale.y * this.getLocalBounds().height);
      }
      set height(value) {
        const localHeight = this.getLocalBounds().height;
        this._setHeight(value, localHeight);
      }
      /**
       * Retrieves the size of the container as a [Size]{@link Size} object.
       *
       * This is faster than get the width and height separately.
       * @example
       * ```ts
       * // Basic size retrieval
       * const size = container.getSize();
       * console.log(`Size: ${size.width}x${size.height}`);
       *
       * // Reuse existing size object
       * const reuseSize = { width: 0, height: 0 };
       * container.getSize(reuseSize);
       * ```
       * @param out - Optional object to store the size in.
       * @returns The size of the container.
       */
      getSize(out2) {
        if (!out2) {
          out2 = {};
        }
        const bounds = this.getLocalBounds();
        out2.width = Math.abs(this.scale.x * bounds.width);
        out2.height = Math.abs(this.scale.y * bounds.height);
        return out2;
      }
      /**
       * Sets the size of the container to the specified width and height.
       * This is more efficient than setting width and height separately as it only recalculates bounds once.
       * @example
       * ```ts
       * // Basic size setting
       * container.setSize(100, 200);
       *
       * // Set uniform size
       * container.setSize(100); // Sets both width and height to 100
       * ```
       * @param value - This can be either a number or a [Size]{@link Size} object.
       * @param height - The height to set. Defaults to the value of `width` if not provided.
       */
      setSize(value, height) {
        const size = this.getLocalBounds();
        if (typeof value === "object") {
          height = value.height ?? value.width;
          value = value.width;
        } else {
          height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, size.width);
        height !== void 0 && this._setHeight(height, size.height);
      }
      /** Called when the skew or the rotation changes. */
      _updateSkew() {
        const rotation = this._rotation;
        const skew = this._skew;
        this._cx = Math.cos(rotation + skew._y);
        this._sx = Math.sin(rotation + skew._y);
        this._cy = -Math.sin(rotation - skew._x);
        this._sy = Math.cos(rotation - skew._x);
      }
      /**
       * Updates the transform properties of the container.
       * Allows partial updates of transform properties for optimized manipulation.
       * @example
       * ```ts
       * // Basic transform update
       * container.updateTransform({
       *     x: 100,
       *     y: 200,
       *     rotation: Math.PI / 4
       * });
       *
       * // Scale and rotate around center
       * sprite.updateTransform({
       *     pivotX: sprite.width / 2,
       *     pivotY: sprite.height / 2,
       *     scaleX: 2,
       *     scaleY: 2,
       *     rotation: Math.PI
       * });
       *
       * // Update position only
       * button.updateTransform({
       *     x: button.x + 10, // Move right
       *     y: button.y      // Keep same y
       * });
       * ```
       * @param opts - Transform options to update
       * @param opts.x - The x position
       * @param opts.y - The y position
       * @param opts.scaleX - The x-axis scale factor
       * @param opts.scaleY - The y-axis scale factor
       * @param opts.rotation - The rotation in radians
       * @param opts.skewX - The x-axis skew factor
       * @param opts.skewY - The y-axis skew factor
       * @param opts.pivotX - The x-axis pivot point
       * @param opts.pivotY - The y-axis pivot point
       * @returns This container, for chaining
       * @see {@link Container#setFromMatrix} For matrix-based transforms
       * @see {@link Container#position} For direct position access
       */
      updateTransform(opts) {
        this.position.set(
          typeof opts.x === "number" ? opts.x : this.position.x,
          typeof opts.y === "number" ? opts.y : this.position.y
        );
        this.scale.set(
          typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
          typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
        );
        this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
        this.skew.set(
          typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
          typeof opts.skewY === "number" ? opts.skewY : this.skew.y
        );
        this.pivot.set(
          typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
          typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
        );
        this.origin.set(
          typeof opts.originX === "number" ? opts.originX : this.origin.x,
          typeof opts.originY === "number" ? opts.originY : this.origin.y
        );
        return this;
      }
      /**
       * Updates the local transform properties by decomposing the given matrix.
       * Extracts position, scale, rotation, and skew from a transformation matrix.
       * @example
       * ```ts
       * // Basic matrix transform
       * const matrix = new Matrix()
       *     .translate(100, 100)
       *     .rotate(Math.PI / 4)
       *     .scale(2, 2);
       *
       * container.setFromMatrix(matrix);
       *
       * // Copy transform from another container
       * const source = new Container();
       * source.position.set(100, 100);
       * source.rotation = Math.PI / 2;
       *
       * target.setFromMatrix(source.localTransform);
       *
       * // Reset transform
       * container.setFromMatrix(Matrix.IDENTITY);
       * ```
       * @param matrix - The matrix to use for updating the transform
       * @see {@link Container#updateTransform} For property-based updates
       * @see {@link Matrix#decompose} For matrix decomposition details
       */
      setFromMatrix(matrix) {
        matrix.decompose(this);
      }
      /** Updates the local transform. */
      updateLocalTransform() {
        const localTransformChangeId = this._didContainerChangeTick;
        if (this._didLocalTransformChangeId === localTransformChangeId)
          return;
        this._didLocalTransformChangeId = localTransformChangeId;
        const lt = this.localTransform;
        const scale = this._scale;
        const pivot = this._pivot;
        const origin = this._origin;
        const position = this._position;
        const sx = scale._x;
        const sy = scale._y;
        const px = pivot._x;
        const py = pivot._y;
        const ox = -origin._x;
        const oy = -origin._y;
        lt.a = this._cx * sx;
        lt.b = this._sx * sx;
        lt.c = this._cy * sy;
        lt.d = this._sy * sy;
        lt.tx = position._x - (px * lt.a + py * lt.c) + (ox * lt.a + oy * lt.c) - ox;
        lt.ty = position._y - (px * lt.b + py * lt.d) + (ox * lt.b + oy * lt.d) - oy;
      }
      // / ///// color related stuff
      set alpha(value) {
        if (value === this.localAlpha)
          return;
        this.localAlpha = value;
        this._updateFlags |= UPDATE_COLOR;
        this._onUpdate();
      }
      /**
       * The opacity of the object relative to its parent's opacity.
       * Value ranges from 0 (fully transparent) to 1 (fully opaque).
       * @example
       * ```ts
       * // Basic transparency
       * sprite.alpha = 0.5; // 50% opacity
       *
       * // Inherited opacity
       * container.alpha = 0.5;
       * const child = new Sprite(texture);
       * child.alpha = 0.5;
       * container.addChild(child);
       * // child's effective opacity is 0.25 (0.5 * 0.5)
       * ```
       * @default 1
       * @see {@link Container#visible} For toggling visibility
       * @see {@link Container#renderable} For render control
       */
      get alpha() {
        return this.localAlpha;
      }
      set tint(value) {
        const tempColor = Color.shared.setValue(value ?? 16777215);
        const bgr = tempColor.toBgrNumber();
        if (bgr === this.localColor)
          return;
        this.localColor = bgr;
        this._updateFlags |= UPDATE_COLOR;
        this._onUpdate();
      }
      /**
       * The tint applied to the sprite.
       *
       * This can be any valid {@link ColorSource}.
       * @example
       * ```ts
       * // Basic color tinting
       * container.tint = 0xff0000; // Red tint
       * container.tint = 'red';    // Same as above
       * container.tint = '#00ff00'; // Green
       * container.tint = 'rgb(0,0,255)'; // Blue
       *
       * // Remove tint
       * container.tint = 0xffffff; // White = no tint
       * container.tint = null;     // Also removes tint
       * ```
       * @default 0xFFFFFF
       * @see {@link Container#alpha} For transparency
       * @see {@link Container#visible} For visibility control
       */
      get tint() {
        return bgr2rgb(this.localColor);
      }
      // / //////////////// blend related stuff
      set blendMode(value) {
        if (this.localBlendMode === value)
          return;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_BLEND;
        this.localBlendMode = value;
        this._onUpdate();
      }
      /**
       * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.
       *
       * Setting to 'normal' will reset to default blending.
       * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.
       * @example
       * ```ts
       * // Basic blend modes
       * sprite.blendMode = 'add';        // Additive blending
       * sprite.blendMode = 'multiply';   // Multiply colors
       * sprite.blendMode = 'screen';     // Screen blend
       *
       * // Reset blend mode
       * sprite.blendMode = 'normal';     // Normal blending
       * ```
       * @default 'normal'
       * @see {@link Container#alpha} For transparency
       * @see {@link Container#tint} For color adjustments
       */
      get blendMode() {
        return this.localBlendMode;
      }
      // / ///////// VISIBILITY / RENDERABLE /////////////////
      /**
       * The visibility of the object. If false the object will not be drawn,
       * and the transform will not be updated.
       * @example
       * ```ts
       * // Basic visibility toggle
       * sprite.visible = false; // Hide sprite
       * sprite.visible = true;  // Show sprite
       * ```
       * @default true
       * @see {@link Container#renderable} For render-only control
       * @see {@link Container#alpha} For transparency
       */
      get visible() {
        return !!(this.localDisplayStatus & 2);
      }
      set visible(value) {
        const valueNumber = value ? 2 : 0;
        if ((this.localDisplayStatus & 2) === valueNumber)
          return;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 2;
        this._onUpdate();
      }
      /** @ignore */
      get culled() {
        return !(this.localDisplayStatus & 4);
      }
      /** @ignore */
      set culled(value) {
        const valueNumber = value ? 0 : 4;
        if ((this.localDisplayStatus & 4) === valueNumber)
          return;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 4;
        this._onUpdate();
      }
      /**
       * Controls whether this object can be rendered. If false the object will not be drawn,
       * but the transform will still be updated. This is different from visible, which skips
       * transform updates.
       * @example
       * ```ts
       * // Basic render control
       * sprite.renderable = false; // Skip rendering
       * sprite.renderable = true;  // Enable rendering
       * ```
       * @default true
       * @see {@link Container#visible} For skipping transform updates
       * @see {@link Container#alpha} For transparency
       */
      get renderable() {
        return !!(this.localDisplayStatus & 1);
      }
      set renderable(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localDisplayStatus & 1) === valueNumber)
          return;
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 1;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._onUpdate();
      }
      /**
       * Whether or not the object should be rendered.
       * @advanced
       */
      get isRenderable() {
        return this.localDisplayStatus === 7 && this.groupAlpha > 0;
      }
      /**
       * Removes all internal references and listeners as well as removes children from the display list.
       * Do not use a Container after calling `destroy`.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @example
       * ```ts
       * container.destroy();
       * container.destroy(true);
       * container.destroy({ children: true });
       * container.destroy({ children: true, texture: true, textureSource: true });
       * ```
       */
      destroy(options = false) {
        if (this.destroyed)
          return;
        this.destroyed = true;
        let oldChildren;
        if (this.children.length) {
          oldChildren = this.removeChildren(0, this.children.length);
        }
        this.removeFromParent();
        this.parent = null;
        this._maskEffect = null;
        this._filterEffect = null;
        this.effects = null;
        this._position = null;
        this._scale = null;
        this._pivot = null;
        this._origin = null;
        this._skew = null;
        this.emit("destroyed", this);
        this.removeAllListeners();
        const destroyChildren = typeof options === "boolean" ? options : options?.children;
        if (destroyChildren && oldChildren) {
          for (let i2 = 0; i2 < oldChildren.length; ++i2) {
            oldChildren[i2].destroy(options);
          }
        }
        this.renderGroup?.destroy();
        this.renderGroup = null;
      }
    };
    extensions.mixin(
      Container,
      childrenHelperMixin,
      getFastGlobalBoundsMixin,
      toLocalGlobalMixin,
      onRenderMixin,
      measureMixin,
      effectsMixin,
      findMixin,
      sortMixin,
      cullingMixin,
      cacheAsTextureMixin,
      getGlobalMixin,
      collectRenderablesMixin
    );
  }
});

// node_modules/pixi.js/lib/ticker/const.mjs
var UPDATE_PRIORITY;
var init_const2 = __esm({
  "node_modules/pixi.js/lib/ticker/const.mjs"() {
    "use strict";
    UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
      return UPDATE_PRIORITY2;
    })(UPDATE_PRIORITY || {});
  }
});

// node_modules/pixi.js/lib/ticker/TickerListener.mjs
var TickerListener;
var init_TickerListener = __esm({
  "node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
    "use strict";
    TickerListener = class {
      /**
       * Constructor
       * @private
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param priority - The priority for emitting
       * @param once - If the handler should fire once
       */
      constructor(fn, context2 = null, priority = 0, once = false) {
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this._fn = fn;
        this._context = context2;
        this.priority = priority;
        this._once = once;
      }
      /**
       * Simple compare function to figure out if a function and context match.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @returns `true` if the listener match the arguments
       */
      match(fn, context2 = null) {
        return this._fn === fn && this._context === context2;
      }
      /**
       * Emit by calling the current function.
       * @param ticker - The ticker emitting.
       * @returns Next ticker
       */
      emit(ticker) {
        if (this._fn) {
          if (this._context) {
            this._fn.call(this._context, ticker);
          } else {
            this._fn(ticker);
          }
        }
        const redirect = this.next;
        if (this._once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      }
      /**
       * Connect to the list.
       * @param previous - Input node, previous listener
       */
      connect(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      }
      /**
       * Destroy and don't use after this.
       * @param hard - `true` to remove the `next` reference, this
       *        is considered a hard destroy. Soft destroy maintains the next reference.
       * @returns The listener to redirect while emitting or removing.
       */
      destroy(hard = false) {
        this._destroyed = true;
        this._fn = null;
        this._context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        const redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      }
    };
  }
});

// node_modules/pixi.js/lib/ticker/Ticker.mjs
var _Ticker, Ticker;
var init_Ticker = __esm({
  "node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
    init_const2();
    init_TickerListener();
    _Ticker = class _Ticker2 {
      constructor() {
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener(null, null, Infinity);
        this.deltaMS = 1 / _Ticker2.targetFPMS;
        this.elapsedMS = 1 / _Ticker2.targetFPMS;
        this._tick = (time) => {
          this._requestId = null;
          if (this.started) {
            this.update(time);
            if (this.started && this._requestId === null && this._head.next) {
              this._requestId = requestAnimationFrame(this._tick);
            }
          }
        };
      }
      /**
       * Conditionally requests a new animation frame.
       * If a frame has not already been requested, and if the internal
       * emitter has listeners, a new frame is requested.
       */
      _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
      /** Conditionally cancels a pending animation frame. */
      _cancelIfNeeded() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      }
      /**
       * Conditionally requests a new animation frame.
       * If the ticker has been started it checks if a frame has not already
       * been requested, and if the internal emitter has listeners. If these
       * conditions are met, a new frame is requested. If the ticker has not
       * been started, but autoStart is `true`, then the ticker starts now,
       * and continues with the previous conditions to request a new frame.
       */
      _startIfPossible() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      }
      /**
       * Register a handler for tick events.
       * @param fn - The listener function to add. Receives the Ticker instance as parameter
       * @param context - The context for the listener
       * @param priority - The priority of the listener
       * @example
       * ```ts
       * // Access time properties through the ticker parameter
       * ticker.add((ticker) => {
       *     // Use deltaTime (dimensionless scalar) for frame-independent animations
       *     sprite.rotation += 0.1 * ticker.deltaTime;
       *
       *     // Use deltaMS (milliseconds) for time-based calculations
       *     const progress = ticker.deltaMS / animationDuration;
       *
       *     // Use elapsedMS for raw timing measurements
       *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);
       * });
       * ```
       */
      add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context2, priority));
      }
      /**
       * Add a handler for the tick event which is only executed once on the next frame.
       * @example
       * ```ts
       * // Basic one-time update
       * ticker.addOnce(() => {
       *     console.log('Runs next frame only');
       * });
       *
       * // With specific context
       * const game = {
       *     init(ticker) {
       *         this.loadResources();
       *         console.log('Game initialized');
       *     }
       * };
       * ticker.addOnce(game.init, game);
       *
       * // With priority
       * ticker.addOnce(
       *     () => {
       *         // High priority one-time setup
       *         physics.init();
       *     },
       *     undefined,
       *     UPDATE_PRIORITY.HIGH
       * );
       * ```
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)
       * @returns This instance of a ticker
       * @see {@link Ticker#add} For continuous updates
       * @see {@link Ticker#remove} For removing handlers
       */
      addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context2, priority, true));
      }
      /**
       * Internally adds the event handler so that it can be sorted by priority.
       * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
       * before the rendering.
       * @private
       * @param listener - Current listener being added.
       * @returns This instance of a ticker
       */
      _addListener(listener) {
        let current = this._head.next;
        let previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      }
      /**
       * Removes any handlers matching the function and context parameters.
       * If no handlers are left after removing, then it cancels the animation frame.
       * @example
       * ```ts
       * // Basic removal
       * const onTick = () => {
       *     sprite.rotation += 0.1;
       * };
       * ticker.add(onTick);
       * ticker.remove(onTick);
       *
       * // Remove with context
       * const game = {
       *     update(ticker) {
       *         this.physics.update(ticker.deltaTime);
       *     }
       * };
       * ticker.add(game.update, game);
       * ticker.remove(game.update, game);
       *
       * // Remove all matching handlers
       * // (if same function was added multiple times)
       * ticker.add(onTick);
       * ticker.add(onTick);
       * ticker.remove(onTick); // Removes all instances
       * ```
       * @param fn - The listener function to be removed
       * @param context - The listener context to be removed
       * @returns This instance of a ticker
       * @see {@link Ticker#add} For adding handlers
       * @see {@link Ticker#addOnce} For one-time handlers
       */
      remove(fn, context2) {
        let listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context2)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      }
      /**
       * The number of listeners on this ticker, calculated by walking through linked list.
       * @example
       * ```ts
       * // Check number of active listeners
       * const ticker = new Ticker();
       * console.log(ticker.count); // 0
       *
       * // Add some listeners
       * ticker.add(() => {});
       * ticker.add(() => {});
       * console.log(ticker.count); // 2
       *
       * // Check after cleanup
       * ticker.destroy();
       * console.log(ticker.count); // 0
       * ```
       * @readonly
       * @see {@link Ticker#add} For adding listeners
       * @see {@link Ticker#remove} For removing listeners
       */
      get count() {
        if (!this._head) {
          return 0;
        }
        let count2 = 0;
        let current = this._head;
        while (current = current.next) {
          count2++;
        }
        return count2;
      }
      /**
       * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.
       * @example
       * ```ts
       * // Basic manual start
       * const ticker = new Ticker();
       * ticker.add(() => {
       *     // Animation code here
       * });
       * ticker.start();
       * ```
       * @see {@link Ticker#stop} For stopping the ticker
       * @see {@link Ticker#autoStart} For automatic starting
       * @see {@link Ticker#started} For checking ticker state
       */
      start() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      }
      /**
       * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.
       * @example
       * ```ts
       * // Basic stop
       * const ticker = new Ticker();
       * ticker.stop();
       * ```
       * @see {@link Ticker#start} For starting the ticker
       * @see {@link Ticker#started} For checking ticker state
       * @see {@link Ticker#destroy} For cleaning up the ticker
       */
      stop() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      }
      /**
       * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.
       * @example
       * ```ts
       * // Clean up with active listeners
       * const ticker = new Ticker();
       * ticker.add(() => {});
       * ticker.destroy(); // Removes all listeners
       * ```
       * @see {@link Ticker#stop} For stopping without destroying
       * @see {@link Ticker#remove} For removing specific listeners
       */
      destroy() {
        if (!this._protected) {
          this.stop();
          let listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      }
      /**
       * Triggers an update.
       *
       * An update entails setting the
       * current {@link Ticker#elapsedMS|elapsedMS},
       * the current {@link Ticker#deltaTime|deltaTime},
       * invoking all listeners with current deltaTime,
       * and then finally setting {@link Ticker#lastTime|lastTime}
       * with the value of currentTime that was provided.
       *
       * This method will be called automatically by animation
       * frame callbacks if the ticker instance has been started
       * and listeners are added.
       * @example
       * ```ts
       * // Basic manual update
       * const ticker = new Ticker();
       * ticker.update(performance.now());
       * ```
       * @param currentTime - The current time of execution (defaults to performance.now())
       * @see {@link Ticker#deltaTime} For frame delta value
       * @see {@link Ticker#elapsedMS} For raw elapsed time
       */
      update(currentTime = performance.now()) {
        let elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            const delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
          const head = this._head;
          let listener = head.next;
          while (listener) {
            listener = listener.emit(this);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      }
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * > [!NOTE] This does not factor in the value of
       * > {@link Ticker#speed|speed}, which is specific
       * > to scaling {@link Ticker#deltaTime|deltaTime}.
       * @example
       * ```ts
       * // Basic FPS monitoring
       * ticker.add(() => {
       *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);
       * });
       * ```
       * @readonly
       */
      get FPS() {
        return 1e3 / this.elapsedMS;
      }
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link Ticker#update|update}.
       *
       * This value is used to cap {@link Ticker#deltaTime|deltaTime},
       * but does not effect the measured value of {@link Ticker#FPS|FPS}.
       *
       * When setting this property it is clamped to a value between
       * `0` and `Ticker.targetFPMS * 1000`.
       * @example
       * ```ts
       * // Set minimum acceptable frame rate
       * const ticker = new Ticker();
       * ticker.minFPS = 30; // Never go below 30 FPS
       *
       * // Use with maxFPS for frame rate clamping
       * ticker.minFPS = 30;
       * ticker.maxFPS = 60;
       *
       * // Monitor delta capping
       * ticker.add(() => {
       *     // Delta time will be capped based on minFPS
       *     console.log(`Delta time: ${ticker.deltaTime}`);
       * });
       * ```
       * @default 10
       */
      get minFPS() {
        return 1e3 / this._maxElapsedMS;
      }
      set minFPS(fps) {
        const minFPS = Math.min(this.maxFPS, fps);
        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
        this._maxElapsedMS = 1 / minFPMS;
      }
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link Ticker#update|update}.
       *
       * This will effect the measured value of {@link Ticker#FPS|FPS}.
       *
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @example
       * ```ts
       * // Set minimum acceptable frame rate
       * const ticker = new Ticker();
       * ticker.maxFPS = 60; // Never go above 60 FPS
       *
       * // Use with maxFPS for frame rate clamping
       * ticker.minFPS = 30;
       * ticker.maxFPS = 60;
       *
       * // Monitor delta capping
       * ticker.add(() => {
       *     // Delta time will be capped based on maxFPS
       *     console.log(`Delta time: ${ticker.deltaTime}`);
       * });
       * ```
       * @default 0
       */
      get maxFPS() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      }
      set maxFPS(fps) {
        if (fps === 0) {
          this._minElapsedMS = 0;
        } else {
          const maxFPS = Math.max(this.minFPS, fps);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      }
      /**
       * The shared ticker instance used by {@link AnimatedSprite} and by
       * {@link VideoSource} to update animation frames / video textures.
       *
       * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * import { Ticker } from 'pixi.js';
       *
       * const ticker = Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the Ticker.shared instance.
       * ticker.autoStart = false;
       *
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       *
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * import { autoDetectRenderer, Container } from 'pixi.js';
       *
       * // You may use the shared ticker to render...
       * const renderer = autoDetectRenderer();
       * const stage = new Container();
       * document.body.appendChild(renderer.view);
       * ticker.add((time) => renderer.render(stage));
       *
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * const animate = (time) => {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * };
       * animate(performance.now());
       * @type {Ticker}
       * @readonly
       */
      static get shared() {
        if (!_Ticker2._shared) {
          const shared = _Ticker2._shared = new _Ticker2();
          shared.autoStart = true;
          shared._protected = true;
        }
        return _Ticker2._shared;
      }
      /**
       * The system ticker instance used by {@link PrepareBase} for core timing
       * functionality that shouldn't usually need to be paused, unlike the `shared`
       * ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
       * @type {Ticker}
       * @readonly
       * @advanced
       */
      static get system() {
        if (!_Ticker2._system) {
          const system = _Ticker2._system = new _Ticker2();
          system.autoStart = true;
          system._protected = true;
        }
        return _Ticker2._system;
      }
    };
    _Ticker.targetFPMS = 0.06;
    Ticker = _Ticker;
  }
});

// node_modules/pixi.js/lib/dom/CanvasObserver.mjs
var CanvasObserver;
var init_CanvasObserver = __esm({
  "node_modules/pixi.js/lib/dom/CanvasObserver.mjs"() {
    init_const2();
    init_Ticker();
    CanvasObserver = class {
      constructor(options) {
        this._lastTransform = "";
        this._observer = null;
        this._tickerAttached = false;
        this.updateTranslation = () => {
          if (!this._canvas)
            return;
          const rect = this._canvas.getBoundingClientRect();
          const contentWidth = this._canvas.width;
          const contentHeight = this._canvas.height;
          const sx = rect.width / contentWidth * this._renderer.resolution;
          const sy = rect.height / contentHeight * this._renderer.resolution;
          const tx = rect.left;
          const ty = rect.top;
          const newTransform = `translate(${tx}px, ${ty}px) scale(${sx}, ${sy})`;
          if (newTransform !== this._lastTransform) {
            this._domElement.style.transform = newTransform;
            this._lastTransform = newTransform;
          }
        };
        this._domElement = options.domElement;
        this._renderer = options.renderer;
        if (globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas)
          return;
        this._canvas = this._renderer.canvas;
        this._attachObserver();
      }
      /** The canvas element that this CanvasObserver is associated with. */
      get canvas() {
        return this._canvas;
      }
      /** Attaches the DOM element to the canvas parent if it is not already attached. */
      ensureAttached() {
        if (!this._domElement.parentNode && this._canvas.parentNode) {
          this._canvas.parentNode.appendChild(this._domElement);
          this.updateTranslation();
        }
      }
      /** Sets up a ResizeObserver if available. This ensures that the DOM element is kept in sync with the canvas size . */
      _attachObserver() {
        if ("ResizeObserver" in globalThis) {
          if (this._observer) {
            this._observer.disconnect();
            this._observer = null;
          }
          this._observer = new ResizeObserver((entries) => {
            for (const entry of entries) {
              if (entry.target !== this._canvas) {
                continue;
              }
              const contentWidth = this.canvas.width;
              const contentHeight = this.canvas.height;
              const sx = entry.contentRect.width / contentWidth * this._renderer.resolution;
              const sy = entry.contentRect.height / contentHeight * this._renderer.resolution;
              const needsUpdate = this._lastScaleX !== sx || this._lastScaleY !== sy;
              if (needsUpdate) {
                this.updateTranslation();
                this._lastScaleX = sx;
                this._lastScaleY = sy;
              }
            }
          });
          this._observer.observe(this._canvas);
        } else if (!this._tickerAttached) {
          Ticker.shared.add(this.updateTranslation, this, UPDATE_PRIORITY.HIGH);
        }
      }
      /** Destroys the CanvasObserver instance, cleaning up observers and Ticker. */
      destroy() {
        if (this._observer) {
          this._observer.disconnect();
          this._observer = null;
        } else if (this._tickerAttached) {
          Ticker.shared.remove(this.updateTranslation);
        }
        this._domElement = null;
        this._renderer = null;
        this._canvas = null;
        this._tickerAttached = false;
        this._lastTransform = "";
        this._lastScaleX = null;
        this._lastScaleY = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/events/FederatedEvent.mjs
var FederatedEvent;
var init_FederatedEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
    init_Point();
    FederatedEvent = class _FederatedEvent {
      /**
       * @param manager - The event boundary which manages this event. Propagation can only occur
       *  within the boundary's jurisdiction.
       */
      constructor(manager) {
        this.bubbles = true;
        this.cancelBubble = true;
        this.cancelable = false;
        this.composed = false;
        this.defaultPrevented = false;
        this.eventPhase = _FederatedEvent.prototype.NONE;
        this.propagationStopped = false;
        this.propagationImmediatelyStopped = false;
        this.layer = new Point();
        this.page = new Point();
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
      }
      /** @readonly */
      get layerX() {
        return this.layer.x;
      }
      /** @readonly */
      get layerY() {
        return this.layer.y;
      }
      /** @readonly */
      get pageX() {
        return this.page.x;
      }
      /** @readonly */
      get pageY() {
        return this.page.y;
      }
      /**
       * Fallback for the deprecated `InteractionEvent.data`.
       * @deprecated since 7.0.0
       */
      get data() {
        return this;
      }
      /**
       * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.
       * @advanced
       */
      composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
      /**
       * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.
       * @deprecated
       * @ignore
       * @param _type
       * @param _bubbles
       * @param _cancelable
       */
      initEvent(_type, _bubbles, _cancelable) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /**
       * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.
       * @ignore
       * @deprecated
       * @param _typeArg
       * @param _bubblesArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       */
      initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /**
       * Prevent default behavior of both PixiJS and the user agent.
       * @example
       * ```ts
       * sprite.on('click', (event) => {
       *     // Prevent both browser's default click behavior
       *     // and PixiJS's default handling
       *     event.preventDefault();
       *
       *     // Custom handling
       *     customClickHandler();
       * });
       * ```
       * @remarks
       * - Only works if the native event is cancelable
       * - Does not stop event propagation
       */
      preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      }
      /**
       * Stop this event from propagating to any additional listeners, including those
       * on the current target and any following targets in the propagation path.
       * @example
       * ```ts
       * container.on('pointerdown', (event) => {
       *     // Stop all further event handling
       *     event.stopImmediatePropagation();
       *
       *     // These handlers won't be called:
       *     // - Other pointerdown listeners on this container
       *     // - Any pointerdown listeners on parent containers
       * });
       * ```
       * @remarks
       * - Immediately stops all event propagation
       * - Prevents other listeners on same target from being called
       * - More aggressive than stopPropagation()
       */
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      /**
       * Stop this event from propagating to the next target in the propagation path.
       * The rest of the listeners on the current target will still be notified.
       * @example
       * ```ts
       * child.on('pointermove', (event) => {
       *     // Handle event on child
       *     updateChild();
       *
       *     // Prevent parent handlers from being called
       *     event.stopPropagation();
       * });
       *
       * // This won't be called if child handles the event
       * parent.on('pointermove', (event) => {
       *     updateParent();
       * });
       * ```
       * @remarks
       * - Stops event bubbling to parent containers
       * - Does not prevent other listeners on same target
       * - Less aggressive than stopImmediatePropagation()
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
  }
});

// node_modules/ismobilejs/esm/isMobile.js
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
var init_isMobile = __esm({
  "node_modules/ismobilejs/esm/isMobile.js"() {
    appleIphone = /iPhone/i;
    appleIpod = /iPod/i;
    appleTablet = /iPad/i;
    appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    androidTablet = /Android/i;
    amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    amazonTablet = /Silk/i;
    windowsPhone = /Windows Phone/i;
    windowsTablet = /\bWindows(?:.+)ARM\b/i;
    otherBlackBerry = /BlackBerry/i;
    otherBlackBerry10 = /BB10/i;
    otherOpera = /Opera Mini/i;
    otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    otherFirefox = /Mobile(?:.+)Firefox\b/i;
    isAppleTabletOnIos13 = function(navigator2) {
      return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
    };
  }
});

// node_modules/ismobilejs/esm/index.js
var init_esm = __esm({
  "node_modules/ismobilejs/esm/index.js"() {
    init_isMobile();
    init_isMobile();
  }
});

// node_modules/pixi.js/lib/utils/browser/isMobile.mjs
var isMobileCall, isMobile2;
var init_isMobile2 = __esm({
  "node_modules/pixi.js/lib/utils/browser/isMobile.mjs"() {
    init_esm();
    isMobileCall = isMobile.default ?? isMobile;
    isMobile2 = isMobileCall(globalThis.navigator);
  }
});

// node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, _AccessibilitySystem, AccessibilitySystem;
var init_AccessibilitySystem = __esm({
  "node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
    init_CanvasObserver();
    init_FederatedEvent();
    init_Extensions();
    init_isMobile2();
    init_removeItems();
    KEY_CODE_TAB = 9;
    DIV_TOUCH_SIZE = 100;
    DIV_TOUCH_POS_X = 0;
    DIV_TOUCH_POS_Y = 0;
    DIV_TOUCH_ZINDEX = 2;
    DIV_HOOK_SIZE = 1;
    DIV_HOOK_POS_X = -1e3;
    DIV_HOOK_POS_Y = -1e3;
    DIV_HOOK_ZINDEX = 2;
    _AccessibilitySystem = class _AccessibilitySystem2 {
      // eslint-disable-next-line jsdoc/require-param
      /**
       * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
       */
      constructor(renderer, _mobileInfo = isMobile2) {
        this._mobileInfo = _mobileInfo;
        this.debug = false;
        this._activateOnTab = true;
        this._deactivateOnMouseMove = true;
        this._isActive = false;
        this._isMobileAccessibility = false;
        this._div = null;
        this._pools = {};
        this._renderId = 0;
        this._children = [];
        this._androidUpdateCount = 0;
        this._androidUpdateFrequency = 500;
        this._isRunningTests = false;
        this._boundOnKeyDown = this._onKeyDown.bind(this);
        this._boundOnMouseMove = this._onMouseMove.bind(this);
        this._hookDiv = null;
        if (_mobileInfo.tablet || _mobileInfo.phone) {
          this._createTouchHook();
        }
        this._renderer = renderer;
      }
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @type {boolean}
       * @readonly
       */
      get isActive() {
        return this._isActive;
      }
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @type {boolean}
       * @readonly
       */
      get isMobileAccessibility() {
        return this._isMobileAccessibility;
      }
      /**
       * Button element for handling touch hooks.
       * @readonly
       */
      get hookDiv() {
        return this._hookDiv;
      }
      /**
       * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.
       * @readonly
       */
      get div() {
        return this._div;
      }
      /**
       * Creates the touch hooks.
       * @private
       */
      _createTouchHook() {
        const hookDiv = document.createElement("button");
        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.position = "absolute";
        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessibility for this content";
        hookDiv.addEventListener("focus", () => {
          this._isMobileAccessibility = true;
          this._activate();
          this._destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
      }
      /**
       * Destroys the touch hooks.
       * @private
       */
      _destroyTouchHook() {
        if (!this._hookDiv) {
          return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
      }
      /**
       * Activating will cause the Accessibility layer to be shown.
       * This is called when a user presses the tab key.
       * @private
       */
      _activate() {
        if (this._isActive) {
          return;
        }
        this._isActive = true;
        if (!this._div) {
          this._div = document.createElement("div");
          this._div.style.position = "absolute";
          this._div.style.top = `${DIV_TOUCH_POS_X}px`;
          this._div.style.left = `${DIV_TOUCH_POS_Y}px`;
          this._div.style.pointerEvents = "none";
          this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          this._canvasObserver = new CanvasObserver({
            domElement: this._div,
            renderer: this._renderer
          });
        }
        if (this._activateOnTab) {
          globalThis.addEventListener("keydown", this._boundOnKeyDown, false);
        }
        if (this._deactivateOnMouseMove) {
          globalThis.document.addEventListener("mousemove", this._boundOnMouseMove, true);
        }
        const canvas = this._renderer.view.canvas;
        if (!canvas.parentNode) {
          const observer = new MutationObserver(() => {
            if (canvas.parentNode) {
              observer.disconnect();
              this._canvasObserver.ensureAttached();
              this._initAccessibilitySetup();
            }
          });
          observer.observe(document.body, { childList: true, subtree: true });
        } else {
          this._canvasObserver.ensureAttached();
          this._initAccessibilitySetup();
        }
      }
      // New method to handle initialization after div is ready
      _initAccessibilitySetup() {
        this._renderer.runners.postrender.add(this);
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        }
      }
      /**
       * Deactivates the accessibility system. Removes listeners and accessibility elements.
       * @private
       */
      _deactivate() {
        if (!this._isActive || this._isMobileAccessibility) {
          return;
        }
        this._isActive = false;
        globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);
        if (this._activateOnTab) {
          globalThis.addEventListener("keydown", this._boundOnKeyDown, false);
        }
        this._renderer.runners.postrender.remove(this);
        for (const child of this._children) {
          if (child._accessibleDiv && child._accessibleDiv.parentNode) {
            child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
            child._accessibleDiv = null;
          }
          child._accessibleActive = false;
        }
        for (const accessibleType in this._pools) {
          const pool = this._pools[accessibleType];
          pool.forEach((div) => {
            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
          });
          delete this._pools[accessibleType];
        }
        if (this._div && this._div.parentNode) {
          this._div.parentNode.removeChild(this._div);
        }
        this._pools = {};
        this._children = [];
      }
      /**
       * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
       * @private
       * @param {Container} container - The Container to check.
       */
      _updateAccessibleObjects(container) {
        if (!container.visible || !container.accessibleChildren) {
          return;
        }
        if (container.accessible) {
          if (!container._accessibleActive) {
            this._addChild(container);
          }
          container._renderId = this._renderId;
        }
        const children = container.children;
        if (children) {
          for (let i2 = 0; i2 < children.length; i2++) {
            this._updateAccessibleObjects(children[i2]);
          }
        }
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        const defaultOpts = _AccessibilitySystem2.defaultOptions;
        const mergedOptions = {
          accessibilityOptions: {
            ...defaultOpts,
            ...options?.accessibilityOptions || {}
          }
        };
        this.debug = mergedOptions.accessibilityOptions.debug;
        this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;
        this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;
        if (mergedOptions.accessibilityOptions.enabledByDefault) {
          this._activate();
        }
        this._renderer.runners.postrender.remove(this);
      }
      /**
       * Updates the accessibility layer during rendering.
       * - Removes divs for containers no longer in the scene
       * - Updates the position and dimensions of the root div
       * - Updates positions of active accessibility divs
       * Only fires while the accessibility system is active.
       * @ignore
       */
      postrender() {
        const now = performance.now();
        if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
          return;
        }
        this._androidUpdateCount = now + this._androidUpdateFrequency;
        if ((!this._renderer.renderingToScreen || !this._renderer.view.canvas) && !this._isRunningTests) {
          return;
        }
        const activeIds = /* @__PURE__ */ new Set();
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          for (const child of this._children) {
            if (child._renderId === this._renderId) {
              activeIds.add(this._children.indexOf(child));
            }
          }
        }
        for (let i2 = this._children.length - 1; i2 >= 0; i2--) {
          const child = this._children[i2];
          if (!activeIds.has(i2)) {
            if (child._accessibleDiv && child._accessibleDiv.parentNode) {
              child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
              const pool = this._getPool(child.accessibleType);
              pool.push(child._accessibleDiv);
              child._accessibleDiv = null;
            }
            child._accessibleActive = false;
            removeItems(this._children, i2, 1);
          }
        }
        if (this._renderer.renderingToScreen) {
          this._canvasObserver.ensureAttached();
        }
        for (let i2 = 0; i2 < this._children.length; i2++) {
          const child = this._children[i2];
          if (!child._accessibleActive || !child._accessibleDiv) {
            continue;
          }
          const div = child._accessibleDiv;
          const hitArea = child.hitArea || child.getBounds().rectangle;
          if (child.hitArea) {
            const wt = child.worldTransform;
            div.style.left = `${wt.tx + hitArea.x * wt.a}px`;
            div.style.top = `${wt.ty + hitArea.y * wt.d}px`;
            div.style.width = `${hitArea.width * wt.a}px`;
            div.style.height = `${hitArea.height * wt.d}px`;
          } else {
            this._capHitArea(hitArea);
            div.style.left = `${hitArea.x}px`;
            div.style.top = `${hitArea.y}px`;
            div.style.width = `${hitArea.width}px`;
            div.style.height = `${hitArea.height}px`;
          }
        }
        this._renderId++;
      }
      /**
       * private function that will visually add the information to the
       * accessibility div
       * @param {HTMLElement} div -
       */
      _updateDebugHTML(div) {
        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
      }
      /**
       * Adjust the hit area based on the bounds of a display object
       * @param {Rectangle} hitArea - Bounds of the child
       */
      _capHitArea(hitArea) {
        if (hitArea.x < 0) {
          hitArea.width += hitArea.x;
          hitArea.x = 0;
        }
        if (hitArea.y < 0) {
          hitArea.height += hitArea.y;
          hitArea.y = 0;
        }
        const { width: viewWidth, height: viewHeight } = this._renderer;
        if (hitArea.x + hitArea.width > viewWidth) {
          hitArea.width = viewWidth - hitArea.x;
        }
        if (hitArea.y + hitArea.height > viewHeight) {
          hitArea.height = viewHeight - hitArea.y;
        }
      }
      /**
       * Creates or reuses a div element for a Container and adds it to the accessibility layer.
       * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.
       * @private
       * @param {Container} container - The child to make accessible.
       */
      _addChild(container) {
        const pool = this._getPool(container.accessibleType);
        let div = pool.pop();
        if (div) {
          div.innerHTML = "";
          div.removeAttribute("title");
          div.removeAttribute("aria-label");
          div.tabIndex = 0;
        } else {
          if (container.accessibleType === "button") {
            div = document.createElement("button");
          } else {
            div = document.createElement(container.accessibleType);
            div.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `;
            if (container.accessibleText) {
              div.innerText = container.accessibleText;
            }
          }
          div.style.width = `${DIV_TOUCH_SIZE}px`;
          div.style.height = `${DIV_TOUCH_SIZE}px`;
          div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
          div.style.position = "absolute";
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          div.style.borderStyle = "none";
          if (navigator.userAgent.toLowerCase().includes("chrome")) {
            div.setAttribute("aria-live", "off");
          } else {
            div.setAttribute("aria-live", "polite");
          }
          if (navigator.userAgent.match(/rv:.*Gecko\//)) {
            div.setAttribute("aria-relevant", "additions");
          } else {
            div.setAttribute("aria-relevant", "text");
          }
          div.addEventListener("click", this._onClick.bind(this));
          div.addEventListener("focus", this._onFocus.bind(this));
          div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = container.accessiblePointerEvents;
        div.type = container.accessibleType;
        if (container.accessibleTitle && container.accessibleTitle !== null) {
          div.title = container.accessibleTitle;
        } else if (!container.accessibleHint || container.accessibleHint === null) {
          div.title = `container ${container.tabIndex}`;
        }
        if (container.accessibleHint && container.accessibleHint !== null) {
          div.setAttribute("aria-label", container.accessibleHint);
        }
        if (container.interactive) {
          div.tabIndex = container.tabIndex;
        } else {
          div.tabIndex = 0;
        }
        if (this.debug) {
          this._updateDebugHTML(div);
        }
        container._accessibleActive = true;
        container._accessibleDiv = div;
        div.container = container;
        this._children.push(container);
        this._div.appendChild(container._accessibleDiv);
      }
      /**
       * Dispatch events with the EventSystem.
       * @param e
       * @param type
       * @private
       */
      _dispatchEvent(e2, type) {
        const { container: target } = e2.target;
        const boundary = this._renderer.events.rootBoundary;
        const event = Object.assign(new FederatedEvent(boundary), { target });
        boundary.rootTarget = this._renderer.lastObjectRendered;
        type.forEach((type2) => boundary.dispatchEvent(event, type2));
      }
      /**
       * Maps the div button press to pixi's EventSystem (click)
       * @private
       * @param {MouseEvent} e - The click event.
       */
      _onClick(e2) {
        this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseover)
       * @private
       * @param {FocusEvent} e - The focus event.
       */
      _onFocus(e2) {
        if (!e2.target.getAttribute("aria-live")) {
          e2.target.setAttribute("aria-live", "assertive");
        }
        this._dispatchEvent(e2, ["mouseover"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseout)
       * @private
       * @param {FocusEvent} e - The focusout event.
       */
      _onFocusOut(e2) {
        if (!e2.target.getAttribute("aria-live")) {
          e2.target.setAttribute("aria-live", "polite");
        }
        this._dispatchEvent(e2, ["mouseout"]);
      }
      /**
       * Is called when a key is pressed
       * @private
       * @param {KeyboardEvent} e - The keydown event.
       */
      _onKeyDown(e2) {
        if (e2.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {
          return;
        }
        this._activate();
      }
      /**
       * Is called when the mouse moves across the renderer element
       * @private
       * @param {MouseEvent} e - The mouse event.
       */
      _onMouseMove(e2) {
        if (e2.movementX === 0 && e2.movementY === 0) {
          return;
        }
        this._deactivate();
      }
      /**
       * Destroys the accessibility system. Removes all elements and listeners.
       * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.
       * > A typically user should not need to call this method directly.
       */
      destroy() {
        this._deactivate();
        this._destroyTouchHook();
        this._canvasObserver?.destroy();
        this._canvasObserver = null;
        this._div = null;
        this._pools = null;
        this._children = null;
        this._renderer = null;
        this._hookDiv = null;
        globalThis.removeEventListener("keydown", this._boundOnKeyDown);
        this._boundOnKeyDown = null;
        globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);
        this._boundOnMouseMove = null;
      }
      /**
       * Enables or disables the accessibility system.
       * @param enabled - Whether to enable or disable accessibility.
       * @example
       * ```js
       * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility
       * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility
       * ```
       */
      setAccessibilityEnabled(enabled) {
        if (enabled) {
          this._activate();
        } else {
          this._deactivate();
        }
      }
      _getPool(accessibleType) {
        if (!this._pools[accessibleType]) {
          this._pools[accessibleType] = [];
        }
        return this._pools[accessibleType];
      }
    };
    _AccessibilitySystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "accessibility"
    };
    _AccessibilitySystem.defaultOptions = {
      /**
       * Whether to enable accessibility features on initialization
       * @default false
       */
      enabledByDefault: false,
      /**
       * Whether to visually show the accessibility divs for debugging
       * @default false
       */
      debug: false,
      /**
       * Whether to activate accessibility when tab key is pressed
       * @default true
       */
      activateOnTab: true,
      /**
       * Whether to deactivate accessibility when mouse moves
       * @default true
       */
      deactivateOnMouseMove: true
    };
    AccessibilitySystem = _AccessibilitySystem;
  }
});

// node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
var accessibilityTarget;
var init_accessibilityTarget = __esm({
  "node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
    "use strict";
    accessibilityTarget = {
      accessible: false,
      accessibleTitle: null,
      accessibleHint: null,
      tabIndex: 0,
      accessibleType: "button",
      accessibleText: null,
      accessiblePointerEvents: "auto",
      accessibleChildren: true,
      _accessibleActive: false,
      _accessibleDiv: null,
      _renderId: -1
    };
  }
});

// node_modules/pixi.js/lib/accessibility/init.mjs
var init_init = __esm({
  "node_modules/pixi.js/lib/accessibility/init.mjs"() {
    init_Extensions();
    init_Container();
    init_AccessibilitySystem();
    init_accessibilityTarget();
    extensions.add(AccessibilitySystem);
    extensions.mixin(Container, accessibilityTarget);
  }
});

// node_modules/pixi.js/lib/app/ResizePlugin.mjs
var ResizePlugin;
var init_ResizePlugin = __esm({
  "node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
    init_Extensions();
    ResizePlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        Object.defineProperty(
          this,
          "resizeTo",
          {
            set(dom) {
              globalThis.removeEventListener("resize", this.queueResize);
              this._resizeTo = dom;
              if (dom) {
                globalThis.addEventListener("resize", this.queueResize);
                this.resize();
              }
            },
            get() {
              return this._resizeTo;
            }
          }
        );
        this.queueResize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          this._resizeId = requestAnimationFrame(() => this.resize());
        };
        this._cancelResize = () => {
          if (this._resizeId) {
            cancelAnimationFrame(this._resizeId);
            this._resizeId = null;
          }
        };
        this.resize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          let width;
          let height;
          if (this._resizeTo === globalThis.window) {
            width = globalThis.innerWidth;
            height = globalThis.innerHeight;
          } else {
            const { clientWidth, clientHeight } = this._resizeTo;
            width = clientWidth;
            height = clientHeight;
          }
          this.renderer.resize(width, height);
          this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      }
      /**
       * Clean up the ticker, scoped to application
       * @private
       */
      static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this._cancelResize();
        this._cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      }
    };
    ResizePlugin.extension = ExtensionType.Application;
  }
});

// node_modules/pixi.js/lib/app/TickerPlugin.mjs
var TickerPlugin;
var init_TickerPlugin = __esm({
  "node_modules/pixi.js/lib/app/TickerPlugin.mjs"() {
    init_Extensions();
    init_const2();
    init_Ticker();
    TickerPlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(
          this,
          "ticker",
          {
            set(ticker) {
              if (this._ticker) {
                this._ticker.remove(this.render, this);
              }
              this._ticker = ticker;
              if (ticker) {
                ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
              }
            },
            get() {
              return this._ticker;
            }
          }
        );
        this.stop = () => {
          this._ticker.stop();
        };
        this.start = () => {
          this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      }
      /**
       * Clean up the ticker, scoped to application.
       * @private
       */
      static destroy() {
        if (this._ticker) {
          const oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      }
    };
    TickerPlugin.extension = ExtensionType.Application;
  }
});

// node_modules/pixi.js/lib/app/init.mjs
var init_init2 = __esm({
  "node_modules/pixi.js/lib/app/init.mjs"() {
    init_Extensions();
    init_ResizePlugin();
    init_TickerPlugin();
    extensions.add(ResizePlugin);
    extensions.add(TickerPlugin);
  }
});

// node_modules/pixi.js/lib/events/EventTicker.mjs
var EventsTickerClass, EventsTicker;
var init_EventTicker = __esm({
  "node_modules/pixi.js/lib/events/EventTicker.mjs"() {
    init_const2();
    init_Ticker();
    EventsTickerClass = class {
      constructor() {
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /**
       * Initializes the event ticker.
       * @param events - The event system.
       */
      init(events) {
        this.removeTickerListener();
        this.events = events;
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /** Whether to pause the update checks or not. */
      get pauseUpdate() {
        return this._pauseUpdate;
      }
      set pauseUpdate(paused) {
        this._pauseUpdate = paused;
      }
      /** Adds the ticker listener. */
      addTickerListener() {
        if (this._tickerAdded || !this.domElement) {
          return;
        }
        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
        this._tickerAdded = true;
      }
      /** Removes the ticker listener. */
      removeTickerListener() {
        if (!this._tickerAdded) {
          return;
        }
        Ticker.system.remove(this._tickerUpdate, this);
        this._tickerAdded = false;
      }
      /** Sets flag to not fire extra events when the user has already moved there mouse */
      pointerMoved() {
        this._didMove = true;
      }
      /** Updates the state of interactive objects. */
      _update() {
        if (!this.domElement || this._pauseUpdate) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        const rootPointerEvent = this.events["_rootPointerEvent"];
        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
          return;
        }
        globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", {
          clientX: rootPointerEvent.clientX,
          clientY: rootPointerEvent.clientY,
          pointerType: rootPointerEvent.pointerType,
          pointerId: rootPointerEvent.pointerId
        }) : new MouseEvent("mousemove", {
          clientX: rootPointerEvent.clientX,
          clientY: rootPointerEvent.clientY
        }));
      }
      /**
       * Updates the state of interactive objects if at least {@link interactionFrequency}
       * milliseconds have passed since the last invocation.
       *
       * Invoked by a throttled ticker update from {@link Ticker.system}.
       * @param ticker - The throttled ticker.
       */
      _tickerUpdate(ticker) {
        this._deltaTime += ticker.deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this._update();
      }
      /** Destroys the event ticker. */
      destroy() {
        this.removeTickerListener();
        this.events = null;
        this.domElement = null;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
    };
    EventsTicker = new EventsTickerClass();
  }
});

// node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
var FederatedMouseEvent;
var init_FederatedMouseEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
    init_Point();
    init_FederatedEvent();
    FederatedMouseEvent = class extends FederatedEvent {
      constructor() {
        super(...arguments);
        this.client = new Point();
        this.movement = new Point();
        this.offset = new Point();
        this.global = new Point();
        this.screen = new Point();
      }
      /** @readonly */
      get clientX() {
        return this.client.x;
      }
      /** @readonly */
      get clientY() {
        return this.client.y;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
       * @readonly
       */
      get x() {
        return this.clientX;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
       * @readonly
       */
      get y() {
        return this.clientY;
      }
      /** @readonly */
      get movementX() {
        return this.movement.x;
      }
      /** @readonly */
      get movementY() {
        return this.movement.y;
      }
      /** @readonly */
      get offsetX() {
        return this.offset.x;
      }
      /** @readonly */
      get offsetY() {
        return this.offset.y;
      }
      /** @readonly */
      get globalX() {
        return this.global.x;
      }
      /** @readonly */
      get globalY() {
        return this.global.y;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for `screen.x`.
       * @readonly
       */
      get screenX() {
        return this.screen.x;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for `screen.y`.
       * @readonly
       */
      get screenY() {
        return this.screen.y;
      }
      /**
       * Converts global coordinates into container-local coordinates.
       *
       * This method transforms coordinates from world space to a container's local space,
       * useful for precise positioning and hit testing.
       * @param container - The Container to get local coordinates for
       * @param point - Optional Point object to store the result. If not provided, a new Point will be created
       * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used
       * @returns The local coordinates as a Point object
       * @example
       * ```ts
       * // Basic usage - get local coordinates relative to a container
       * sprite.on('pointermove', (event: FederatedMouseEvent) => {
       *     // Get position relative to the sprite
       *     const localPos = event.getLocalPosition(sprite);
       *     console.log('Local position:', localPos.x, localPos.y);
       * });
       * // Using custom global coordinates
       * const customGlobal = new Point(100, 100);
       * sprite.on('pointermove', (event: FederatedMouseEvent) => {
       *     // Transform custom coordinates
       *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);
       *     console.log('Custom local position:', localPos.x, localPos.y);
       * });
       * ```
       * @see {@link Container.worldTransform} For the transformation matrix
       * @see {@link Point} For the point class used to store coordinates
       */
      getLocalPosition(container, point, globalPos) {
        return container.worldTransform.applyInverse(globalPos || this.global, point);
      }
      /**
       * Whether the modifier key was pressed when this event natively occurred.
       * @param key - The modifier key.
       */
      getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
      /**
       * Not supported.
       * @param _typeArg
       * @param _canBubbleArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       * @param _screenXArg
       * @param _screenYArg
       * @param _clientXArg
       * @param _clientYArg
       * @param _ctrlKeyArg
       * @param _altKeyArg
       * @param _shiftKeyArg
       * @param _metaKeyArg
       * @param _buttonArg
       * @param _relatedTargetArg
       * @deprecated since 7.0.0
       * @ignore
       */
      // eslint-disable-next-line max-params
      initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
      }
    };
  }
});

// node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
var FederatedPointerEvent;
var init_FederatedPointerEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedPointerEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.width = 0;
        this.height = 0;
        this.isPrimary = false;
      }
      /**
       * Only included for completeness for now
       * @ignore
       */
      getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
      /**
       * Only included for completeness for now
       * @ignore
       */
      getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
    };
  }
});

// node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
var FederatedWheelEvent;
var init_FederatedWheelEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedWheelEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.DOM_DELTA_PIXEL = 0;
        this.DOM_DELTA_LINE = 1;
        this.DOM_DELTA_PAGE = 2;
      }
    };
    FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
    FederatedWheelEvent.DOM_DELTA_LINE = 1;
    FederatedWheelEvent.DOM_DELTA_PAGE = 2;
  }
});

// node_modules/pixi.js/lib/events/EventBoundary.mjs
var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
var init_EventBoundary = __esm({
  "node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
    init_eventemitter3();
    init_Point();
    init_warn();
    init_EventTicker();
    init_FederatedMouseEvent();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    PROPAGATION_LIMIT = 2048;
    tempHitLocation = new Point();
    tempLocalMapping = new Point();
    EventBoundary = class {
      /**
       * @param rootTarget - The holder of the event boundary.
       */
      constructor(rootTarget) {
        this.dispatch = new eventemitter3_default();
        this.moveOnAll = false;
        this.enableGlobalMoveEvents = true;
        this.mappingState = {
          trackingData: {}
        };
        this.eventPool = /* @__PURE__ */ new Map();
        this._allInteractiveElements = [];
        this._hitElements = [];
        this._isPointerMoveEvent = false;
        this.rootTarget = rootTarget;
        this.hitPruneFn = this.hitPruneFn.bind(this);
        this.hitTestFn = this.hitTestFn.bind(this);
        this.mapPointerDown = this.mapPointerDown.bind(this);
        this.mapPointerMove = this.mapPointerMove.bind(this);
        this.mapPointerOut = this.mapPointerOut.bind(this);
        this.mapPointerOver = this.mapPointerOver.bind(this);
        this.mapPointerUp = this.mapPointerUp.bind(this);
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
        this.mapWheel = this.mapWheel.bind(this);
        this.mappingTable = {};
        this.addEventMapping("pointerdown", this.mapPointerDown);
        this.addEventMapping("pointermove", this.mapPointerMove);
        this.addEventMapping("pointerout", this.mapPointerOut);
        this.addEventMapping("pointerleave", this.mapPointerOut);
        this.addEventMapping("pointerover", this.mapPointerOver);
        this.addEventMapping("pointerup", this.mapPointerUp);
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
        this.addEventMapping("wheel", this.mapWheel);
      }
      /**
       * Adds an event mapping for the event `type` handled by `fn`.
       *
       * Event mappings can be used to implement additional or custom events. They take an event
       * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
       * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
       *
       * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
       * instead.
       * @param type - The type of upstream event to map.
       * @param fn - The mapping method. The context of this function must be bound manually, if desired.
       */
      addEventMapping(type, fn) {
        if (!this.mappingTable[type]) {
          this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
          fn,
          priority: 0
        });
        this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
      }
      /**
       * Dispatches the given event
       * @param e - The event to dispatch.
       * @param type - The type of event to dispatch. Defaults to `e.type`.
       */
      dispatchEvent(e2, type) {
        e2.propagationStopped = false;
        e2.propagationImmediatelyStopped = false;
        this.propagate(e2, type);
        this.dispatch.emit(type || e2.type, e2);
      }
      /**
       * Maps the given upstream event through the event boundary and propagates it downstream.
       * @param e - The event to map.
       */
      mapEvent(e2) {
        if (!this.rootTarget) {
          return;
        }
        const mappers = this.mappingTable[e2.type];
        if (mappers) {
          for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++) {
            mappers[i2].fn(e2);
          }
        } else {
          warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
        }
      }
      /**
       * Finds the Container that is the target of a event at the given coordinates.
       *
       * The passed (x,y) coordinates are in the world space above this event boundary.
       * @param x - The x coordinate of the event.
       * @param y - The y coordinate of the event.
       */
      hitTest(x2, y2) {
        EventsTicker.pauseUpdate = true;
        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
        const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
        const invertedPath = this[fn](
          this.rootTarget,
          this.rootTarget.eventMode,
          tempHitLocation.set(x2, y2),
          this.hitTestFn,
          this.hitPruneFn
        );
        return invertedPath && invertedPath[0];
      }
      /**
       * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
       * target `e.target`.
       * @param e - The event to propagate.
       * @param type - The type of event to propagate. Defaults to `e.type`.
       */
      propagate(e2, type) {
        if (!e2.target) {
          return;
        }
        const composedPath = e2.composedPath();
        e2.eventPhase = e2.CAPTURING_PHASE;
        for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++) {
          e2.currentTarget = composedPath[i2];
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
        }
        e2.eventPhase = e2.AT_TARGET;
        e2.currentTarget = e2.target;
        this.notifyTarget(e2, type);
        if (e2.propagationStopped || e2.propagationImmediatelyStopped)
          return;
        e2.eventPhase = e2.BUBBLING_PHASE;
        for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
          e2.currentTarget = composedPath[i2];
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
        }
      }
      /**
       * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.
       *
       * This is used in the `globalpointermove` event.
       * @param e - The emitted event.
       * @param type - The listeners to notify.
       * @param targets - The targets to notify.
       */
      all(e2, type, targets = this._allInteractiveElements) {
        if (targets.length === 0)
          return;
        e2.eventPhase = e2.BUBBLING_PHASE;
        const events = Array.isArray(type) ? type : [type];
        for (let i2 = targets.length - 1; i2 >= 0; i2--) {
          events.forEach((event) => {
            e2.currentTarget = targets[i2];
            this.notifyTarget(e2, event);
          });
        }
      }
      /**
       * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
       * `target`. The last element in the path is `target`.
       * @param target - The target to find the propagation path to.
       */
      propagationPath(target) {
        const propagationPath = [target];
        for (let i2 = 0; i2 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i2++) {
          if (!target.parent) {
            throw new Error("Cannot find propagation path to disconnected target");
          }
          propagationPath.push(target.parent);
          target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
      }
      hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
        let shouldReturn = false;
        if (this._interactivePrune(currentTarget))
          return null;
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          for (let i2 = children.length - 1; i2 >= 0; i2--) {
            const child = children[i2];
            const nestedHit = this.hitTestMoveRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              location,
              testFn,
              pruneFn,
              ignore || pruneFn(currentTarget, location)
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive) {
                if (isInteractive)
                  this._allInteractiveElements.push(currentTarget);
                nestedHit.push(currentTarget);
              }
              if (this._hitElements.length === 0)
                this._hitElements = nestedHit;
              shouldReturn = true;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveTarget && isInteractiveTarget)
          this._allInteractiveElements.push(currentTarget);
        if (ignore || this._hitElements.length > 0)
          return null;
        if (shouldReturn)
          return this._hitElements;
        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      /**
       * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
       * @param currentTarget - The Container that is to be hit tested.
       * @param eventMode - The event mode for the `currentTarget` or one of its parents.
       * @param location - The location that is being tested for overlap.
       * @param testFn - Callback that determines whether the target passes hit testing. This callback
       *  can assume that `pruneFn` failed to prune the container.
       * @param pruneFn - Callback that determiness whether the target and all of its children
       *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
       *  of the scene graph.
       * @returns An array holding the hit testing target and all its ancestors in order. The first element
       *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
       *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
       */
      hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
          return null;
        }
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          const relativeLocation = location;
          for (let i2 = children.length - 1; i2 >= 0; i2--) {
            const child = children[i2];
            const nestedHit = this.hitTestRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              relativeLocation,
              testFn,
              pruneFn
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive)
                nestedHit.push(currentTarget);
              return nestedHit;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveMode && testFn(currentTarget, location)) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      _isInteractive(int) {
        return int === "static" || int === "dynamic";
      }
      _interactivePrune(container) {
        if (!container || !container.visible || !container.renderable || !container.measurable) {
          return true;
        }
        if (container.eventMode === "none") {
          return true;
        }
        if (container.eventMode === "passive" && !container.interactiveChildren) {
          return true;
        }
        return false;
      }
      /**
       * Checks whether the container or any of its children cannot pass the hit test at all.
       *
       * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
       * and {@link Container._maskEffect} for pruning.
       * @param container - The container to prune.
       * @param location - The location to test for overlap.
       */
      hitPruneFn(container, location) {
        if (container.hitArea) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
            return true;
          }
        }
        if (container.effects && container.effects.length) {
          for (let i2 = 0; i2 < container.effects.length; i2++) {
            const effect = container.effects[i2];
            if (effect.containsPoint) {
              const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
              if (!effectContainsPoint) {
                return true;
              }
            }
          }
        }
        return false;
      }
      /**
       * Checks whether the container passes hit testing for the given location.
       * @param container - The container to test.
       * @param location - The location to test for overlap.
       * @returns - Whether `container` passes hit testing for `location`.
       */
      hitTestFn(container, location) {
        if (container.hitArea) {
          return true;
        }
        if (container?.containsPoint) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          return container.containsPoint(tempLocalMapping);
        }
        return false;
      }
      /**
       * Notify all the listeners to the event's `currentTarget`.
       *
       * If the `currentTarget` contains the property `on<type>`, then it is called here,
       * simulating the behavior from version 6.x and prior.
       * @param e - The event passed to the target.
       * @param type - The type of event to notify. Defaults to `e.type`.
       */
      notifyTarget(e2, type) {
        if (!e2.currentTarget.isInteractive()) {
          return;
        }
        type ?? (type = e2.type);
        const handlerKey = `on${type}`;
        e2.currentTarget[handlerKey]?.(e2);
        const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
        this._notifyListeners(e2, key);
        if (e2.eventPhase === e2.AT_TARGET) {
          this._notifyListeners(e2, type);
        }
      }
      /**
       * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
       *
       * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
       * @param from - The upstream `pointerdown` event.
       */
      mapPointerDown(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const e2 = this.createPointerEvent(from);
        this.dispatchEvent(e2, "pointerdown");
        if (e2.pointerType === "touch") {
          this.dispatchEvent(e2, "touchstart");
        } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
          const isRightButton = e2.button === 2;
          this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
        }
        const trackingData = this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e2.composedPath();
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
       *
       * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
       * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
       * @param from - The upstream `pointermove` event.
       */
      mapPointerMove(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = true;
        const e2 = this.createPointerEvent(from);
        this._isPointerMoveEvent = false;
        const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
        const trackingData = this.trackingData(from.pointerId);
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
          const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          const outEvent = this.createPointerEvent(from, outType, outTarget);
          this.dispatchEvent(outEvent, "pointerout");
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          if (!e2.composedPath().includes(outTarget)) {
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            this.freeEvent(leaveEvent);
          }
          this.freeEvent(outEvent);
        }
        if (outTarget !== e2.target) {
          const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          const overEvent = this.clonePointerEvent(e2, overType);
          this.dispatchEvent(overEvent, "pointerover");
          if (isMouse)
            this.dispatchEvent(overEvent, "mouseover");
          let overTargetAncestor = outTarget?.parent;
          while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
            if (overTargetAncestor === e2.target)
              break;
            overTargetAncestor = overTargetAncestor.parent;
          }
          const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
          if (didPointerEnter) {
            const enterEvent = this.clonePointerEvent(e2, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
              enterEvent.currentTarget = enterEvent.target;
              this.notifyTarget(enterEvent);
              if (isMouse)
                this.notifyTarget(enterEvent, "mouseenter");
              enterEvent.target = enterEvent.target.parent;
            }
            this.freeEvent(enterEvent);
          }
          this.freeEvent(overEvent);
        }
        const allMethods = [];
        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
        allowGlobalPointerEvents && allMethods.push("globalpointermove");
        if (e2.pointerType === "touch") {
          this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
          allowGlobalPointerEvents && allMethods.push("globaltouchmove");
        }
        if (isMouse) {
          this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
          allowGlobalPointerEvents && allMethods.push("globalmousemove");
          this.cursor = e2.target?.cursor;
        }
        if (allMethods.length > 0) {
          this.all(e2, allMethods);
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e2.composedPath();
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
       *
       * The tracking data for the specific pointer gets a new `overTarget`.
       * @param from - The upstream `pointerover` event.
       */
      mapPointerOver(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const e2 = this.createPointerEvent(from);
        const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
        this.dispatchEvent(e2, "pointerover");
        if (isMouse)
          this.dispatchEvent(e2, "mouseover");
        if (e2.pointerType === "mouse")
          this.cursor = e2.target?.cursor;
        const enterEvent = this.clonePointerEvent(e2, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = e2.composedPath();
        this.freeEvent(e2);
        this.freeEvent(enterEvent);
      }
      /**
       * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
       *
       * The tracking data for the specific pointer is cleared of a `overTarget`.
       * @param from - The upstream `pointerout` event.
       */
      mapPointerOut(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
          this.dispatchEvent(outEvent);
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
            leaveEvent.currentTarget = leaveEvent.target;
            this.notifyTarget(leaveEvent);
            if (isMouse)
              this.notifyTarget(leaveEvent, "mouseleave");
            leaveEvent.target = leaveEvent.target.parent;
          }
          trackingData.overTargets = null;
          this.freeEvent(outEvent);
          this.freeEvent(leaveEvent);
        }
        this.cursor = null;
      }
      /**
       * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
       * and `click`/`rightclick`/`pointertap` events, in that order.
       *
       * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
       * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
       * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
       * specific pointer types.
       * @param from - The upstream `pointerup` event.
       */
      mapPointerUp(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const now = performance.now();
        const e2 = this.createPointerEvent(from);
        this.dispatchEvent(e2, "pointerup");
        if (e2.pointerType === "touch") {
          this.dispatchEvent(e2, "touchend");
        } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
          const isRightButton = e2.button === 2;
          this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        let clickTarget = pressTarget;
        if (pressTarget && !e2.composedPath().includes(pressTarget)) {
          let currentTarget = pressTarget;
          while (currentTarget && !e2.composedPath().includes(currentTarget)) {
            e2.currentTarget = currentTarget;
            this.notifyTarget(e2, "pointerupoutside");
            if (e2.pointerType === "touch") {
              this.notifyTarget(e2, "touchendoutside");
            } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
              const isRightButton = e2.button === 2;
              this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          const clickEvent = this.clonePointerEvent(e2, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = null;
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now
            };
          }
          const clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now;
          clickEvent.detail = clickHistory.clickCount;
          if (clickEvent.pointerType === "mouse") {
            const isRightButton = clickEvent.button === 2;
            this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
          } else if (clickEvent.pointerType === "touch") {
            this.dispatchEvent(clickEvent, "tap");
          }
          this.dispatchEvent(clickEvent, "pointertap");
          this.freeEvent(clickEvent);
        }
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
       * `pointerdown` target to `rootTarget`.
       *
       * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
       * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
       *
       * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
       * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
       * @param from - The upstream `pointerupoutside` event.
       */
      mapPointerUpOutside(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        const e2 = this.createPointerEvent(from);
        if (pressTarget) {
          let currentTarget = pressTarget;
          while (currentTarget) {
            e2.currentTarget = currentTarget;
            this.notifyTarget(e2, "pointerupoutside");
            if (e2.pointerType === "touch") {
              this.notifyTarget(e2, "touchendoutside");
            } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
              this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `wheel` event to a downstream `wheel` event.
       * @param from - The upstream `wheel` event.
       */
      mapWheel(from) {
        if (!(from instanceof FederatedWheelEvent)) {
          warn("EventBoundary cannot map a non-wheel event as a wheel event");
          return;
        }
        const wheelEvent = this.createWheelEvent(from);
        this.dispatchEvent(wheelEvent);
        this.freeEvent(wheelEvent);
      }
      /**
       * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
       *
       * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
       * or `pointerover` target was unmounted from the scene graph.
       * @param propagationPath - The propagation path was valid in the past.
       * @returns - The most specific event-target still mounted at the same location in the scene graph.
       */
      findMountedTarget(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        let currentTarget = propagationPath[0];
        for (let i2 = 1; i2 < propagationPath.length; i2++) {
          if (propagationPath[i2].parent === currentTarget) {
            currentTarget = propagationPath[i2];
          } else {
            break;
          }
        }
        return currentTarget;
      }
      /**
       * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The `originalEvent` for the returned event.
       * @param [type=from.type] - The type of the returned event.
       * @param target - The target of the returned event.
       */
      createPointerEvent(from, type, target) {
        const event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
        if (typeof type === "string") {
          event.type = type;
        }
        return event;
      }
      /**
       * Creates a wheel event whose `originalEvent` is `from`.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The upstream wheel event.
       */
      createWheelEvent(from) {
        const event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = this.hitTest(event.global.x, event.global.y);
        return event;
      }
      /**
       * Clones the event `from`, with an optional `type` override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The event to clone.
       * @param [type=from.type] - The type of the returned event.
       */
      clonePointerEvent(from, type) {
        const event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type ?? event.type;
        return event;
      }
      /**
       * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.
       *
       * The following properties are copied:
       * + deltaMode
       * + deltaX
       * + deltaY
       * + deltaZ
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      }
      /**
       * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.
       *
       * The following properties are copied:
       * + pointerId
       * + width
       * + height
       * + isPrimary
       * + pointerType
       * + pressure
       * + tangentialPressure
       * + tiltX
       * + tiltY
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyPointerData(from, to) {
        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
          return;
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      }
      /**
       * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.
       *
       * The following properties are copied:
       * + altKey
       * + button
       * + buttons
       * + clientX
       * + clientY
       * + metaKey
       * + movementX
       * + movementY
       * + pageX
       * + pageY
       * + x
       * + y
       * + screen
       * + shiftKey
       * + global
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyMouseData(from, to) {
        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
          return;
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.client.copyFrom(from.client);
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.movement.copyFrom(from.movement);
        to.screen.copyFrom(from.screen);
        to.shiftKey = from.shiftKey;
        to.global.copyFrom(from.global);
      }
      /**
       * Copies base {@link FederatedEvent} data from `from` into `to`.
       *
       * The following properties are copied:
       * + isTrusted
       * + srcElement
       * + timeStamp
       * + type
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = performance.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.copyFrom(from.layer);
        to.page.copyFrom(from.page);
      }
      /**
       * @param id - The pointer ID.
       * @returns The tracking data stored for the given pointer. If no data exists, a blank
       *  state will be created.
       */
      trackingData(id) {
        if (!this.mappingState.trackingData[id]) {
          this.mappingState.trackingData[id] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id];
      }
      /**
       * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
       *
       * This allocation is constructor-agnostic, as long as it only takes one argument - this event
       * boundary.
       * @param constructor - The event's constructor.
       * @returns An event of the given type.
       */
      allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        const event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.defaultPrevented = false;
        event.path = null;
        event.target = null;
        return event;
      }
      /**
       * Frees the event and puts it back into the event pool.
       *
       * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
       *
       * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
       * not be freed. This is because of the possibility that the same event is freed twice, which can cause
       * it to be allocated twice & result in overwriting.
       * @param event - The event to be freed.
       * @throws Error if the event is managed by another event boundary.
       */
      freeEvent(event) {
        if (event.manager !== this)
          throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      }
      /**
       * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
       * is set on the event.
       * @param e - The event to call each listener with.
       * @param type - The event key.
       */
      _notifyListeners(e2, type) {
        const listeners = e2.currentTarget._events[type];
        if (!listeners)
          return;
        if ("fn" in listeners) {
          if (listeners.once)
            e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
          listeners.fn.call(listeners.context, e2);
        } else {
          for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e2.propagationImmediatelyStopped; i2++) {
            if (listeners[i2].once)
              e2.currentTarget.removeListener(type, listeners[i2].fn, void 0, true);
            listeners[i2].fn.call(listeners[i2].context, e2);
          }
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/events/EventSystem.mjs
var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
var init_EventSystem = __esm({
  "node_modules/pixi.js/lib/events/EventSystem.mjs"() {
    init_Extensions();
    init_EventBoundary();
    init_EventTicker();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    MOUSE_POINTER_ID = 1;
    TOUCH_TO_POINTER = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel"
    };
    _EventSystem = class _EventSystem2 {
      /**
       * @param {Renderer} renderer
       */
      constructor(renderer) {
        this.supportsTouchEvents = "ontouchstart" in globalThis;
        this.supportsPointerEvents = !!globalThis.PointerEvent;
        this.domElement = null;
        this.resolution = 1;
        this.renderer = renderer;
        this.rootBoundary = new EventBoundary(null);
        EventsTicker.init(this);
        this.autoPreventDefault = true;
        this._eventsAdded = false;
        this._rootPointerEvent = new FederatedPointerEvent(null);
        this._rootWheelEvent = new FederatedWheelEvent(null);
        this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
          set: (target, key, value) => {
            if (key === "globalMove") {
              this.rootBoundary.enableGlobalMoveEvents = value;
            }
            target[key] = value;
            return true;
          }
        });
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerMove = this._onPointerMove.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
        this._onPointerOverOut = this._onPointerOverOut.bind(this);
        this.onWheel = this.onWheel.bind(this);
      }
      /**
       * The default interaction mode for all display objects.
       * @see Container.eventMode
       * @type {EventMode}
       * @readonly
       * @since 7.2.0
       */
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        const { canvas, resolution } = this.renderer;
        this.setTargetElement(canvas);
        this.resolution = resolution;
        _EventSystem2._defaultEventMode = options.eventMode ?? "passive";
        Object.assign(this.features, options.eventFeatures ?? {});
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
      }
      /**
       * Handle changing resolution.
       * @ignore
       */
      resolutionChange(resolution) {
        this.resolution = resolution;
      }
      /** Destroys all event listeners and detaches the renderer. */
      destroy() {
        EventsTicker.destroy();
        this.setTargetElement(null);
        this.renderer = null;
        this._currentCursor = null;
      }
      /**
       * Sets the current cursor mode, handling any callbacks or CSS style changes.
       * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.
       * @param mode - Cursor mode to set. Can be:
       * - A CSS cursor string (e.g., 'pointer', 'grab')
       * - A key from the cursorStyles dictionary
       * - null/undefined to reset to default
       * @example
       * ```ts
       * // Using predefined cursor styles
       * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor
       * app.renderer.events.setCursor('grab');       // Set grab cursor
       * app.renderer.events.setCursor(null);         // Reset to default
       *
       * // Using custom cursor styles
       * app.renderer.events.cursorStyles.custom = 'url("cursor.png"), auto';
       * app.renderer.events.setCursor('custom');     // Apply custom cursor
       *
       * // Using callback-based cursor
       * app.renderer.events.cursorStyles.dynamic = (mode) => {
       *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';
       * };
       * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback
       * ```
       * @remarks
       * - Has no effect on OffscreenCanvas except for callback-based cursors
       * - Caches current cursor to avoid unnecessary DOM updates
       * - Supports CSS cursor values, style objects, and callback functions
       * @see {@link EventSystem.cursorStyles} For defining custom cursor styles
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference
       */
      setCursor(mode) {
        mode || (mode = "default");
        let applyStyles = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
          applyStyles = false;
        }
        if (this._currentCursor === mode) {
          return;
        }
        this._currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              if (applyStyles) {
                this.domElement.style.cursor = style;
              }
              break;
            case "function":
              style(mode);
              break;
            case "object":
              if (applyStyles) {
                Object.assign(this.domElement.style, style);
              }
              break;
          }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.domElement.style.cursor = mode;
        }
      }
      /**
       * The global pointer event instance containing the most recent pointer state.
       * This is useful for accessing pointer information without listening to events.
       * @example
       * ```ts
       * // Access current pointer position at any time
       * const eventSystem = app.renderer.events;
       * const pointer = eventSystem.pointer;
       *
       * // Get global coordinates
       * console.log('Position:', pointer.global.x, pointer.global.y);
       *
       * // Check button state
       * console.log('Buttons pressed:', pointer.buttons);
       *
       * // Get pointer type and pressure
       * console.log('Type:', pointer.pointerType);
       * console.log('Pressure:', pointer.pressure);
       * ```
       * @readonly
       * @since 7.2.0
       * @see {@link FederatedPointerEvent} For all available pointer properties
       */
      get pointer() {
        return this._rootPointerEvent;
      }
      /**
       * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerDown(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const events = this._normalizeToPointerData(nativeEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
          const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        for (let i2 = 0, j2 = events.length; i2 < j2; i2++) {
          const nativeEvent2 = events[i2];
          const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
          this.rootBoundary.mapEvent(federatedEvent);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch events.
       */
      _onPointerMove(nativeEvent) {
        if (!this.features.move)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        EventsTicker.pointerMoved();
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerUp(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
          target = nativeEvent.composedPath()[0];
        }
        const outside = target !== this.domElement ? "outside" : "";
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
          event.type += outside;
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerOverOut(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
       * @param nativeEvent - The native wheel event.
       */
      onWheel(nativeEvent) {
        if (!this.features.wheel)
          return;
        const wheelEvent = this.normalizeWheelEvent(nativeEvent);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        this.rootBoundary.mapEvent(wheelEvent);
      }
      /**
       * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
       * This method manages the DOM event bindings for the event system, allowing you to
       * change or remove the target element that receives input events.
       * > [!IMPORTANT] This will default to the canvas element of the renderer, so you
       * > should not need to call this unless you are using a custom element.
       * @param element - The new DOM element to bind events to, or null to remove all event bindings
       * @example
       * ```ts
       * // Set a new canvas element as the target
       * const canvas = document.createElement('canvas');
       * app.renderer.events.setTargetElement(canvas);
       *
       * // Remove all event bindings
       * app.renderer.events.setTargetElement(null);
       *
       * // Switch to a different canvas
       * const newCanvas = document.querySelector('#game-canvas');
       * app.renderer.events.setTargetElement(newCanvas);
       * ```
       * @remarks
       * - Automatically removes event listeners from previous element
       * - Required for the event system to function
       * - Safe to call multiple times
       * @see {@link EventSystem#domElement} The current DOM element
       * @see {@link EventsTicker} For the ticker system that tracks pointer movement
       */
      setTargetElement(element) {
        this._removeEvents();
        this.domElement = element;
        EventsTicker.domElement = element;
        this._addEvents();
      }
      /** Register event listeners on {@link Renderer#domElement this.domElement}. */
      _addEvents() {
        if (this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.addTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "none";
            style.msTouchAction = "none";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "none";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
          this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.addEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
          this.domElement.addEventListener("mousedown", this._onPointerDown, true);
          this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.addEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.addEventListener("touchstart", this._onPointerDown, true);
            this.domElement.addEventListener("touchend", this._onPointerUp, true);
            this.domElement.addEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.addEventListener("wheel", this.onWheel, {
          passive: true,
          capture: true
        });
        this._eventsAdded = true;
      }
      /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
      _removeEvents() {
        if (!this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.removeTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "";
            style.msTouchAction = "";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
          this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.removeEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
          this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
          this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.removeEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
            this.domElement.removeEventListener("touchend", this._onPointerUp, true);
            this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.removeEventListener("wheel", this.onWheel, true);
        this.domElement = null;
        this._eventsAdded = false;
      }
      /**
       * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.
       * This takes into account the current scale, position, and resolution of the DOM element.
       * @param point - The point to store the mapped coordinates in
       * @param x - The x coordinate in DOM/client space
       * @param y - The y coordinate in DOM/client space
       * @example
       * ```ts
       * // Map mouse coordinates to PixiJS space
       * const point = new Point();
       * app.renderer.events.mapPositionToPoint(
       *     point,
       *     event.clientX,
       *     event.clientY
       * );
       * console.log('Mapped position:', point.x, point.y);
       *
       * // Using with pointer events
       * sprite.on('pointermove', (event) => {
       *     // event.global already contains mapped coordinates
       *     console.log('Global:', event.global.x, event.global.y);
       *
       *     // Map to local coordinates
       *     const local = event.getLocalPosition(sprite);
       *     console.log('Local:', local.x, local.y);
       * });
       * ```
       * @remarks
       * - Accounts for element scaling and positioning
       * - Adjusts for device pixel ratio/resolution
       */
      mapPositionToPoint(point, x2, y2) {
        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
          x: 0,
          y: 0,
          width: this.domElement.width,
          height: this.domElement.height,
          left: 0,
          top: 0
        };
        const resolutionMultiplier = 1 / this.resolution;
        point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
        point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
      }
      /**
       * Ensures that the original event object contains all data that a regular pointer event would have
       * @param event - The original event data from a touch or mouse event
       * @returns An array containing a single normalized pointer event, in the case of a pointer
       *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
       */
      _normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
            const touch = event.changedTouches[i2];
            if (typeof touch.button === "undefined")
              touch.button = 0;
            if (typeof touch.buttons === "undefined")
              touch.buttons = 1;
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined")
              touch.width = touch.radiusX || 1;
            if (typeof touch.height === "undefined")
              touch.height = touch.radiusY || 1;
            if (typeof touch.tiltX === "undefined")
              touch.tiltX = 0;
            if (typeof touch.tiltY === "undefined")
              touch.tiltY = 0;
            if (typeof touch.pointerType === "undefined")
              touch.pointerType = "touch";
            if (typeof touch.pointerId === "undefined")
              touch.pointerId = touch.identifier || 0;
            if (typeof touch.pressure === "undefined")
              touch.pressure = touch.force || 0.5;
            if (typeof touch.twist === "undefined")
              touch.twist = 0;
            if (typeof touch.tangentialPressure === "undefined")
              touch.tangentialPressure = 0;
            if (typeof touch.layerX === "undefined")
              touch.layerX = touch.offsetX = touch.clientX;
            if (typeof touch.layerY === "undefined")
              touch.layerY = touch.offsetY = touch.clientY;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
          const tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined")
            tempEvent.isPrimary = true;
          if (typeof tempEvent.width === "undefined")
            tempEvent.width = 1;
          if (typeof tempEvent.height === "undefined")
            tempEvent.height = 1;
          if (typeof tempEvent.tiltX === "undefined")
            tempEvent.tiltX = 0;
          if (typeof tempEvent.tiltY === "undefined")
            tempEvent.tiltY = 0;
          if (typeof tempEvent.pointerType === "undefined")
            tempEvent.pointerType = "mouse";
          if (typeof tempEvent.pointerId === "undefined")
            tempEvent.pointerId = MOUSE_POINTER_ID;
          if (typeof tempEvent.pressure === "undefined")
            tempEvent.pressure = 0.5;
          if (typeof tempEvent.twist === "undefined")
            tempEvent.twist = 0;
          if (typeof tempEvent.tangentialPressure === "undefined")
            tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      }
      /**
       * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
       *
       * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
       * multiple native wheel events.
       * @param nativeEvent - The native wheel event that occurred on the canvas.
       * @returns A federated wheel event.
       */
      normalizeWheelEvent(nativeEvent) {
        const event = this._rootWheelEvent;
        this._transferMouseData(event, nativeEvent);
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        event.deltaMode = nativeEvent.deltaMode;
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      }
      /**
       * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
       * @param event
       * @param nativeEvent
       */
      _bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this._transferMouseData(event, nativeEvent);
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
      }
      /**
       * Transfers base & mouse event data from the `nativeEvent` to the federated event.
       * @param event
       * @param nativeEvent
       */
      _transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
        event.shiftKey = nativeEvent.shiftKey;
      }
    };
    _EventSystem.extension = {
      name: "events",
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.CanvasSystem,
        ExtensionType.WebGPUSystem
      ],
      priority: -1
    };
    _EventSystem.defaultEventFeatures = {
      /** Enables pointer events associated with pointer movement. */
      move: true,
      /** Enables global pointer move events. */
      globalMove: true,
      /** Enables pointer events associated with clicking. */
      click: true,
      /** Enables wheel events. */
      wheel: true
    };
    EventSystem = _EventSystem;
  }
});

// node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
var FederatedContainer;
var init_FederatedEventTarget = __esm({
  "node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
    init_EventSystem();
    init_FederatedEvent();
    FederatedContainer = {
      onclick: null,
      onmousedown: null,
      onmouseenter: null,
      onmouseleave: null,
      onmousemove: null,
      onglobalmousemove: null,
      onmouseout: null,
      onmouseover: null,
      onmouseup: null,
      onmouseupoutside: null,
      onpointercancel: null,
      onpointerdown: null,
      onpointerenter: null,
      onpointerleave: null,
      onpointermove: null,
      onglobalpointermove: null,
      onpointerout: null,
      onpointerover: null,
      onpointertap: null,
      onpointerup: null,
      onpointerupoutside: null,
      onrightclick: null,
      onrightdown: null,
      onrightup: null,
      onrightupoutside: null,
      ontap: null,
      ontouchcancel: null,
      ontouchend: null,
      ontouchendoutside: null,
      ontouchmove: null,
      onglobaltouchmove: null,
      ontouchstart: null,
      onwheel: null,
      get interactive() {
        return this.eventMode === "dynamic" || this.eventMode === "static";
      },
      set interactive(value) {
        this.eventMode = value ? "static" : "passive";
      },
      _internalEventMode: void 0,
      get eventMode() {
        return this._internalEventMode ?? EventSystem.defaultEventMode;
      },
      set eventMode(value) {
        this._internalEventMode = value;
      },
      isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic";
      },
      interactiveChildren: true,
      hitArea: null,
      addEventListener(type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const signal = typeof options === "object" ? options.signal : void 0;
        const once = typeof options === "object" ? options.once === true : false;
        const context2 = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
        const emitter = this;
        if (signal) {
          signal.addEventListener("abort", () => {
            emitter.off(type, listenerFn, context2);
          });
        }
        if (once) {
          emitter.once(type, listenerFn, context2);
        } else {
          emitter.on(type, listenerFn, context2);
        }
      },
      removeEventListener(type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context2 = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.off(type, listener, context2);
      },
      dispatchEvent(e2) {
        if (!(e2 instanceof FederatedEvent)) {
          throw new Error("Container cannot propagate events outside of the Federated Events API");
        }
        e2.defaultPrevented = false;
        e2.path = null;
        e2.target = this;
        e2.manager.dispatchEvent(e2);
        return !e2.defaultPrevented;
      }
    };
  }
});

// node_modules/pixi.js/lib/events/init.mjs
var init_init3 = __esm({
  "node_modules/pixi.js/lib/events/init.mjs"() {
    init_Extensions();
    init_Container();
    init_EventSystem();
    init_FederatedEventTarget();
    extensions.add(EventSystem);
    extensions.mixin(Container, FederatedContainer);
  }
});

// node_modules/pixi.js/lib/dom/DOMPipe.mjs
var DOMPipe;
var init_DOMPipe = __esm({
  "node_modules/pixi.js/lib/dom/DOMPipe.mjs"() {
    init_Extensions();
    init_CanvasObserver();
    DOMPipe = class {
      /**
       * Constructor for the DOMPipe class.
       * @param renderer - The renderer instance that this DOMPipe will be associated with.
       */
      constructor(renderer) {
        this._attachedDomElements = [];
        this._renderer = renderer;
        this._renderer.runners.postrender.add(this);
        this._renderer.runners.init.add(this);
        this._domElement = document.createElement("div");
        this._domElement.style.position = "absolute";
        this._domElement.style.top = "0";
        this._domElement.style.left = "0";
        this._domElement.style.pointerEvents = "none";
        this._domElement.style.zIndex = "1000";
      }
      /** Initializes the DOMPipe, setting up the main DOM element and adding it to the document body. */
      init() {
        this._canvasObserver = new CanvasObserver({
          domElement: this._domElement,
          renderer: this._renderer
        });
      }
      /**
       * Adds a renderable DOM container to the list of attached elements.
       * @param domContainer - The DOM container to be added.
       * @param _instructionSet - The instruction set (unused).
       */
      addRenderable(domContainer, _instructionSet) {
        if (!this._attachedDomElements.includes(domContainer)) {
          this._attachedDomElements.push(domContainer);
        }
      }
      /**
       * Updates a renderable DOM container.
       * @param _domContainer - The DOM container to be updated (unused).
       */
      updateRenderable(_domContainer) {
      }
      /**
       * Validates a renderable DOM container.
       * @param _domContainer - The DOM container to be validated (unused).
       * @returns Always returns true as validation is not required.
       */
      validateRenderable(_domContainer) {
        return true;
      }
      /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */
      postrender() {
        const attachedDomElements = this._attachedDomElements;
        if (attachedDomElements.length === 0) {
          this._domElement.remove();
          return;
        }
        this._canvasObserver.ensureAttached();
        for (let i2 = 0; i2 < attachedDomElements.length; i2++) {
          const domContainer = attachedDomElements[i2];
          const element = domContainer.element;
          if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {
            element?.remove();
            attachedDomElements.splice(i2, 1);
            i2--;
          } else {
            if (!this._domElement.contains(element)) {
              element.style.position = "absolute";
              element.style.pointerEvents = "auto";
              this._domElement.appendChild(element);
            }
            const wt = domContainer.worldTransform;
            const anchor = domContainer._anchor;
            const ax = domContainer.width * anchor.x;
            const ay = domContainer.height * anchor.y;
            element.style.transformOrigin = `${ax}px ${ay}px`;
            element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;
            element.style.opacity = domContainer.groupAlpha.toString();
          }
        }
      }
      /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */
      destroy() {
        this._renderer.runners.postrender.remove(this);
        for (let i2 = 0; i2 < this._attachedDomElements.length; i2++) {
          const domContainer = this._attachedDomElements[i2];
          domContainer.element?.remove();
        }
        this._attachedDomElements.length = 0;
        this._domElement.remove();
        this._canvasObserver.destroy();
        this._renderer = null;
      }
    };
    DOMPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "dom"
    };
  }
});

// node_modules/pixi.js/lib/scene/view/ViewContainer.mjs
var ViewContainer;
var init_ViewContainer = __esm({
  "node_modules/pixi.js/lib/scene/view/ViewContainer.mjs"() {
    init_Bounds();
    init_Container();
    ViewContainer = class extends Container {
      // eslint-disable-next-line @typescript-eslint/no-useless-constructor
      constructor(options) {
        super(options);
        this.canBundle = true;
        this.allowChildren = false;
        this._roundPixels = 0;
        this._lastUsed = -1;
        this._gpuData = /* @__PURE__ */ Object.create(null);
        this._bounds = new Bounds(0, 1, 0, 0);
        this._boundsDirty = true;
      }
      /**
       * The local bounds of the view in its own coordinate space.
       * Bounds are automatically updated when the view's content changes.
       * @example
       * ```ts
       * // Get bounds dimensions
       * const bounds = view.bounds;
       * console.log(`Width: ${bounds.maxX - bounds.minX}`);
       * console.log(`Height: ${bounds.maxY - bounds.minY}`);
       * ```
       * @returns The rectangular bounds of the view
       * @see {@link Bounds} For bounds operations
       */
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        this.updateBounds();
        this._boundsDirty = false;
        return this._bounds;
      }
      /**
       * Whether or not to round the x/y position of the sprite.
       * @example
       * ```ts
       * // Enable pixel rounding for crisp rendering
       * view.roundPixels = true;
       * ```
       * @default false
       */
      get roundPixels() {
        return !!this._roundPixels;
      }
      set roundPixels(value) {
        this._roundPixels = value ? 1 : 0;
      }
      /**
       * Checks if the object contains the given point in local coordinates.
       * Uses the view's bounds for hit testing.
       * @example
       * ```ts
       * // Basic point check
       * const localPoint = { x: 50, y: 25 };
       * const contains = view.containsPoint(localPoint);
       * console.log('Point is inside:', contains);
       * ```
       * @param point - The point to check in local coordinates
       * @returns True if the point is within the view's bounds
       * @see {@link ViewContainer#bounds} For the bounds used in hit testing
       * @see {@link Container#toLocal} For converting global coordinates to local
       */
      containsPoint(point) {
        const bounds = this.bounds;
        const { x: x2, y: y2 } = point;
        return x2 >= bounds.minX && x2 <= bounds.maxX && y2 >= bounds.minY && y2 <= bounds.maxY;
      }
      /** @private */
      onViewUpdate() {
        this._didViewChangeTick++;
        this._boundsDirty = true;
        if (this.didViewUpdate)
          return;
        this.didViewUpdate = true;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.onChildViewUpdate(this);
        }
      }
      destroy(options) {
        super.destroy(options);
        this._bounds = null;
        for (const key in this._gpuData) {
          this._gpuData[key].destroy?.();
        }
        this._gpuData = null;
      }
      /**
       * Collects renderables for the view container.
       * @param instructionSet - The instruction set to collect renderables for.
       * @param renderer - The renderer to collect renderables for.
       * @param currentLayer - The current render layer.
       * @internal
       */
      collectRenderablesSimple(instructionSet, renderer, currentLayer) {
        const { renderPipes: renderPipes3 } = renderer;
        renderPipes3.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);
        const rp = renderPipes3;
        rp[this.renderPipeId].addRenderable(this, instructionSet);
        this.didViewUpdate = false;
        const children = this.children;
        const length = children.length;
        for (let i2 = 0; i2 < length; i2++) {
          children[i2].collectRenderables(instructionSet, renderer, currentLayer);
        }
        renderPipes3.blendMode.popBlendMode(instructionSet);
      }
    };
  }
});

// node_modules/pixi.js/lib/dom/init.mjs
var init_init4 = __esm({
  "node_modules/pixi.js/lib/dom/init.mjs"() {
    init_Extensions();
    init_DOMPipe();
    extensions.add(DOMPipe);
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
var LoaderParserPriority;
var init_LoaderParser = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
    "use strict";
    LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
      LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
      LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
      LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
      return LoaderParserPriority2;
    })(LoaderParserPriority || {});
  }
});

// node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs
var BrowserAdapter;
var init_BrowserAdapter = __esm({
  "node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs"() {
    "use strict";
    BrowserAdapter = {
      createCanvas: (width, height) => {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
      },
      createImage: () => new Image(),
      getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => document.baseURI ?? window.location.href,
      getFontFaceSet: () => document.fonts,
      fetch: (url, options) => fetch(url, options),
      parseXML: (xml) => {
        const parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
      }
    };
  }
});

// node_modules/pixi.js/lib/environment/adapter.mjs
var currentAdapter, DOMAdapter;
var init_adapter = __esm({
  "node_modules/pixi.js/lib/environment/adapter.mjs"() {
    init_BrowserAdapter();
    currentAdapter = BrowserAdapter;
    DOMAdapter = {
      /**
       * Returns the current adapter.
       * @returns {environment.Adapter} The current adapter.
       */
      get() {
        return currentAdapter;
      },
      /**
       * Sets the current adapter.
       * @param adapter - The new adapter.
       */
      set(adapter) {
        currentAdapter = adapter;
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/path.mjs
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length) {
      code = path2.charCodeAt(i2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i2)}`;
        } else {
          res = path2.slice(lastSlash + 1, i2);
        }
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var path;
var init_path = __esm({
  "node_modules/pixi.js/lib/utils/path.mjs"() {
    init_adapter();
    path = {
      /**
       * Converts a path to posix format.
       * @param path - The path to convert to posix
       * @example
       * ```ts
       * // Convert a Windows path to POSIX format
       * path.toPosix('C:\\Users\\User\\Documents\\file.txt');
       * // -> 'C:/Users/User/Documents/file.txt'
       * ```
       */
      toPosix(path2) {
        return replaceAll(path2, "\\", "/");
      },
      /**
       * Checks if the path is a URL e.g. http://, https://
       * @param path - The path to check
       * @example
       * ```ts
       * // Check if a path is a URL
       * path.isUrl('http://www.example.com');
       * // -> true
       * path.isUrl('C:/Users/User/Documents/file.txt');
       * // -> false
       * ```
       */
      isUrl(path2) {
        return /^https?:/.test(this.toPosix(path2));
      },
      /**
       * Checks if the path is a data URL
       * @param path - The path to check
       * @example
       * ```ts
       * // Check if a path is a data URL
       * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');
       * // -> true
       * ```
       */
      isDataUrl(path2) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
      },
      /**
       * Checks if the path is a blob URL
       * @param path - The path to check
       * @example
       * ```ts
       * // Check if a path is a blob URL
       * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');
       * // -> true
       * ```
       */
      isBlobUrl(path2) {
        return path2.startsWith("blob:");
      },
      /**
       * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
       * This will return true for windows file paths
       * @param path - The path to check
       * @example
       * ```ts
       * // Check if a path has a protocol
       * path.hasProtocol('http://www.example.com');
       * // -> true
       * path.hasProtocol('C:/Users/User/Documents/file.txt');
       * // -> true
       * ```
       */
      hasProtocol(path2) {
        return /^[^/:]+:/.test(this.toPosix(path2));
      },
      /**
       * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
       * @param path - The path to get the protocol from
       * @example
       * ```ts
       * // Get the protocol from a URL
       * path.getProtocol('http://www.example.com/path/to/resource');
       * // -> 'http://'
       * // Get the protocol from a file path
       * path.getProtocol('C:/Users/User/Documents/file.txt');
       * // -> 'C:/'
       * ```
       */
      getProtocol(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        const matchFile = /^file:\/\/\//.exec(path2);
        if (matchFile) {
          return matchFile[0];
        }
        const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
        if (matchProtocol) {
          return matchProtocol[0];
        }
        return "";
      },
      /**
       * Converts URL to an absolute path.
       * When loading from a Web Worker, we must use absolute paths.
       * If the URL is already absolute we return it as is
       * If it's not, we convert it
       * @param url - The URL to test
       * @param customBaseUrl - The base URL to use
       * @param customRootUrl - The root URL to use
       * @example
       * ```ts
       * // Convert a relative URL to an absolute path
       * path.toAbsolute('images/texture.png', 'http://example.com/assets/');
       * // -> 'http://example.com/assets/images/texture.png'
       * ```
       */
      toAbsolute(url, customBaseUrl, customRootUrl) {
        assertPath(url);
        if (this.isDataUrl(url) || this.isBlobUrl(url))
          return url;
        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
        url = this.toPosix(url);
        if (url.startsWith("/")) {
          return path.join(rootUrl, url.slice(1));
        }
        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
        return absolutePath;
      },
      /**
       * Normalizes the given path, resolving '..' and '.' segments
       * @param path - The path to normalize
       * @example
       * ```ts
       * // Normalize a path with relative segments
       * path.normalize('http://www.example.com/foo/bar/../baz');
       * // -> 'http://www.example.com/foo/baz'
       * // Normalize a file path with relative segments
       * path.normalize('C:\\Users\\User\\Documents\\..\\file.txt');
       * // -> 'C:/Users/User/file.txt'
       * ```
       */
      normalize(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        if (this.isDataUrl(path2) || this.isBlobUrl(path2))
          return path2;
        path2 = this.toPosix(path2);
        let protocol = "";
        const isAbsolute = path2.startsWith("/");
        if (this.hasProtocol(path2)) {
          protocol = this.rootname(path2);
          path2 = path2.slice(protocol.length);
        }
        const trailingSeparator = path2.endsWith("/");
        path2 = normalizeStringPosix(path2, false);
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute)
          return `/${path2}`;
        return protocol + path2;
      },
      /**
       * Determines if path is an absolute path.
       * Absolute paths can be urls, data urls, or paths on disk
       * @param path - The path to test
       * @example
       * ```ts
       * // Check if a path is absolute
       * path.isAbsolute('http://www.example.com/foo/bar');
       * // -> true
       * path.isAbsolute('C:/Users/User/Documents/file.txt');
       * // -> true
       * ```
       */
      isAbsolute(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        if (this.hasProtocol(path2))
          return true;
        return path2.startsWith("/");
      },
      /**
       * Joins all given path segments together using the platform-specific separator as a delimiter,
       * then normalizes the resulting path
       * @param segments - The segments of the path to join
       * @example
       * ```ts
       * // Join multiple path segments
       * path.join('assets', 'images', 'sprite.png');
       * // -> 'assets/images/sprite.png'
       * // Join with relative segments
       * path.join('assets', 'images', '../textures', 'sprite.png');
       * // -> 'assets/textures/sprite.png'
       * ```
       */
      join(...segments) {
        if (segments.length === 0) {
          return ".";
        }
        let joined;
        for (let i2 = 0; i2 < segments.length; ++i2) {
          const arg = segments[i2];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else {
              const prevArg = segments[i2 - 1] ?? "";
              if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                joined += `/../${arg}`;
              } else {
                joined += `/${arg}`;
              }
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        return this.normalize(joined);
      },
      /**
       * Returns the directory name of a path
       * @param path - The path to parse
       * @example
       * ```ts
       * // Get the directory name of a path
       * path.dirname('http://www.example.com/foo/bar/baz.png');
       * // -> 'http://www.example.com/foo/bar'
       * // Get the directory name of a file path
       * path.dirname('C:/Users/User/Documents/file.txt');
       * // -> 'C:/Users/User/Documents'
       * ```
       */
      dirname(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        path2 = this.toPosix(path2);
        let code = path2.charCodeAt(0);
        const hasRoot = code === 47;
        let end = -1;
        let matchedSlash = true;
        const proto = this.getProtocol(path2);
        const origpath = path2;
        path2 = path2.slice(proto.length);
        for (let i2 = path2.length - 1; i2 >= 1; --i2) {
          code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              end = i2;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
        if (hasRoot && end === 1)
          return "//";
        return proto + path2.slice(0, end);
      },
      /**
       * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
       * @param path - The path to parse
       * @example
       * ```ts
       * // Get the root of a URL
       * path.rootname('http://www.example.com/foo/bar/baz.png');
       * // -> 'http://www.example.com/'
       * // Get the root of a file path
       * path.rootname('C:/Users/User/Documents/file.txt');
       * // -> 'C:/'
       * ```
       */
      rootname(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        let root = "";
        if (path2.startsWith("/"))
          root = "/";
        else {
          root = this.getProtocol(path2);
        }
        if (this.isUrl(path2)) {
          const index = path2.indexOf("/", root.length);
          if (index !== -1) {
            root = path2.slice(0, index);
          } else
            root = path2;
          if (!root.endsWith("/"))
            root += "/";
        }
        return root;
      },
      /**
       * Returns the last portion of a path
       * @param path - The path to test
       * @param ext - Optional extension to remove
       * @example
       * ```ts
       * // Get the basename of a URL
       * path.basename('http://www.example.com/foo/bar/baz.png');
       * // -> 'baz.png'
       * // Get the basename of a file path
       * path.basename('C:/Users/User/Documents/file.txt');
       * // -> 'file.txt'
       * ```
       */
      basename(path2, ext) {
        assertPath(path2);
        if (ext)
          assertPath(ext);
        path2 = removeUrlParams(this.toPosix(path2));
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i2;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i2 = path2.length - 1; i2 >= 0; --i2) {
            const code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i2 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i2;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        }
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          if (path2.charCodeAt(i2) === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
        }
        if (end === -1)
          return "";
        return path2.slice(start, end);
      },
      /**
       * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
       * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
       * the first character of the basename of path, an empty string is returned.
       * @param path - The path to parse
       * @example
       * ```ts
       * // Get the extension of a URL
       * path.extname('http://www.example.com/foo/bar/baz.png');
       * // -> '.png'
       * // Get the extension of a file path
       * path.extname('C:/Users/User/Documents/file.txt');
       * // -> '.txt'
       * ```
       */
      extname(path2) {
        assertPath(path2);
        path2 = removeUrlParams(this.toPosix(path2));
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i2 = path2.length - 1; i2 >= 0; --i2) {
          const code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      /**
       * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
       * @param path - The path to parse
       * @example
       * ```ts
       * // Parse a URL
       * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');
       * // -> {
       * //   root: 'http://www.example.com/',
       * //   dir: 'http://www.example.com/foo/bar',
       * //   base: 'baz.png',
       * //   ext: '.png',
       * //   name: 'baz'
       * // }
       * // Parse a file path
       * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');
       * // -> {
       * //   root: 'C:/',
       * //   dir: 'C:/Users/User/Documents',
       * //   base: 'file.txt',
       * //   ext: '.txt',
       * //   name: 'file'
       * // }
       * ```
       */
      parse(path2) {
        assertPath(path2);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path2.length === 0)
          return ret;
        path2 = removeUrlParams(this.toPosix(path2));
        let code = path2.charCodeAt(0);
        const isAbsolute = this.isAbsolute(path2);
        let start;
        const protocol = "";
        ret.root = this.rootname(path2);
        if (isAbsolute || this.hasProtocol(path2)) {
          start = 1;
        } else {
          start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i2 = path2.length - 1;
        let preDotState = 0;
        for (; i2 >= start; --i2) {
          code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        ret.dir = this.dirname(path2);
        if (protocol)
          ret.dir = protocol + ret.dir;
        return ret;
      },
      sep: "/",
      delimiter: ":",
      joinExtensions: [".html"]
    };
  }
});

// node_modules/pixi.js/lib/assets/utils/convertToList.mjs
var convertToList;
var init_convertToList = __esm({
  "node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
    "use strict";
    convertToList = (input, transform, forceTransform = false) => {
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!transform) {
        return input;
      }
      return input.map((item) => {
        if (typeof item === "string" || forceTransform) {
          return transform(item);
        }
        return item;
      });
    };
  }
});

// node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i2 = 0; i2 < id.length; i2++) {
    const value = id[i2];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}
var init_createStringVariations = __esm({
  "node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
var isSingleItem;
var init_isSingleItem = __esm({
  "node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs"() {
    "use strict";
    isSingleItem = (item) => !Array.isArray(item);
  }
});

// node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
function getUrlExtension(url) {
  return url.split(".").pop().split("?").shift().split("#").shift();
}
var Resolver;
var init_Resolver = __esm({
  "node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"() {
    init_warn();
    init_path();
    init_convertToList();
    init_createStringVariations();
    init_isSingleItem();
    Resolver = class {
      constructor() {
        this._defaultBundleIdentifierOptions = {
          connector: "-",
          createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
          extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
        };
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
        this._assetMap = {};
        this._preferredOrder = [];
        this._parsers = [];
        this._resolverHash = {};
        this._bundles = {};
      }
      /**
       * Override how the resolver deals with generating bundle ids.
       * must be called before any bundles are added
       * @param bundleIdentifier - the bundle identifier options
       */
      setBundleIdentifier(bundleIdentifier) {
        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
        if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
          throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
      }
      /**
       * Let the resolver know which assets you prefer to use when resolving assets.
       * Multiple prefer user defined rules can be added.
       * @example
       * resolver.prefer({
       *     // first look for something with the correct format, and then then correct resolution
       *     priority: ['format', 'resolution'],
       *     params:{
       *         format:'webp', // prefer webp images
       *         resolution: 2, // prefer a resolution of 2
       *     }
       * })
       * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
       * resolver.resolveUrl('foo') // => 'bar@2x.webp'
       * @param preferOrders - the prefer options
       */
      prefer(...preferOrders) {
        preferOrders.forEach((prefer) => {
          this._preferredOrder.push(prefer);
          if (!prefer.priority) {
            prefer.priority = Object.keys(prefer.params);
          }
        });
        this._resolverHash = {};
      }
      /**
       * Set the base path to prepend to all urls when resolving
       * @example
       * resolver.basePath = 'https://home.com/';
       * resolver.add('foo', 'bar.ong');
       * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
       * @param basePath - the base path to use
       */
      set basePath(basePath) {
        this._basePath = basePath;
      }
      get basePath() {
        return this._basePath;
      }
      /**
       * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
       * default value for browsers is `window.location.origin`
       * @example
       * // Application hosted on https://home.com/some-path/index.html
       * resolver.basePath = 'https://home.com/some-path/';
       * resolver.rootPath = 'https://home.com/';
       * resolver.add('foo', '/bar.png');
       * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
       * @param rootPath - the root path to use
       */
      set rootPath(rootPath) {
        this._rootPath = rootPath;
      }
      get rootPath() {
        return this._rootPath;
      }
      /**
       * All the active URL parsers that help the parser to extract information and create
       * an asset object-based on parsing the URL itself.
       *
       * Can be added using the extensions API
       * @example
       * resolver.add('foo', [
       *     {
       *         resolution: 2,
       *         format: 'png',
       *         src: 'image@2x.png',
       *     },
       *     {
       *         resolution:1,
       *         format:'png',
       *         src: 'image.png',
       *     },
       * ]);
       *
       * // With a url parser the information such as resolution and file format could extracted from the url itself:
       * extensions.add({
       *     extension: ExtensionType.ResolveParser,
       *     test: loadTextures.test, // test if url ends in an image
       *     parse: (value: string) =>
       *     ({
       *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
       *         format: value.split('.').pop(),
       *         src: value,
       *     }),
       * });
       *
       * // Now resolution and format can be extracted from the url
       * resolver.add('foo', [
       *     'image@2x.png',
       *     'image.png',
       * ]);
       */
      get parsers() {
        return this._parsers;
      }
      /** Used for testing, this resets the resolver to its initial state */
      reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
        this._assetMap = {};
        this._preferredOrder = [];
        this._resolverHash = {};
        this._rootPath = null;
        this._basePath = null;
        this._manifest = null;
        this._bundles = {};
        this._defaultSearchParams = null;
      }
      /**
       * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
       * @param searchParams - the default url parameters to append when resolving urls
       */
      setDefaultSearchParams(searchParams) {
        if (typeof searchParams === "string") {
          this._defaultSearchParams = searchParams;
        } else {
          const queryValues = searchParams;
          this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
        }
      }
      /**
       * Returns the aliases for a given asset
       * @param asset - the asset to get the aliases for
       */
      getAlias(asset) {
        const { alias, src } = asset;
        const aliasesToUse = convertToList(
          alias || src,
          (value) => {
            if (typeof value === "string")
              return value;
            if (Array.isArray(value))
              return value.map((v2) => v2?.src ?? v2);
            if (value?.src)
              return value.src;
            return value;
          },
          true
        );
        return aliasesToUse;
      }
      /**
       * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
       * generally a manifest would be built using a tool.
       * @param manifest - the manifest to add to the resolver
       */
      addManifest(manifest) {
        if (this._manifest) {
          warn("[Resolver] Manifest already exists, this will be overwritten");
        }
        this._manifest = manifest;
        manifest.bundles.forEach((bundle) => {
          this.addBundle(bundle.name, bundle.assets);
        });
      }
      /**
       * This adds a bundle of assets in one go so that you can resolve them as a group.
       * For example you could add a bundle for each screen in you pixi app
       * @example
       * resolver.addBundle('animals', [
       *  { alias: 'bunny', src: 'bunny.png' },
       *  { alias: 'chicken', src: 'chicken.png' },
       *  { alias: 'thumper', src: 'thumper.png' },
       * ]);
       * // or
       * resolver.addBundle('animals', {
       *     bunny: 'bunny.png',
       *     chicken: 'chicken.png',
       *     thumper: 'thumper.png',
       * });
       *
       * const resolvedAssets = await resolver.resolveBundle('animals');
       * @param bundleId - The id of the bundle to add
       * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
       */
      addBundle(bundleId, assets) {
        const assetNames = [];
        let convertedAssets = assets;
        if (!Array.isArray(assets)) {
          convertedAssets = Object.entries(assets).map(([alias, src]) => {
            if (typeof src === "string" || Array.isArray(src)) {
              return { alias, src };
            }
            return { alias, ...src };
          });
        }
        convertedAssets.forEach((asset) => {
          const srcs = asset.src;
          const aliases = asset.alias;
          let ids;
          if (typeof aliases === "string") {
            const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
            assetNames.push(bundleAssetId);
            ids = [aliases, bundleAssetId];
          } else {
            const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
            assetNames.push(...bundleIds);
            ids = [...aliases, ...bundleIds];
          }
          this.add({
            ...asset,
            ...{
              alias: ids,
              src: srcs
            }
          });
        });
        this._bundles[bundleId] = assetNames;
      }
      /**
       * Tells the resolver what keys are associated with witch asset.
       * The most important thing the resolver does
       * @example
       * // Single key, single asset:
       * resolver.add({alias: 'foo', src: 'bar.png');
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Multiple keys, single asset:
       * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
       * resolver.resolveUrl('foo') // => 'bar.png'
       * resolver.resolveUrl('boo') // => 'bar.png'
       *
       * // Multiple keys, multiple assets:
       * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Add custom data attached to the resolver
       * Resolver.add({
       *     alias: 'bunnyBooBooSmooth',
       *     src: 'bunny{png,webp}',
       *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
       * });
       *
       * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
       * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
       */
      add(aliases) {
        const assets = [];
        if (Array.isArray(aliases)) {
          assets.push(...aliases);
        } else {
          assets.push(aliases);
        }
        let keyCheck;
        keyCheck = (key) => {
          if (this.hasKey(key)) {
            warn(`[Resolver] already has key: ${key} overwriting`);
          }
        };
        const assetArray = convertToList(assets);
        assetArray.forEach((asset) => {
          const { src } = asset;
          let {
            data,
            format,
            loadParser: userDefinedLoadParser,
            parser: userDefinedParser
          } = asset;
          const srcsToUse = convertToList(src).map((src2) => {
            if (typeof src2 === "string") {
              return createStringVariations(src2);
            }
            return Array.isArray(src2) ? src2 : [src2];
          });
          const aliasesToUse = this.getAlias(asset);
          Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
          const resolvedAssets = [];
          srcsToUse.forEach((srcs) => {
            srcs.forEach((src2) => {
              let formattedAsset = {};
              if (typeof src2 !== "object") {
                formattedAsset.src = src2;
                for (let i2 = 0; i2 < this._parsers.length; i2++) {
                  const parser = this._parsers[i2];
                  if (parser.test(src2)) {
                    formattedAsset = parser.parse(src2);
                    break;
                  }
                }
              } else {
                data = src2.data ?? data;
                format = src2.format ?? format;
                if (src2.loadParser || src2.parser) {
                  userDefinedLoadParser = src2.loadParser ?? userDefinedLoadParser;
                  userDefinedParser = src2.parser ?? userDefinedParser;
                }
                formattedAsset = {
                  ...formattedAsset,
                  ...src2
                };
              }
              if (!aliasesToUse) {
                throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
              }
              formattedAsset = this._buildResolvedAsset(formattedAsset, {
                aliases: aliasesToUse,
                data,
                format,
                loadParser: userDefinedLoadParser,
                parser: userDefinedParser,
                progressSize: asset.progressSize
              });
              resolvedAssets.push(formattedAsset);
            });
          });
          aliasesToUse.forEach((alias) => {
            this._assetMap[alias] = resolvedAssets;
          });
        });
      }
      // TODO: this needs an overload like load did in Assets
      /**
       * If the resolver has had a manifest set via setManifest, this will return the assets urls for
       * a given bundleId or bundleIds.
       * @example
       * // Manifest Example
       * const manifest = {
       *     bundles: [
       *         {
       *             name: 'load-screen',
       *             assets: [
       *                 {
       *                     alias: 'background',
       *                     src: 'sunset.png',
       *                 },
       *                 {
       *                     alias: 'bar',
       *                     src: 'load-bar.{png,webp}',
       *                 },
       *             ],
       *         },
       *         {
       *             name: 'game-screen',
       *             assets: [
       *                 {
       *                     alias: 'character',
       *                     src: 'robot.png',
       *                 },
       *                 {
       *                     alias: 'enemy',
       *                     src: 'bad-guy.png',
       *                 },
       *             ],
       *         },
       *     ]
       * };
       *
       * resolver.setManifest(manifest);
       * const resolved = resolver.resolveBundle('load-screen');
       * @param bundleIds - The bundle ids to resolve
       * @returns All the bundles assets or a hash of assets for each bundle specified
       */
      resolveBundle(bundleIds) {
        const singleAsset = isSingleItem(bundleIds);
        bundleIds = convertToList(bundleIds);
        const out2 = {};
        bundleIds.forEach((bundleId) => {
          const assetNames = this._bundles[bundleId];
          if (assetNames) {
            const results = this.resolve(assetNames);
            const assets = {};
            for (const key in results) {
              const asset = results[key];
              assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
            }
            out2[bundleId] = assets;
          }
        });
        return singleAsset ? out2[bundleIds[0]] : out2;
      }
      /**
       * Does exactly what resolve does, but returns just the URL rather than the whole asset object
       * @param key - The key or keys to resolve
       * @returns - The URLs associated with the key(s)
       */
      resolveUrl(key) {
        const result = this.resolve(key);
        if (typeof key !== "string") {
          const out2 = {};
          for (const i2 in result) {
            out2[i2] = result[i2].src;
          }
          return out2;
        }
        return result.src;
      }
      resolve(keys) {
        const singleAsset = isSingleItem(keys);
        keys = convertToList(keys);
        const result = {};
        keys.forEach((key) => {
          if (!this._resolverHash[key]) {
            if (this._assetMap[key]) {
              let assets = this._assetMap[key];
              const preferredOrder = this._getPreferredOrder(assets);
              preferredOrder?.priority.forEach((priorityKey) => {
                preferredOrder.params[priorityKey].forEach((value) => {
                  const filteredAssets = assets.filter((asset) => {
                    if (asset[priorityKey]) {
                      return asset[priorityKey] === value;
                    }
                    return false;
                  });
                  if (filteredAssets.length) {
                    assets = filteredAssets;
                  }
                });
              });
              this._resolverHash[key] = assets[0];
            } else {
              this._resolverHash[key] = this._buildResolvedAsset({
                alias: [key],
                src: key
              }, {});
            }
          }
          result[key] = this._resolverHash[key];
        });
        return singleAsset ? result[keys[0]] : result;
      }
      /**
       * Checks if an asset with a given key exists in the resolver
       * @param key - The key of the asset
       */
      hasKey(key) {
        return !!this._assetMap[key];
      }
      /**
       * Checks if a bundle with the given key exists in the resolver
       * @param key - The key of the bundle
       */
      hasBundle(key) {
        return !!this._bundles[key];
      }
      /**
       * Internal function for figuring out what prefer criteria an asset should use.
       * @param assets
       */
      _getPreferredOrder(assets) {
        for (let i2 = 0; i2 < assets.length; i2++) {
          const asset = assets[i2];
          const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
          if (preferred) {
            return preferred;
          }
        }
        return this._preferredOrder[0];
      }
      /**
       * Appends the default url parameters to the url
       * @param url - The url to append the default parameters to
       * @returns - The url with the default parameters appended
       */
      _appendDefaultSearchParams(url) {
        if (!this._defaultSearchParams)
          return url;
        const paramConnector = /\?/.test(url) ? "&" : "?";
        return `${url}${paramConnector}${this._defaultSearchParams}`;
      }
      _buildResolvedAsset(formattedAsset, data) {
        const { aliases, data: assetData, loadParser, parser, format, progressSize } = data;
        if (this._basePath || this._rootPath) {
          formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
        }
        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
        formattedAsset.parser = parser ?? formattedAsset.parser;
        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
        if (progressSize !== void 0) {
          formattedAsset.progressSize = progressSize;
        }
        return formattedAsset;
      }
    };
    Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
  }
});

// node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
var copySearchParams;
var init_copySearchParams = __esm({
  "node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
    "use strict";
    copySearchParams = (targetUrl, sourceUrl) => {
      const searchParams = sourceUrl.split("?")[1];
      if (searchParams) {
        targetUrl += `?${searchParams}`;
      }
      return targetUrl;
    };
  }
});

// node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
var _Spritesheet, Spritesheet;
var init_Spritesheet = __esm({
  "node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
    init_Rectangle();
    init_TextureSource();
    init_Texture();
    _Spritesheet = class _Spritesheet2 {
      constructor(optionsOrTexture, arg1) {
        this.linkedSheets = [];
        let options = optionsOrTexture;
        if (optionsOrTexture?.source instanceof TextureSource) {
          options = {
            texture: optionsOrTexture,
            data: arg1
          };
        }
        const { texture, data, cachePrefix = "" } = options;
        this.cachePrefix = cachePrefix;
        this._texture = texture instanceof Texture ? texture : null;
        this.textureSource = texture.source;
        this.textures = {};
        this.animations = {};
        this.data = data;
        const metaResolution = parseFloat(data.meta.scale);
        if (metaResolution) {
          this.resolution = metaResolution;
          texture.source.resolution = this.resolution;
        } else {
          this.resolution = texture.source._resolution;
        }
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      /**
       * Parser spritesheet from loaded data. This is done asynchronously
       * to prevent creating too many Texture within a single process.
       */
      parse() {
        return new Promise((resolve) => {
          this._callback = resolve;
          this._batchIndex = 0;
          if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
          } else {
            this._nextBatch();
          }
        });
      }
      /**
       * Process a batch of frames
       * @param initialFrameIndex - The index of frame to start.
       */
      _processFrames(initialFrameIndex) {
        let frameIndex = initialFrameIndex;
        const maxFrames = _Spritesheet2.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          const i2 = this._frameKeys[frameIndex];
          const data = this._frames[i2];
          const rect = data.frame;
          if (rect) {
            let frame = null;
            let trim = null;
            const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            const orig = new Rectangle(
              0,
              0,
              Math.floor(sourceSize.w) / this.resolution,
              Math.floor(sourceSize.h) / this.resolution
            );
            if (data.rotated) {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.h) / this.resolution,
                Math.floor(rect.w) / this.resolution
              );
            } else {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim = new Rectangle(
                Math.floor(data.spriteSourceSize.x) / this.resolution,
                Math.floor(data.spriteSourceSize.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            this.textures[i2] = new Texture({
              source: this.textureSource,
              frame,
              orig,
              trim,
              rotate: data.rotated ? 2 : 0,
              defaultAnchor: data.anchor,
              defaultBorders: data.borders,
              label: i2.toString()
            });
          }
          frameIndex++;
        }
      }
      /** Parse animations config. */
      _processAnimations() {
        const animations = this.data.animations || {};
        for (const animName in animations) {
          this.animations[animName] = [];
          for (let i2 = 0; i2 < animations[animName].length; i2++) {
            const frameName = animations[animName][i2];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      }
      /** The parse has completed. */
      _parseComplete() {
        const callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      }
      /** Begin the next batch of textures. */
      _nextBatch() {
        this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(() => {
          if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
            this._nextBatch();
          } else {
            this._processAnimations();
            this._parseComplete();
          }
        }, 0);
      }
      /**
       * Destroy Spritesheet and don't use after this.
       * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
       */
      destroy(destroyBase = false) {
        for (const i2 in this.textures) {
          this.textures[i2].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          this._texture?.destroy();
          this.textureSource.destroy();
        }
        this._texture = null;
        this.textureSource = null;
        this.linkedSheets = [];
      }
    };
    _Spritesheet.BATCH_SIZE = 1e3;
    Spritesheet = _Spritesheet;
  }
});

// node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out2 = {};
  keys.forEach((key) => {
    out2[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out2[`${asset.cachePrefix}${key}`] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i2) => {
      const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
      Object.assign(out2, out22);
    });
  }
  return out2;
}
var validImages, spritesheetAsset;
var init_spritesheetAsset = __esm({
  "node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
    init_LoaderParser();
    init_Resolver();
    init_copySearchParams();
    init_Extensions();
    init_Texture();
    init_path();
    init_Spritesheet();
    validImages = [
      "jpg",
      "png",
      "jpeg",
      "avif",
      "webp",
      "basis",
      "etc2",
      "bc7",
      "bc6h",
      "bc5",
      "bc4",
      "bc3",
      "bc2",
      "bc1",
      "eac",
      "astc"
    ];
    spritesheetAsset = {
      extension: ExtensionType.Asset,
      /** Handle the caching of the related Spritesheet Textures */
      cache: {
        test: (asset) => asset instanceof Spritesheet,
        getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
      },
      /** Resolve the resolution of the asset. */
      resolver: {
        extension: {
          type: ExtensionType.ResolveParser,
          name: "resolveSpritesheet"
        },
        test: (value) => {
          const tempURL = value.split("?")[0];
          const split = tempURL.split(".");
          const extension = split.pop();
          const format = split.pop();
          return extension === "json" && validImages.includes(format);
        },
        parse: (value) => {
          const split = value.split(".");
          return {
            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format: split[split.length - 2],
            src: value
          };
        }
      },
      /**
       * Loader plugin that parses sprite sheets!
       * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
       * If it is, we load the spritesheets image and parse the data into Spritesheet
       * All textures in the sprite sheet are then added to the cache
       */
      loader: {
        /** used for deprecation purposes */
        name: "spritesheetLoader",
        id: "spritesheet",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal,
          name: "spritesheetLoader"
        },
        async testParse(asset, options) {
          return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
        },
        async parse(asset, options, loader) {
          const {
            texture: imageTexture,
            // if user need to use preloaded texture
            imageFilename,
            // if user need to use custom filename (not from jsonFile.meta.image)
            textureOptions,
            // if user need to set texture options on texture
            cachePrefix
            // if user need to use custom cache prefix
          } = options?.data ?? {};
          let basePath = path.dirname(options.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          let texture;
          if (imageTexture instanceof Texture) {
            texture = imageTexture;
          } else {
            const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);
            const assets = await loader.load([{ src: imagePath, data: textureOptions }]);
            texture = assets[imagePath];
          }
          const spritesheet = new Spritesheet({
            texture: texture.source,
            data: asset,
            cachePrefix
          });
          await spritesheet.parse();
          const multiPacks = asset?.meta?.related_multi_packs;
          if (Array.isArray(multiPacks)) {
            const promises = [];
            for (const item of multiPacks) {
              if (typeof item !== "string") {
                continue;
              }
              let itemUrl = basePath + item;
              if (options.data?.ignoreMultiPack) {
                continue;
              }
              itemUrl = copySearchParams(itemUrl, options.src);
              promises.push(loader.load({
                src: itemUrl,
                data: {
                  textureOptions,
                  ignoreMultiPack: true
                }
              }));
            }
            const res = await Promise.all(promises);
            spritesheet.linkedSheets = res;
            res.forEach((item) => {
              item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
            });
          }
          return spritesheet;
        },
        async unload(spritesheet, _resolvedAsset, loader) {
          await loader.unload(spritesheet.textureSource._sourceOrigin);
          spritesheet.destroy(false);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/spritesheet/init.mjs
var init_init5 = __esm({
  "node_modules/pixi.js/lib/spritesheet/init.mjs"() {
    init_Extensions();
    init_spritesheetAsset();
    extensions.add(spritesheetAsset);
  }
});

// node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs
function updateQuadBounds(bounds, anchor, texture) {
  const { width, height } = texture.orig;
  const trim = texture.trim;
  if (trim) {
    const sourceWidth = trim.width;
    const sourceHeight = trim.height;
    bounds.minX = trim.x - anchor._x * width;
    bounds.maxX = bounds.minX + sourceWidth;
    bounds.minY = trim.y - anchor._y * height;
    bounds.maxY = bounds.minY + sourceHeight;
  } else {
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
}
var init_updateQuadBounds = __esm({
  "node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
var Sprite;
var init_Sprite = __esm({
  "node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
    init_ObservablePoint();
    init_Texture();
    init_updateQuadBounds();
    init_deprecation();
    init_ViewContainer();
    Sprite = class _Sprite extends ViewContainer {
      /**
       * @param options - The options for creating the sprite.
       */
      constructor(options = Texture.EMPTY) {
        if (options instanceof Texture) {
          options = { texture: options };
        }
        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;
        super({
          label: "Sprite",
          ...rest
        });
        this.renderPipeId = "sprite";
        this.batched = true;
        this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
        this._anchor = new ObservablePoint(
          {
            _onUpdate: () => {
              this.onViewUpdate();
            }
          }
        );
        if (anchor) {
          this.anchor = anchor;
        } else if (texture.defaultAnchor) {
          this.anchor = texture.defaultAnchor;
        }
        this.texture = texture;
        this.allowChildren = false;
        this.roundPixels = roundPixels ?? false;
        if (width !== void 0)
          this.width = width;
        if (height !== void 0)
          this.height = height;
      }
      /**
       * Creates a new sprite based on a source texture, image, video, or canvas element.
       * This is a convenience method that automatically creates and manages textures.
       * @example
       * ```ts
       * // Create from path or URL
       * const sprite = Sprite.from('assets/image.png');
       *
       * // Create from existing texture
       * const sprite = Sprite.from(texture);
       *
       * // Create from canvas
       * const canvas = document.createElement('canvas');
       * const sprite = Sprite.from(canvas, true); // Skip caching new texture
       * ```
       * @param source - The source to create the sprite from. Can be a path to an image, a texture,
       * or any valid texture source (canvas, video, etc.)
       * @param skipCache - Whether to skip adding to the texture cache when creating a new texture
       * @returns A new sprite based on the source
       * @see {@link Texture.from} For texture creation details
       * @see {@link Assets} For asset loading and management
       */
      static from(source3, skipCache = false) {
        if (source3 instanceof Texture) {
          return new _Sprite(source3);
        }
        return new _Sprite(Texture.from(source3, skipCache));
      }
      set texture(value) {
        value || (value = Texture.EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value)
          return;
        if (currentTexture && currentTexture.dynamic)
          currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic)
          value.on("update", this.onViewUpdate, this);
        this._texture = value;
        if (this._width) {
          this._setWidth(this._width, this._texture.orig.width);
        }
        if (this._height) {
          this._setHeight(this._height, this._texture.orig.height);
        }
        this.onViewUpdate();
      }
      /**
       * The texture that is displayed by the sprite. When changed, automatically updates
       * the sprite dimensions and manages texture event listeners.
       * @example
       * ```ts
       * // Create sprite with texture
       * const sprite = new Sprite({
       *     texture: Texture.from('sprite.png')
       * });
       *
       * // Update texture
       * sprite.texture = Texture.from('newSprite.png');
       *
       * // Use texture from spritesheet
       * const sheet = await Assets.load('spritesheet.json');
       * sprite.texture = sheet.textures['frame1.png'];
       *
       * // Reset to empty texture
       * sprite.texture = Texture.EMPTY;
       * ```
       * @see {@link Texture} For texture creation and management
       * @see {@link Assets} For asset loading
       */
      get texture() {
        return this._texture;
      }
      /**
       * The bounds of the sprite, taking into account the texture's trim area.
       * @example
       * ```ts
       * const texture = new Texture({
       *     source: new TextureSource({ width: 300, height: 300 }),
       *     frame: new Rectangle(196, 66, 58, 56),
       *     trim: new Rectangle(4, 4, 58, 56),
       *     orig: new Rectangle(0, 0, 64, 64),
       *     rotate: 2,
       * });
       * const sprite = new Sprite(texture);
       * const visualBounds = sprite.visualBounds;
       * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }
       */
      get visualBounds() {
        updateQuadBounds(this._visualBounds, this._anchor, this._texture);
        return this._visualBounds;
      }
      /**
       * @deprecated
       * @ignore
       */
      get sourceBounds() {
        deprecation("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead.");
        return this.visualBounds;
      }
      /** @private */
      updateBounds() {
        const anchor = this._anchor;
        const texture = this._texture;
        const bounds = this._bounds;
        const { width, height } = texture.orig;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @example
       * sprite.destroy();
       * sprite.destroy(true);
       * sprite.destroy({ texture: true, textureSource: true });
       */
      destroy(options = false) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._visualBounds = null;
        this._bounds = null;
        this._anchor = null;
        this._gpuData = null;
      }
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
       * and passed to the constructor.
       *
       * - The default is `(0,0)`, this means the sprite's origin is the top left.
       * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * ```ts
       * // Center the anchor point
       * sprite.anchor = 0.5; // Sets both x and y to 0.5
       * sprite.position.set(400, 300); // Sprite will be centered at this position
       *
       * // Set specific x/y anchor points
       * sprite.anchor = {
       *     x: 1, // Right edge
       *     y: 0  // Top edge
       * };
       *
       * // Using individual coordinates
       * sprite.anchor.set(0.5, 1); // Center-bottom
       *
       * // For rotation around center
       * sprite.anchor.set(0.5);
       * sprite.rotation = Math.PI / 4; // 45 degrees around center
       *
       * // For scaling from center
       * sprite.anchor.set(0.5);
       * sprite.scale.set(2); // Scales from center point
       * ```
       */
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
      }
      /**
       * The width of the sprite, setting this will actually modify the scale to achieve the value set.
       * @example
       * ```ts
       * // Set width directly
       * sprite.width = 200;
       * console.log(sprite.scale.x); // Scale adjusted to match width
       *
       * // Set width while preserving aspect ratio
       * const ratio = sprite.height / sprite.width;
       * sprite.width = 300;
       * sprite.height = 300 * ratio;
       *
       * // For better performance when setting both width and height
       * sprite.setSize(300, 400); // Avoids recalculating bounds twice
       *
       * // Reset to original texture size
       * sprite.width = sprite.texture.orig.width;
       * ```
       */
      get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      }
      set width(value) {
        this._setWidth(value, this._texture.orig.width);
        this._width = value;
      }
      /**
       * The height of the sprite, setting this will actually modify the scale to achieve the value set.
       * @example
       * ```ts
       * // Set height directly
       * sprite.height = 150;
       * console.log(sprite.scale.y); // Scale adjusted to match height
       *
       * // Set height while preserving aspect ratio
       * const ratio = sprite.width / sprite.height;
       * sprite.height = 200;
       * sprite.width = 200 * ratio;
       *
       * // For better performance when setting both width and height
       * sprite.setSize(300, 400); // Avoids recalculating bounds twice
       *
       * // Reset to original texture size
       * sprite.height = sprite.texture.orig.height;
       * ```
       */
      get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      }
      set height(value) {
        this._setHeight(value, this._texture.orig.height);
        this._height = value;
      }
      /**
       * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.
       * This is faster than getting width and height separately as it only calculates the bounds once.
       * @example
       * ```ts
       * // Basic size retrieval
       * const sprite = new Sprite(Texture.from('sprite.png'));
       * const size = sprite.getSize();
       * console.log(`Size: ${size.width}x${size.height}`);
       *
       * // Reuse existing size object
       * const reuseSize = { width: 0, height: 0 };
       * sprite.getSize(reuseSize);
       * ```
       * @param out - Optional object to store the size in, to avoid allocating a new object
       * @returns The size of the Sprite
       * @see {@link Sprite#width} For getting just the width
       * @see {@link Sprite#height} For getting just the height
       * @see {@link Sprite#setSize} For setting both width and height
       */
      getSize(out2) {
        out2 || (out2 = {});
        out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
        out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
        return out2;
      }
      /**
       * Sets the size of the Sprite to the specified width and height.
       * This is faster than setting width and height separately as it only recalculates bounds once.
       * @example
       * ```ts
       * // Basic size setting
       * const sprite = new Sprite(Texture.from('sprite.png'));
       * sprite.setSize(100, 200); // Width: 100, Height: 200
       *
       * // Set uniform size
       * sprite.setSize(100); // Sets both width and height to 100
       *
       * // Set size with object
       * sprite.setSize({
       *     width: 200,
       *     height: 300
       * });
       *
       * // Reset to texture size
       * sprite.setSize(
       *     sprite.texture.orig.width,
       *     sprite.texture.orig.height
       * );
       * ```
       * @param value - This can be either a number or a {@link Size} object
       * @param height - The height to set. Defaults to the value of `width` if not provided
       * @see {@link Sprite#width} For setting width only
       * @see {@link Sprite#height} For setting height only
       * @see {@link Sprite#texture} For the source dimensions
       */
      setSize(value, height) {
        if (typeof value === "object") {
          height = value.height ?? value.width;
          value = value.width;
        } else {
          height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, this._texture.orig.width);
        height !== void 0 && this._setHeight(height, this._texture.orig.height);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
function addMaskBounds(mask, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds;
  mask.measurable = true;
  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask.measurable = false;
}
var tempBounds;
var init_addMaskBounds = __esm({
  "node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
    init_Bounds();
    init_getGlobalBounds();
    tempBounds = new Bounds();
  }
});

// node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
function addMaskLocalBounds(mask, bounds, localRoot) {
  const boundsToMask = boundsPool.get();
  mask.measurable = true;
  const tempMatrix7 = matrixPool.get().identity();
  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix7);
  getLocalBounds(mask, boundsToMask, relativeMask);
  mask.measurable = false;
  bounds.addBoundsMask(boundsToMask);
  matrixPool.return(tempMatrix7);
  boundsPool.return(boundsToMask);
}
function getMatrixRelativeToParent(target, root, matrix) {
  if (!target) {
    warn("Mask bounds, renderable is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent(target.parent, root, matrix);
    target.updateLocalTransform();
    matrix.append(target.localTransform);
  }
  return matrix;
}
var init_addMaskLocalBounds = __esm({
  "node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
    init_getLocalBounds();
    init_matrixAndBoundsPool();
    init_warn();
  }
});

// node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
var AlphaMask;
var init_AlphaMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
    init_Extensions();
    init_Sprite();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    AlphaMask = class {
      constructor(options) {
        this.priority = 0;
        this.inverse = false;
        this.pipe = "alphaMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.renderMaskToTexture = !(mask instanceof Sprite);
        this.mask.renderable = this.renderMaskToTexture;
        this.mask.includeInBuild = !this.renderMaskToTexture;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        if (!this.inverse) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask = this.mask;
        return hitTestFn(mask, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Sprite;
      }
    };
    AlphaMask.extension = ExtensionType.MaskEffect;
  }
});

// node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
var ColorMask;
var init_ColorMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
    init_Extensions();
    ColorMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "colorMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
      }
      destroy() {
      }
      static test(mask) {
        return typeof mask === "number";
      }
    };
    ColorMask.extension = ExtensionType.MaskEffect;
  }
});

// node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
var StencilMask;
var init_StencilMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
    init_Extensions();
    init_Container();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    StencilMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "stencilMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.mask.includeInBuild = false;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask.includeInBuild = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask = this.mask;
        return hitTestFn(mask, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Container;
      }
    };
    StencilMask.extension = ExtensionType.MaskEffect;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
var CanvasSource;
var init_CanvasSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
    init_adapter();
    init_Extensions();
    init_TextureSource();
    CanvasSource = class extends TextureSource {
      constructor(options) {
        if (!options.resource) {
          options.resource = DOMAdapter.get().createCanvas();
        }
        if (!options.width) {
          options.width = options.resource.width;
          if (!options.autoDensity) {
            options.width /= options.resolution;
          }
        }
        if (!options.height) {
          options.height = options.resource.height;
          if (!options.autoDensity) {
            options.height /= options.resolution;
          }
        }
        super(options);
        this.uploadMethodId = "image";
        this.autoDensity = options.autoDensity;
        this.resizeCanvas();
        this.transparent = !!options.transparent;
      }
      resizeCanvas() {
        if (this.autoDensity && "style" in this.resource) {
          this.resource.style.width = `${this.width}px`;
          this.resource.style.height = `${this.height}px`;
        }
        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
          this.resource.width = this.pixelWidth;
          this.resource.height = this.pixelHeight;
        }
      }
      resize(width = this.width, height = this.height, resolution = this._resolution) {
        const didResize = super.resize(width, height, resolution);
        if (didResize) {
          this.resizeCanvas();
        }
        return didResize;
      }
      static test(resource) {
        return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
      }
      /**
       * Returns the 2D rendering context for the canvas.
       * Caches the context after creating it.
       * @returns The 2D rendering context of the canvas.
       */
      get context2D() {
        return this._context2D || (this._context2D = this.resource.getContext("2d"));
      }
    };
    CanvasSource.extension = ExtensionType.TextureSource;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
var ImageSource;
var init_ImageSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
    init_Extensions();
    init_TextureSource();
    ImageSource = class extends TextureSource {
      constructor(options) {
        super(options);
        this.uploadMethodId = "image";
        this.autoGarbageCollect = true;
      }
      static test(resource) {
        return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
      }
    };
    ImageSource.extension = ExtensionType.TextureSource;
  }
});

// node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
async function detectVideoAlphaMode() {
  promise ?? (promise = (async () => {
    const canvas = DOMAdapter.get().createCanvas(1, 1);
    const gl = canvas.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve(video2);
      video2.onerror = () => resolve(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise;
}
var promise;
var init_detectVideoAlphaMode = __esm({
  "node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
var _VideoSource, VideoSource;
var init_VideoSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
    init_Extensions();
    init_Ticker();
    init_detectVideoAlphaMode();
    init_TextureSource();
    _VideoSource = class _VideoSource2 extends TextureSource {
      constructor(options) {
        super(options);
        this.isReady = false;
        this.uploadMethodId = "video";
        options = {
          ..._VideoSource2.defaultOptions,
          ...options
        };
        this._autoUpdate = true;
        this._isConnectedToTicker = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        this.autoPlay = options.autoPlay !== false;
        this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
        this._videoFrameRequestCallbackHandle = null;
        this._load = null;
        this._resolve = null;
        this._reject = null;
        this._onCanPlay = this._onCanPlay.bind(this);
        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
        this._onError = this._onError.bind(this);
        this._onPlayStart = this._onPlayStart.bind(this);
        this._onPlayStop = this._onPlayStop.bind(this);
        this._onSeeked = this._onSeeked.bind(this);
        if (options.autoLoad !== false) {
          void this.load();
        }
      }
      /** Update the video frame if the source is not destroyed and meets certain conditions. */
      updateFrame() {
        if (this.destroyed) {
          return;
        }
        if (this._updateFPS) {
          const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        }
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
        if (this.isValid) {
          this.update();
        }
      }
      /** Callback to update the video frame and potentially request the next frame update. */
      _videoFrameRequestCallback() {
        this.updateFrame();
        if (this.destroyed) {
          this._videoFrameRequestCallbackHandle = null;
        } else {
          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
      }
      /**
       * Checks if the resource has valid dimensions.
       * @returns {boolean} True if width and height are set, otherwise false.
       */
      get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight;
      }
      /**
       * Start preloading the video resource.
       * @returns {Promise<this>} Handle the validate event
       */
      async load() {
        if (this._load) {
          return this._load;
        }
        const source3 = this.resource;
        const options = this.options;
        if ((source3.readyState === source3.HAVE_ENOUGH_DATA || source3.readyState === source3.HAVE_FUTURE_DATA) && source3.width && source3.height) {
          source3.complete = true;
        }
        source3.addEventListener("play", this._onPlayStart);
        source3.addEventListener("pause", this._onPlayStop);
        source3.addEventListener("seeked", this._onSeeked);
        if (!this._isSourceReady()) {
          if (!options.preload) {
            source3.addEventListener("canplay", this._onCanPlay);
          }
          source3.addEventListener("canplaythrough", this._onCanPlayThrough);
          source3.addEventListener("error", this._onError, true);
        } else {
          this._mediaReady();
        }
        this.alphaMode = await detectVideoAlphaMode();
        this._load = new Promise((resolve, reject) => {
          if (this.isValid) {
            resolve(this);
          } else {
            this._resolve = resolve;
            this._reject = reject;
            if (options.preloadTimeoutMs !== void 0) {
              this._preloadTimeout = setTimeout(() => {
                this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
              });
            }
            source3.load();
          }
        });
        return this._load;
      }
      /**
       * Handle video error events.
       * @param event - The error event
       */
      _onError(event) {
        this.resource.removeEventListener("error", this._onError, true);
        this.emit("error", event);
        if (this._reject) {
          this._reject(event);
          this._reject = null;
          this._resolve = null;
        }
      }
      /**
       * Checks if the underlying source is playing.
       * @returns True if playing.
       */
      _isSourcePlaying() {
        const source3 = this.resource;
        return !source3.paused && !source3.ended;
      }
      /**
       * Checks if the underlying source is ready for playing.
       * @returns True if ready.
       */
      _isSourceReady() {
        const source3 = this.resource;
        return source3.readyState > 2;
      }
      /** Runs the update loop when the video is ready to play. */
      _onPlayStart() {
        if (!this.isValid) {
          this._mediaReady();
        }
        this._configureAutoUpdate();
      }
      /** Stops the update loop when a pause event is triggered. */
      _onPlayStop() {
        this._configureAutoUpdate();
      }
      /** Handles behavior when the video completes seeking to the current playback position. */
      _onSeeked() {
        if (this._autoUpdate && !this._isSourcePlaying()) {
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
        }
      }
      _onCanPlay() {
        const source3 = this.resource;
        source3.removeEventListener("canplay", this._onCanPlay);
        this._mediaReady();
      }
      _onCanPlayThrough() {
        const source3 = this.resource;
        source3.removeEventListener("canplaythrough", this._onCanPlay);
        if (this._preloadTimeout) {
          clearTimeout(this._preloadTimeout);
          this._preloadTimeout = void 0;
        }
        this._mediaReady();
      }
      /** Fired when the video is loaded and ready to play. */
      _mediaReady() {
        const source3 = this.resource;
        if (this.isValid) {
          this.isReady = true;
          this.resize(source3.videoWidth, source3.videoHeight);
        }
        this._msToNextUpdate = 0;
        this.updateFrame();
        this._msToNextUpdate = 0;
        if (this._resolve) {
          this._resolve(this);
          this._resolve = null;
          this._reject = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          void this.resource.play();
        }
      }
      /** Cleans up resources and event listeners associated with this texture. */
      destroy() {
        this._configureAutoUpdate();
        const source3 = this.resource;
        if (source3) {
          source3.removeEventListener("play", this._onPlayStart);
          source3.removeEventListener("pause", this._onPlayStop);
          source3.removeEventListener("seeked", this._onSeeked);
          source3.removeEventListener("canplay", this._onCanPlay);
          source3.removeEventListener("canplaythrough", this._onCanPlayThrough);
          source3.removeEventListener("error", this._onError, true);
          source3.pause();
          source3.src = "";
          source3.load();
        }
        super.destroy();
      }
      /** Should the base texture automatically update itself, set to true by default. */
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * How many times a second to update the texture from the video.
       * Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get updateFPS() {
        return this._updateFPS;
      }
      set updateFPS(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * Configures the updating mechanism based on the current state and settings.
       *
       * This method decides between using the browser's native video frame callback or a custom ticker
       * for updating the video frame. It ensures optimal performance and responsiveness
       * based on the video's state, playback status, and the desired frames-per-second setting.
       *
       * - If `_autoUpdate` is enabled and the video source is playing:
       *   - It will prefer the native video frame callback if available and no specific FPS is set.
       *   - Otherwise, it will use a custom ticker for manual updates.
       * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
       */
      _configureAutoUpdate() {
        if (this._autoUpdate && this._isSourcePlaying()) {
          if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
            if (this._videoFrameRequestCallbackHandle === null) {
              this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                this._videoFrameRequestCallback
              );
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (!this._isConnectedToTicker) {
              Ticker.shared.add(this.updateFrame, this);
              this._isConnectedToTicker = true;
              this._msToNextUpdate = 0;
            }
          }
        } else {
          if (this._videoFrameRequestCallbackHandle !== null) {
            this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
            this._videoFrameRequestCallbackHandle = null;
          }
          if (this._isConnectedToTicker) {
            Ticker.shared.remove(this.updateFrame, this);
            this._isConnectedToTicker = false;
            this._msToNextUpdate = 0;
          }
        }
      }
      static test(resource) {
        return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
      }
    };
    _VideoSource.extension = ExtensionType.TextureSource;
    _VideoSource.defaultOptions = {
      ...TextureSource.defaultOptions,
      /** If true, the video will start loading immediately. */
      autoLoad: true,
      /** If true, the video will start playing as soon as it is loaded. */
      autoPlay: true,
      /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
      updateFPS: 0,
      /** If true, the video will be loaded with the `crossorigin` attribute. */
      crossorigin: true,
      /** If true, the video will loop when it ends. */
      loop: false,
      /** If true, the video will be muted. */
      muted: true,
      /** If true, the video will play inline. */
      playsinline: true,
      /** If true, the video will be preloaded. */
      preload: false
    };
    _VideoSource.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
    VideoSource = _VideoSource;
  }
});

// node_modules/pixi.js/lib/assets/cache/Cache.mjs
var CacheClass, Cache;
var init_Cache = __esm({
  "node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
    init_warn();
    init_convertToList();
    CacheClass = class {
      constructor() {
        this._parsers = [];
        this._cache = /* @__PURE__ */ new Map();
        this._cacheMap = /* @__PURE__ */ new Map();
      }
      /** Clear all entries. */
      reset() {
        this._cacheMap.clear();
        this._cache.clear();
      }
      /**
       * Check if the key exists
       * @param key - The key to check
       */
      has(key) {
        return this._cache.has(key);
      }
      /**
       * Fetch entry by key
       * @param key - The key of the entry to get
       */
      get(key) {
        const result = this._cache.get(key);
        if (!result) {
          warn(`[Assets] Asset id ${key} was not found in the Cache`);
        }
        return result;
      }
      /**
       * Set a value by key or keys name
       * @param key - The key or keys to set
       * @param value - The value to store in the cache or from which cacheable assets will be derived.
       */
      set(key, value) {
        const keys = convertToList(key);
        let cacheableAssets;
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parser = this.parsers[i2];
          if (parser.test(value)) {
            cacheableAssets = parser.getCacheableAssets(keys, value);
            break;
          }
        }
        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
        if (!cacheableAssets) {
          keys.forEach((key2) => {
            cacheableMap.set(key2, value);
          });
        }
        const cacheKeys = [...cacheableMap.keys()];
        const cachedAssets = {
          cacheKeys,
          keys
        };
        keys.forEach((key2) => {
          this._cacheMap.set(key2, cachedAssets);
        });
        cacheKeys.forEach((key2) => {
          const val = cacheableAssets ? cacheableAssets[key2] : value;
          if (this._cache.has(key2) && this._cache.get(key2) !== val) {
            warn("[Cache] already has key:", key2);
          }
          this._cache.set(key2, cacheableMap.get(key2));
        });
      }
      /**
       * Remove entry by key
       *
       * This function will also remove any associated alias from the cache also.
       * @param key - The key of the entry to remove
       */
      remove(key) {
        if (!this._cacheMap.has(key)) {
          warn(`[Assets] Asset id ${key} was not found in the Cache`);
          return;
        }
        const cacheMap2 = this._cacheMap.get(key);
        const cacheKeys = cacheMap2.cacheKeys;
        cacheKeys.forEach((key2) => {
          this._cache.delete(key2);
        });
        cacheMap2.keys.forEach((key2) => {
          this._cacheMap.delete(key2);
        });
      }
      /**
       * All loader parsers registered
       * @advanced
       */
      get parsers() {
        return this._parsers;
      }
    };
    Cache = new CacheClass();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
function textureSourceFrom(options = {}) {
  const hasResource = options && options.resource;
  const res = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  for (let i2 = 0; i2 < sources.length; i2++) {
    const Source = sources[i2];
    if (Source.test(res)) {
      return new Source(opts);
    }
  }
  throw new Error(`Could not find a source type for resource: ${opts.resource}`);
}
function resourceToTexture(options = {}, skipCache = false) {
  const hasResource = options && options.resource;
  const resource = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  if (!skipCache && Cache.has(resource)) {
    return Cache.get(resource);
  }
  const texture = new Texture({ source: textureSourceFrom(opts) });
  texture.on("destroy", () => {
    if (Cache.has(resource)) {
      Cache.remove(resource);
    }
  });
  if (!skipCache) {
    Cache.set(resource, texture);
  }
  return texture;
}
function textureFrom(id, skipCache = false) {
  if (typeof id === "string") {
    return Cache.get(id);
  } else if (id instanceof TextureSource) {
    return new Texture({ source: id });
  }
  return resourceToTexture(id, skipCache);
}
var sources;
var init_textureFrom = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs"() {
    init_Cache();
    init_Extensions();
    init_TextureSource();
    init_Texture();
    sources = [];
    extensions.handleByList(ExtensionType.TextureSource, sources);
    Texture.from = textureFrom;
    TextureSource.from = textureSourceFrom;
  }
});

// node_modules/pixi.js/lib/rendering/init.mjs
var init_init6 = __esm({
  "node_modules/pixi.js/lib/rendering/init.mjs"() {
    init_Extensions();
    init_AlphaMask();
    init_ColorMask();
    init_StencilMask();
    init_BufferImageSource();
    init_CanvasSource();
    init_ImageSource();
    init_VideoSource();
    init_textureFrom();
    extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
var BindGroup;
var init_BindGroup = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
    "use strict";
    BindGroup = class {
      /**
       * Create a new instance eof the Bind Group.
       * @param resources - The resources that are bound together for use by a shader.
       */
      constructor(resources) {
        this.resources = /* @__PURE__ */ Object.create(null);
        this._dirty = true;
        let index = 0;
        for (const i2 in resources) {
          const resource = resources[i2];
          this.setResource(resource, index++);
        }
        this._updateKey();
      }
      /**
       * Updates the key if its flagged as dirty. This is used internally to
       * match this bind group to a WebGPU BindGroup.
       * @internal
       */
      _updateKey() {
        if (!this._dirty)
          return;
        this._dirty = false;
        const keyParts = [];
        let index = 0;
        for (const i2 in this.resources) {
          keyParts[index++] = this.resources[i2]._resourceId;
        }
        this._key = keyParts.join("|");
      }
      /**
       * Set a resource at a given index. this function will
       * ensure that listeners will be removed from the current resource
       * and added to the new resource.
       * @param resource - The resource to set.
       * @param index - The index to set the resource at.
       */
      setResource(resource, index) {
        const currentResource = this.resources[index];
        if (resource === currentResource)
          return;
        if (currentResource) {
          resource.off?.("change", this.onResourceChange, this);
        }
        resource.on?.("change", this.onResourceChange, this);
        this.resources[index] = resource;
        this._dirty = true;
      }
      /**
       * Returns the resource at the current specified index.
       * @param index - The index of the resource to get.
       * @returns - The resource at the specified index.
       */
      getResource(index) {
        return this.resources[index];
      }
      /**
       * Used internally to 'touch' each resource, to ensure that the GC
       * knows that all resources in this bind group are still being used.
       * @param tick - The current tick.
       * @internal
       */
      _touch(tick) {
        const resources = this.resources;
        for (const i2 in resources) {
          resources[i2]._touched = tick;
        }
      }
      /** Destroys this bind group and removes all listeners. */
      destroy() {
        const resources = this.resources;
        for (const i2 in resources) {
          const resource = resources[i2];
          resource?.off?.("change", this.onResourceChange, this);
        }
        this.resources = null;
      }
      onResourceChange(resource) {
        this._dirty = true;
        if (resource.destroyed) {
          const resources = this.resources;
          for (const i2 in resources) {
            if (resources[i2] === resource) {
              resources[i2] = null;
            }
          }
        } else {
          this._updateKey();
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
function getTextureBatchBindGroup(textures, size, maxTextures) {
  let uid3 = 2166136261;
  for (let i2 = 0; i2 < size; i2++) {
    uid3 ^= textures[i2].uid;
    uid3 = Math.imul(uid3, 16777619);
    uid3 >>>= 0;
  }
  return cachedGroups[uid3] || generateTextureBatchBindGroup(textures, size, uid3, maxTextures);
}
function generateTextureBatchBindGroup(textures, size, key, maxTextures) {
  const bindGroupResources = {};
  let bindIndex = 0;
  for (let i2 = 0; i2 < maxTextures; i2++) {
    const texture = i2 < size ? textures[i2] : Texture.EMPTY.source;
    bindGroupResources[bindIndex++] = texture.source;
    bindGroupResources[bindIndex++] = texture.style;
  }
  const bindGroup = new BindGroup(bindGroupResources);
  cachedGroups[key] = bindGroup;
  return bindGroup;
}
var cachedGroups;
var init_getTextureBatchBindGroup = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
    init_BindGroup();
    init_Texture();
    cachedGroups = {};
  }
});

// node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs
var ViewableBuffer;
var init_ViewableBuffer = __esm({
  "node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs"() {
    "use strict";
    ViewableBuffer = class {
      constructor(sizeOrBuffer) {
        if (typeof sizeOrBuffer === "number") {
          this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
          this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
          this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
        this.size = this.rawBinaryData.byteLength;
      }
      /** View on the raw binary data as a `Int8Array`. */
      get int8View() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      }
      /** View on the raw binary data as a `Uint8Array`. */
      get uint8View() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      }
      /**  View on the raw binary data as a `Int16Array`. */
      get int16View() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      }
      /** View on the raw binary data as a `Int32Array`. */
      get int32View() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      }
      /** View on the raw binary data as a `Float64Array`. */
      get float64View() {
        if (!this._float64Array) {
          this._float64Array = new Float64Array(this.rawBinaryData);
        }
        return this._float64Array;
      }
      /** View on the raw binary data as a `BigUint64Array`. */
      get bigUint64View() {
        if (!this._bigUint64Array) {
          this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
        }
        return this._bigUint64Array;
      }
      /**
       * Returns the view of the given type.
       * @param type - One of `int8`, `uint8`, `int16`,
       *    `uint16`, `int32`, `uint32`, and `float32`.
       * @returns - typed array of given type
       */
      view(type) {
        return this[`${type}View`];
      }
      /** Destroys all buffer references. Do not use after calling this. */
      destroy() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this.uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      }
      /**
       * Returns the size of the given type in bytes.
       * @param type - One of `int8`, `uint8`, `int16`,
       *   `uint16`, `int32`, `uint32`, and `float32`.
       * @returns - size of the type in bytes
       */
      static sizeOf(type) {
        switch (type) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(`${type} isn't a valid view type`);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
function fastCopy(sourceBuffer, destinationBuffer) {
  const lengthDouble = sourceBuffer.byteLength / 8 | 0;
  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
  destinationFloat64View.set(sourceFloat64View);
  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
  if (remainingBytes > 0) {
    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
    destinationUint8View.set(sourceUint8View);
  }
}
var init_fastCopy = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
var BLEND_TO_NPM, STENCIL_MODES;
var init_const3 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
    "use strict";
    BLEND_TO_NPM = {
      normal: "normal-npm",
      add: "add-npm",
      screen: "screen-npm"
    };
    STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
      STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
      STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
      STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
      STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
      return STENCIL_MODES2;
    })(STENCIL_MODES || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
function getAdjustedBlendModeBlend(blendMode, textureSource) {
  if (textureSource.alphaMode === "no-premultiply-alpha") {
    return BLEND_TO_NPM[blendMode] || blendMode;
  }
  return blendMode;
}
var init_getAdjustedBlendModeBlend = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"() {
    init_const3();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
function getTestContext() {
  if (!context || context?.isContextLost()) {
    const canvas = DOMAdapter.get().createCanvas();
    context = canvas.getContext("webgl", {});
  }
  return context;
}
var context;
var init_getTestContext = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i2 = 0; i2 < maxIfs; ++i2) {
    if (i2 > 0) {
      src += "\nelse ";
    }
    if (i2 < maxIfs - 1) {
      src += `if(test == ${i2}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  try {
    while (true) {
      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
  } finally {
    gl.deleteShader(shader);
  }
  return maxIfs;
}
var fragTemplate;
var init_checkMaxIfStatementsInShader = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs"() {
    "use strict";
    fragTemplate = [
      "precision mediump float;",
      "void main(void){",
      "float test = 0.1;",
      "%forloop%",
      "gl_FragColor = vec4(0.0);",
      "}"
    ].join("\n");
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs
function getMaxTexturesPerBatch() {
  if (maxTexturesPerBatchCache)
    return maxTexturesPerBatchCache;
  const gl = getTestContext();
  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(
    maxTexturesPerBatchCache,
    gl
  );
  gl.getExtension("WEBGL_lose_context")?.loseContext();
  return maxTexturesPerBatchCache;
}
var maxTexturesPerBatchCache;
var init_maxRecommendedTextures = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs"() {
    init_getTestContext();
    init_checkMaxIfStatementsInShader();
    maxTexturesPerBatchCache = null;
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
var BatchTextureArray;
var init_BatchTextureArray = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
    "use strict";
    BatchTextureArray = class {
      constructor() {
        this.ids = /* @__PURE__ */ Object.create(null);
        this.textures = [];
        this.count = 0;
      }
      /** Clear the textures and their locations. */
      clear() {
        for (let i2 = 0; i2 < this.count; i2++) {
          const t2 = this.textures[i2];
          this.textures[i2] = null;
          this.ids[t2.uid] = null;
        }
        this.count = 0;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
function getBatchFromPool() {
  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
}
function returnBatchToPool(batch) {
  batchPool[batchPoolIndex++] = batch;
}
var Batch, batchPool, batchPoolIndex, BATCH_TICK, _Batcher, Batcher;
var init_Batcher = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
    init_uid();
    init_ViewableBuffer();
    init_deprecation();
    init_GlobalResourceRegistry();
    init_fastCopy();
    init_getAdjustedBlendModeBlend();
    init_maxRecommendedTextures();
    init_BatchTextureArray();
    Batch = class {
      constructor() {
        this.renderPipeId = "batch";
        this.action = "startBatch";
        this.start = 0;
        this.size = 0;
        this.textures = new BatchTextureArray();
        this.blendMode = "normal";
        this.topology = "triangle-strip";
        this.canBundle = true;
      }
      destroy() {
        this.textures = null;
        this.gpuBindGroup = null;
        this.bindGroup = null;
        this.batcher = null;
      }
    };
    batchPool = [];
    batchPoolIndex = 0;
    GlobalResourceRegistry.register({
      clear: () => {
        if (batchPool.length > 0) {
          for (const item of batchPool) {
            if (item)
              item.destroy();
          }
        }
        batchPool.length = 0;
        batchPoolIndex = 0;
      }
    });
    BATCH_TICK = 0;
    _Batcher = class _Batcher2 {
      constructor(options) {
        this.uid = uid("batcher");
        this.dirty = true;
        this.batchIndex = 0;
        this.batches = [];
        this._elements = [];
        options = { ..._Batcher2.defaultOptions, ...options };
        if (!options.maxTextures) {
          deprecation("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options");
          options.maxTextures = getMaxTexturesPerBatch();
        }
        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;
        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
        this.indexBuffer = new Uint16Array(indicesInitialSize);
        this.maxTextures = maxTextures;
      }
      begin() {
        this.elementSize = 0;
        this.elementStart = 0;
        this.indexSize = 0;
        this.attributeSize = 0;
        for (let i2 = 0; i2 < this.batchIndex; i2++) {
          returnBatchToPool(this.batches[i2]);
        }
        this.batchIndex = 0;
        this._batchIndexStart = 0;
        this._batchIndexSize = 0;
        this.dirty = true;
      }
      add(batchableObject) {
        this._elements[this.elementSize++] = batchableObject;
        batchableObject._indexStart = this.indexSize;
        batchableObject._attributeStart = this.attributeSize;
        batchableObject._batcher = this;
        this.indexSize += batchableObject.indexSize;
        this.attributeSize += batchableObject.attributeSize * this.vertexSize;
      }
      checkAndUpdateTexture(batchableObject, texture) {
        const textureId = batchableObject._batch.textures.ids[texture._source.uid];
        if (!textureId && textureId !== 0)
          return false;
        batchableObject._textureId = textureId;
        batchableObject.texture = texture;
        return true;
      }
      updateElement(batchableObject) {
        this.dirty = true;
        const attributeBuffer = this.attributeBuffer;
        if (batchableObject.packAsQuad) {
          this.packQuadAttributes(
            batchableObject,
            attributeBuffer.float32View,
            attributeBuffer.uint32View,
            batchableObject._attributeStart,
            batchableObject._textureId
          );
        } else {
          this.packAttributes(
            batchableObject,
            attributeBuffer.float32View,
            attributeBuffer.uint32View,
            batchableObject._attributeStart,
            batchableObject._textureId
          );
        }
      }
      /**
       * breaks the batcher. This happens when a batch gets too big,
       * or we need to switch to a different type of rendering (a filter for example)
       * @param instructionSet
       */
      break(instructionSet) {
        const elements = this._elements;
        if (!elements[this.elementStart])
          return;
        let batch = getBatchFromPool();
        let textureBatch = batch.textures;
        textureBatch.clear();
        const firstElement = elements[this.elementStart];
        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
        let topology = firstElement.topology;
        if (this.attributeSize * 4 > this.attributeBuffer.size) {
          this._resizeAttributeBuffer(this.attributeSize * 4);
        }
        if (this.indexSize > this.indexBuffer.length) {
          this._resizeIndexBuffer(this.indexSize);
        }
        const f32 = this.attributeBuffer.float32View;
        const u32 = this.attributeBuffer.uint32View;
        const indexBuffer = this.indexBuffer;
        let size = this._batchIndexSize;
        let start = this._batchIndexStart;
        let action = "startBatch";
        const maxTextures = this.maxTextures;
        for (let i2 = this.elementStart; i2 < this.elementSize; ++i2) {
          const element = elements[i2];
          elements[i2] = null;
          const texture = element.texture;
          const source3 = texture._source;
          const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source3);
          const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;
          if (source3._batchTick === BATCH_TICK && !breakRequired) {
            element._textureId = source3._textureBindLocation;
            size += element.indexSize;
            if (element.packAsQuad) {
              this.packQuadAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packQuadIndex(
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            } else {
              this.packAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packIndex(
                element,
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            }
            element._batch = batch;
            continue;
          }
          source3._batchTick = BATCH_TICK;
          if (textureBatch.count >= maxTextures || breakRequired) {
            this._finishBatch(
              batch,
              start,
              size - start,
              textureBatch,
              blendMode,
              topology,
              instructionSet,
              action
            );
            action = "renderBatch";
            start = size;
            blendMode = adjustedBlendMode;
            topology = element.topology;
            batch = getBatchFromPool();
            textureBatch = batch.textures;
            textureBatch.clear();
            ++BATCH_TICK;
          }
          element._textureId = source3._textureBindLocation = textureBatch.count;
          textureBatch.ids[source3.uid] = textureBatch.count;
          textureBatch.textures[textureBatch.count++] = source3;
          element._batch = batch;
          size += element.indexSize;
          if (element.packAsQuad) {
            this.packQuadAttributes(
              element,
              f32,
              u32,
              element._attributeStart,
              element._textureId
            );
            this.packQuadIndex(
              indexBuffer,
              element._indexStart,
              element._attributeStart / this.vertexSize
            );
          } else {
            this.packAttributes(
              element,
              f32,
              u32,
              element._attributeStart,
              element._textureId
            );
            this.packIndex(
              element,
              indexBuffer,
              element._indexStart,
              element._attributeStart / this.vertexSize
            );
          }
        }
        if (textureBatch.count > 0) {
          this._finishBatch(
            batch,
            start,
            size - start,
            textureBatch,
            blendMode,
            topology,
            instructionSet,
            action
          );
          start = size;
          ++BATCH_TICK;
        }
        this.elementStart = this.elementSize;
        this._batchIndexStart = start;
        this._batchIndexSize = size;
      }
      _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {
        batch.gpuBindGroup = null;
        batch.bindGroup = null;
        batch.action = action;
        batch.batcher = this;
        batch.textures = textureBatch;
        batch.blendMode = blendMode;
        batch.topology = topology;
        batch.start = indexStart;
        batch.size = indexSize;
        ++BATCH_TICK;
        this.batches[this.batchIndex++] = batch;
        instructionSet.add(batch);
      }
      finish(instructionSet) {
        this.break(instructionSet);
      }
      /**
       * Resizes the attribute buffer to the given size (1 = 1 float32)
       * @param size - the size in vertices to ensure (not bytes!)
       */
      ensureAttributeBuffer(size) {
        if (size * 4 <= this.attributeBuffer.size)
          return;
        this._resizeAttributeBuffer(size * 4);
      }
      /**
       * Resizes the index buffer to the given size (1 = 1 float32)
       * @param size - the size in vertices to ensure (not bytes!)
       */
      ensureIndexBuffer(size) {
        if (size <= this.indexBuffer.length)
          return;
        this._resizeIndexBuffer(size);
      }
      _resizeAttributeBuffer(size) {
        const newSize = Math.max(size, this.attributeBuffer.size * 2);
        const newArrayBuffer = new ViewableBuffer(newSize);
        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
        this.attributeBuffer = newArrayBuffer;
      }
      _resizeIndexBuffer(size) {
        const indexBuffer = this.indexBuffer;
        let newSize = Math.max(size, indexBuffer.length * 1.5);
        newSize += newSize % 2;
        const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
          for (let i2 = 0; i2 < indexBuffer.length; i2++) {
            newIndexBuffer[i2] = indexBuffer[i2];
          }
        } else {
          fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
        }
        this.indexBuffer = newIndexBuffer;
      }
      packQuadIndex(indexBuffer, index, indicesOffset) {
        indexBuffer[index] = indicesOffset + 0;
        indexBuffer[index + 1] = indicesOffset + 1;
        indexBuffer[index + 2] = indicesOffset + 2;
        indexBuffer[index + 3] = indicesOffset + 0;
        indexBuffer[index + 4] = indicesOffset + 2;
        indexBuffer[index + 5] = indicesOffset + 3;
      }
      packIndex(element, indexBuffer, index, indicesOffset) {
        const indices = element.indices;
        const size = element.indexSize;
        const indexOffset = element.indexOffset;
        const attributeOffset = element.attributeOffset;
        for (let i2 = 0; i2 < size; i2++) {
          indexBuffer[index++] = indicesOffset + indices[i2 + indexOffset] - attributeOffset;
        }
      }
      destroy() {
        if (this.batches === null)
          return;
        for (let i2 = 0; i2 < this.batches.length; i2++) {
          returnBatchToPool(this.batches[i2]);
        }
        this.batches = null;
        for (let i2 = 0; i2 < this._elements.length; i2++) {
          if (this._elements[i2])
            this._elements[i2]._batch = null;
        }
        this._elements = null;
        this.indexBuffer = null;
        this.attributeBuffer.destroy();
        this.attributeBuffer = null;
      }
    };
    _Batcher.defaultOptions = {
      maxTextures: null,
      attributesInitialSize: 4,
      indicesInitialSize: 6
    };
    Batcher = _Batcher;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
var BufferUsage;
var init_const4 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
    "use strict";
    BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
      BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
      BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
      BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
      BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
      BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
      BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
      BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
      BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
      BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
      BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
      BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
      return BufferUsage2;
    })(BufferUsage || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
var Buffer2;
var init_Buffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
    init_eventemitter3();
    init_uid();
    init_const4();
    Buffer2 = class extends eventemitter3_default {
      /**
       * Creates a new Buffer with the given options
       * @param options - the options for the buffer
       */
      constructor(options) {
        let { data, size } = options;
        const { usage, label, shrinkToFit } = options;
        super();
        this.uid = uid("buffer");
        this._resourceType = "buffer";
        this._resourceId = uid("resource");
        this._touched = 0;
        this._updateID = 1;
        this._dataInt32 = null;
        this.shrinkToFit = true;
        this.destroyed = false;
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        this._data = data;
        size ?? (size = data?.byteLength);
        const mappedAtCreation = !!data;
        this.descriptor = {
          size,
          usage,
          mappedAtCreation,
          label
        };
        this.shrinkToFit = shrinkToFit ?? true;
      }
      /** the data in the buffer */
      get data() {
        return this._data;
      }
      set data(value) {
        this.setDataWithSize(value, value.length, true);
      }
      get dataInt32() {
        if (!this._dataInt32) {
          this._dataInt32 = new Int32Array(this.data.buffer);
        }
        return this._dataInt32;
      }
      /** whether the buffer is static or not */
      get static() {
        return !!(this.descriptor.usage & BufferUsage.STATIC);
      }
      set static(value) {
        if (value) {
          this.descriptor.usage |= BufferUsage.STATIC;
        } else {
          this.descriptor.usage &= ~BufferUsage.STATIC;
        }
      }
      /**
       * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
       * If you only want to update a subset of the buffer, you can pass in the size of the data.
       * @param value - the data to set
       * @param size - the size of the data in bytes
       * @param syncGPU - should the buffer be updated on the GPU immediately?
       */
      setDataWithSize(value, size, syncGPU) {
        this._updateID++;
        this._updateSize = size * value.BYTES_PER_ELEMENT;
        if (this._data === value) {
          if (syncGPU)
            this.emit("update", this);
          return;
        }
        const oldData = this._data;
        this._data = value;
        this._dataInt32 = null;
        if (!oldData || oldData.length !== value.length) {
          if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {
            if (syncGPU)
              this.emit("update", this);
          } else {
            this.descriptor.size = value.byteLength;
            this._resourceId = uid("resource");
            this.emit("change", this);
          }
          return;
        }
        if (syncGPU)
          this.emit("update", this);
      }
      /**
       * updates the buffer on the GPU to reflect the data in the buffer.
       * By default it will update the entire buffer. If you only want to update a subset of the buffer,
       * you can pass in the size of the buffer to update.
       * @param sizeInBytes - the new size of the buffer in bytes
       */
      update(sizeInBytes) {
        this._updateSize = sizeInBytes ?? this._updateSize;
        this._updateID++;
        this.emit("update", this);
      }
      /** Destroys the buffer */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        this.emit("change", this);
        this._data = null;
        this.descriptor = null;
        this.removeAllListeners();
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
function ensureIsBuffer(buffer, index) {
  if (!(buffer instanceof Buffer2)) {
    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
    if (buffer instanceof Array) {
      if (index) {
        buffer = new Uint32Array(buffer);
        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
      } else {
        buffer = new Float32Array(buffer);
        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
      }
    }
    buffer = new Buffer2({
      data: buffer,
      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage
    });
  }
  return buffer;
}
var init_ensureIsBuffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
    init_Buffer();
    init_const4();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
function getGeometryBounds(geometry, attributeId, bounds) {
  const attribute = geometry.getAttribute(attributeId);
  if (!attribute) {
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = 0;
    bounds.maxY = 0;
    return bounds;
  }
  const data = attribute.buffer.data;
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  const byteSize = data.BYTES_PER_ELEMENT;
  const offset = (attribute.offset || 0) / byteSize;
  const stride = (attribute.stride || 2 * 4) / byteSize;
  for (let i2 = offset; i2 < data.length; i2 += stride) {
    const x2 = data[i2];
    const y2 = data[i2 + 1];
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
  }
  bounds.minX = minX;
  bounds.minY = minY;
  bounds.maxX = maxX;
  bounds.maxY = maxY;
  return bounds;
}
var init_getGeometryBounds = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
function ensureIsAttribute(attribute) {
  if (attribute instanceof Buffer2 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
    attribute = {
      buffer: attribute
    };
  }
  attribute.buffer = ensureIsBuffer(attribute.buffer, false);
  return attribute;
}
var Geometry;
var init_Geometry = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
    init_eventemitter3();
    init_Bounds();
    init_uid();
    init_Buffer();
    init_ensureIsBuffer();
    init_getGeometryBounds();
    Geometry = class extends eventemitter3_default {
      /**
       * Create a new instance of a geometry
       * @param options - The options for the geometry.
       */
      constructor(options = {}) {
        super();
        this.uid = uid("geometry");
        this._layoutKey = 0;
        this.instanceCount = 1;
        this._bounds = new Bounds();
        this._boundsDirty = true;
        const { attributes, indexBuffer, topology } = options;
        this.buffers = [];
        this.attributes = {};
        if (attributes) {
          for (const i2 in attributes) {
            this.addAttribute(i2, attributes[i2]);
          }
        }
        this.instanceCount = options.instanceCount ?? 1;
        if (indexBuffer) {
          this.addIndex(indexBuffer);
        }
        this.topology = topology || "triangle-list";
      }
      onBufferUpdate() {
        this._boundsDirty = true;
        this.emit("update", this);
      }
      /**
       * Returns the requested attribute.
       * @param id - The name of the attribute required
       * @returns - The attribute requested.
       */
      getAttribute(id) {
        return this.attributes[id];
      }
      /**
       * Returns the index buffer
       * @returns - The index buffer.
       */
      getIndex() {
        return this.indexBuffer;
      }
      /**
       * Returns the requested buffer.
       * @param id - The name of the buffer required.
       * @returns - The buffer requested.
       */
      getBuffer(id) {
        return this.getAttribute(id).buffer;
      }
      /**
       * Used to figure out how many vertices there are in this geometry
       * @returns the number of vertices in the geometry
       */
      getSize() {
        for (const i2 in this.attributes) {
          const attribute = this.attributes[i2];
          const buffer = attribute.buffer;
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      }
      /**
       * Adds an attribute to the geometry.
       * @param name - The name of the attribute to add.
       * @param attributeOption - The attribute option to add.
       */
      addAttribute(name, attributeOption) {
        const attribute = ensureIsAttribute(attributeOption);
        const bufferIndex = this.buffers.indexOf(attribute.buffer);
        if (bufferIndex === -1) {
          this.buffers.push(attribute.buffer);
          attribute.buffer.on("update", this.onBufferUpdate, this);
          attribute.buffer.on("change", this.onBufferUpdate, this);
        }
        this.attributes[name] = attribute;
      }
      /**
       * Adds an index buffer to the geometry.
       * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
       */
      addIndex(indexBuffer) {
        this.indexBuffer = ensureIsBuffer(indexBuffer, true);
        this.buffers.push(this.indexBuffer);
      }
      /** Returns the bounds of the geometry. */
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        this._boundsDirty = false;
        return getGeometryBounds(this, "aPosition", this._bounds);
      }
      /**
       * destroys the geometry.
       * @param destroyBuffers - destroy the buffers associated with this geometry
       */
      destroy(destroyBuffers = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        if (destroyBuffers) {
          this.buffers.forEach((buffer) => buffer.destroy());
        }
        this.attributes = null;
        this.buffers = null;
        this.indexBuffer = null;
        this._bounds = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs
var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
var init_BatchGeometry = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs"() {
    init_Buffer();
    init_const4();
    init_Geometry();
    placeHolderBufferData = new Float32Array(1);
    placeHolderIndexData = new Uint32Array(1);
    BatchGeometry = class extends Geometry {
      constructor() {
        const vertexSize = 6;
        const attributeBuffer = new Buffer2({
          data: placeHolderBufferData,
          label: "attribute-batch-buffer",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
          shrinkToFit: false
        });
        const indexBuffer = new Buffer2({
          data: placeHolderIndexData,
          label: "index-batch-buffer",
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
          // | BufferUsage.STATIC,
          shrinkToFit: false
        });
        const stride = vertexSize * 4;
        super({
          attributes: {
            aPosition: {
              buffer: attributeBuffer,
              format: "float32x2",
              stride,
              offset: 0
            },
            aUV: {
              buffer: attributeBuffer,
              format: "float32x2",
              stride,
              offset: 2 * 4
            },
            aColor: {
              buffer: attributeBuffer,
              format: "unorm8x4",
              stride,
              offset: 4 * 4
            },
            aTextureIdAndRound: {
              buffer: attributeBuffer,
              format: "uint16x2",
              stride,
              offset: 5 * 4
            }
          },
          indexBuffer
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
function createIdFromString(value, groupId) {
  let id = idHash2[value];
  if (id === void 0) {
    if (idCounts[groupId] === void 0) {
      idCounts[groupId] = 1;
    }
    idHash2[value] = id = idCounts[groupId]++;
  }
  return id;
}
var idCounts, idHash2;
var init_createIdFromString = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
    "use strict";
    idCounts = /* @__PURE__ */ Object.create(null);
    idHash2 = /* @__PURE__ */ Object.create(null);
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = "mediump";
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision;
}
var maxFragmentPrecision;
var init_getMaxFragmentPrecision = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
    init_getTestContext();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
function addProgramDefines(src, isES300, isFragment) {
  if (isES300)
    return src;
  if (isFragment) {
    src = src.replace("out vec4 finalColor;", "");
    return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
  }
  return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
}
var init_addProgramDefines = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
function ensurePrecision(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var init_ensurePrecision = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
function insertVersion(src, isES300) {
  if (!isES300)
    return src;
  return `#version 300 es
${src}`;
}
var init_insertVersion = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache[name]) {
    nameCache[name]++;
    name += `-${nameCache[name]}`;
  } else {
    nameCache[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  return `${shaderName}
${src}`;
}
var fragmentNameCache, VertexNameCache;
var init_setProgramName = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs"() {
    "use strict";
    fragmentNameCache = {};
    VertexNameCache = {};
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
function stripVersion(src, isES300) {
  if (!isES300)
    return src;
  return src.replace("#version 300 es", "");
}
var init_stripVersion = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
var processes, programCache, _GlProgram, GlProgram;
var init_GlProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
    init_createIdFromString();
    init_getMaxFragmentPrecision();
    init_addProgramDefines();
    init_ensurePrecision();
    init_insertVersion();
    init_setProgramName();
    init_stripVersion();
    processes = {
      // strips any version headers..
      stripVersion,
      // adds precision string if not already present
      ensurePrecision,
      // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
      addProgramDefines,
      // add the program name to the shader
      setProgramName,
      // add the version string to the shader header
      insertVersion
    };
    programCache = /* @__PURE__ */ Object.create(null);
    _GlProgram = class _GlProgram2 {
      /**
       * Creates a shiny new GlProgram. Used by WebGL renderer.
       * @param options - The options for the program.
       */
      constructor(options) {
        options = { ..._GlProgram2.defaultOptions, ...options };
        const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
        const preprocessorOptions = {
          stripVersion: isES300,
          ensurePrecision: {
            requestedFragmentPrecision: options.preferredFragmentPrecision,
            requestedVertexPrecision: options.preferredVertexPrecision,
            maxSupportedVertexPrecision: "highp",
            maxSupportedFragmentPrecision: getMaxFragmentPrecision()
          },
          setProgramName: {
            name: options.name
          },
          addProgramDefines: isES300,
          insertVersion: isES300
        };
        let fragment4 = options.fragment;
        let vertex4 = options.vertex;
        Object.keys(processes).forEach((processKey) => {
          const processOptions = preprocessorOptions[processKey];
          fragment4 = processes[processKey](fragment4, processOptions, true);
          vertex4 = processes[processKey](vertex4, processOptions, false);
        });
        this.fragment = fragment4;
        this.vertex = vertex4;
        this.transformFeedbackVaryings = options.transformFeedbackVaryings;
        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
      }
      /** destroys the program */
      destroy() {
        this.fragment = null;
        this.vertex = null;
        this._attributeData = null;
        this._uniformData = null;
        this._uniformBlockData = null;
        this.transformFeedbackVaryings = null;
        programCache[this._cacheKey] = null;
      }
      /**
       * Helper function that creates a program for a given source.
       * It will check the program cache if the program has already been created.
       * If it has that one will be returned, if not a new one will be created and cached.
       * @param options - The options for the program.
       * @returns A program using the same source
       */
      static from(options) {
        const key = `${options.vertex}:${options.fragment}`;
        if (!programCache[key]) {
          programCache[key] = new _GlProgram2(options);
          programCache[key]._cacheKey = key;
        }
        return programCache[key];
      }
    };
    _GlProgram.defaultOptions = {
      preferredVertexPrecision: "highp",
      preferredFragmentPrecision: "mediump"
    };
    GlProgram = _GlProgram;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
function getAttributeInfoFromFormat(format) {
  return attributeFormatData[format] ?? attributeFormatData.float32;
}
var attributeFormatData;
var init_getAttributeInfoFromFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"() {
    "use strict";
    attributeFormatData = {
      uint8x2: { size: 2, stride: 2, normalised: false },
      uint8x4: { size: 4, stride: 4, normalised: false },
      sint8x2: { size: 2, stride: 2, normalised: false },
      sint8x4: { size: 4, stride: 4, normalised: false },
      unorm8x2: { size: 2, stride: 2, normalised: true },
      unorm8x4: { size: 4, stride: 4, normalised: true },
      snorm8x2: { size: 2, stride: 2, normalised: true },
      snorm8x4: { size: 4, stride: 4, normalised: true },
      uint16x2: { size: 2, stride: 4, normalised: false },
      uint16x4: { size: 4, stride: 8, normalised: false },
      sint16x2: { size: 2, stride: 4, normalised: false },
      sint16x4: { size: 4, stride: 8, normalised: false },
      unorm16x2: { size: 2, stride: 4, normalised: true },
      unorm16x4: { size: 4, stride: 8, normalised: true },
      snorm16x2: { size: 2, stride: 4, normalised: true },
      snorm16x4: { size: 4, stride: 8, normalised: true },
      float16x2: { size: 2, stride: 4, normalised: false },
      float16x4: { size: 4, stride: 8, normalised: false },
      float32: { size: 1, stride: 4, normalised: false },
      float32x2: { size: 2, stride: 8, normalised: false },
      float32x3: { size: 3, stride: 12, normalised: false },
      float32x4: { size: 4, stride: 16, normalised: false },
      uint32: { size: 1, stride: 4, normalised: false },
      uint32x2: { size: 2, stride: 8, normalised: false },
      uint32x3: { size: 3, stride: 12, normalised: false },
      uint32x4: { size: 4, stride: 16, normalised: false },
      sint32: { size: 1, stride: 4, normalised: false },
      sint32x2: { size: 2, stride: 8, normalised: false },
      sint32x3: { size: 3, stride: 12, normalised: false },
      sint32x4: { size: 4, stride: 16, normalised: false }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
function extractAttributesFromGpuProgram({ source: source3, entryPoint }) {
  const results = {};
  const mainVertStart = source3.indexOf(`fn ${entryPoint}`);
  if (mainVertStart !== -1) {
    const arrowFunctionStart = source3.indexOf("->", mainVertStart);
    if (arrowFunctionStart !== -1) {
      const functionArgsSubstring = source3.substring(mainVertStart, arrowFunctionStart);
      const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let match;
      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
        results[match[2]] = {
          location: parseInt(match[1], 10),
          format,
          stride: getAttributeInfoFromFormat(format).stride,
          offset: 0,
          instance: false,
          start: 0
        };
      }
    }
  }
  return results;
}
var WGSL_TO_VERTEX_TYPES;
var init_extractAttributesFromGpuProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs"() {
    init_getAttributeInfoFromFormat();
    WGSL_TO_VERTEX_TYPES = {
      f32: "float32",
      "vec2<f32>": "float32x2",
      "vec3<f32>": "float32x3",
      "vec4<f32>": "float32x4",
      vec2f: "float32x2",
      vec3f: "float32x3",
      vec4f: "float32x4",
      i32: "sint32",
      "vec2<i32>": "sint32x2",
      "vec3<i32>": "sint32x3",
      "vec4<i32>": "sint32x4",
      u32: "uint32",
      "vec2<u32>": "uint32x2",
      "vec3<u32>": "uint32x3",
      "vec4<u32>": "uint32x4",
      bool: "uint32",
      "vec2<bool>": "uint32x2",
      "vec3<bool>": "uint32x3",
      "vec4<bool>": "uint32x4"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
function extractStructAndGroups(wgsl2) {
  const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl2.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl2.match(structPattern)?.map((struct) => {
    const name = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type] = member.split(":");
      acc[name2.trim()] = type.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name, members };
  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
  return {
    groups,
    structs
  };
}
var init_extractStructAndGroups = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
var ShaderStage;
var init_const5 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
    "use strict";
    ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
      ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
      ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
      ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
      return ShaderStage2;
    })(ShaderStage || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i2 = 0; i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}
var init_generateGpuLayoutGroups = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs"() {
    init_const5();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i2 = 0; i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}
var init_generateLayoutHash = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key)) {
      return false;
    }
    dupeGroupKeySet.add(key);
    return true;
  });
  return { structs, groups };
}
var init_removeStructAndGroupDuplicates = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
var programCache2, GpuProgram;
var init_GpuProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
    init_createIdFromString();
    init_extractAttributesFromGpuProgram();
    init_extractStructAndGroups();
    init_generateGpuLayoutGroups();
    init_generateLayoutHash();
    init_removeStructAndGroupDuplicates();
    programCache2 = /* @__PURE__ */ Object.create(null);
    GpuProgram = class _GpuProgram {
      /**
       * Create a new GpuProgram
       * @param options - The options for the gpu program
       */
      constructor(options) {
        this._layoutKey = 0;
        this._attributeLocationsKey = 0;
        const { fragment: fragment4, vertex: vertex4, layout, gpuLayout, name } = options;
        this.name = name;
        this.fragment = fragment4;
        this.vertex = vertex4;
        if (fragment4.source === vertex4.source) {
          const structsAndGroups = extractStructAndGroups(fragment4.source);
          this.structsAndGroups = structsAndGroups;
        } else {
          const vertexStructsAndGroups = extractStructAndGroups(vertex4.source);
          const fragmentStructsAndGroups = extractStructAndGroups(fragment4.source);
          this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
        }
        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
        this._generateProgramKey();
      }
      // TODO maker this pure
      _generateProgramKey() {
        const { vertex: vertex4, fragment: fragment4 } = this;
        const bigKey = vertex4.source + fragment4.source + vertex4.entryPoint + fragment4.entryPoint;
        this._layoutKey = createIdFromString(bigKey, "program");
      }
      get attributeData() {
        this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
        return this._attributeData;
      }
      /** destroys the program */
      destroy() {
        this.gpuLayout = null;
        this.layout = null;
        this.structsAndGroups = null;
        this.fragment = null;
        this.vertex = null;
        programCache2[this._cacheKey] = null;
      }
      /**
       * Helper function that creates a program for a given source.
       * It will check the program cache if the program has already been created.
       * If it has that one will be returned, if not a new one will be created and cached.
       * @param options - The options for the program.
       * @returns A program using the same source
       */
      static from(options) {
        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
        if (!programCache2[key]) {
          programCache2[key] = new _GpuProgram(options);
          programCache2[key]._cacheKey = key;
        }
        return programCache2[key];
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
function addBits(srcParts, parts, name) {
  if (srcParts) {
    for (const i2 in srcParts) {
      const id = i2.toLocaleLowerCase();
      const part = parts[id];
      if (part) {
        let sanitisedPart = srcParts[i2];
        if (i2 === "header") {
          sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
        }
        if (name) {
          part.push(`//----${name}----//`);
        }
        part.push(sanitisedPart);
      } else {
        warn(`${i2} placement hook does not exist in shader`);
      }
    }
  }
}
var init_addBits = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
    init_warn();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
function compileHooks(programSrc) {
  const parts = {};
  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
  partMatches.forEach((hook) => {
    parts[hook] = [];
  });
  return parts;
}
var findHooksRx;
var init_compileHooks = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
    "use strict";
    findHooksRx = /\{\{(.*?)\}\}/g;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
function extractInputs(fragmentSource, out2) {
  let match;
  const regex = /@in\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function compileInputs(fragments, template, sort = false) {
  const results = [];
  extractInputs(template, results);
  fragments.forEach((fragment4) => {
    if (fragment4.header) {
      extractInputs(fragment4.header, results);
    }
  });
  const mainInput = results;
  if (sort) {
    mainInput.sort();
  }
  const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join("\n");
  let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
  cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
  return cleanedString;
}
var init_compileInputs = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
function extractOutputs(fragmentSource, out2) {
  let match;
  const regex = /@out\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function extractVariableName(value) {
  const regex = /\b(\w+)\s*:/g;
  const match = regex.exec(value);
  return match ? match[1] : "";
}
function stripVariable(value) {
  const regex = /@.*?\s+/g;
  return value.replace(regex, "");
}
function compileOutputs(fragments, template) {
  const results = [];
  extractOutputs(template, results);
  fragments.forEach((fragment4) => {
    if (fragment4.header) {
      extractOutputs(fragment4.header, results);
    }
  });
  let index = 0;
  const mainStruct = results.sort().map((inValue) => {
    if (inValue.indexOf("builtin") > -1) {
      return inValue;
    }
    return `@location(${index++}) ${inValue}`;
  }).join(",\n");
  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
  const mainEnd = `return VSOutput(
            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
  let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
  compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
  compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
  compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
  return compiledCode;
}
var init_compileOutputs = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
function injectBits(templateSrc, fragmentParts) {
  let out2 = templateSrc;
  for (const i2 in fragmentParts) {
    const parts = fragmentParts[i2];
    const toInject = parts.join("\n");
    if (toInject.length) {
      out2 = out2.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join("\n")}
//----${i2} FINISH----//`);
    } else {
      out2 = out2.replace(`{{${i2}}}`, "");
    }
  }
  return out2;
}
var init_injectBits = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
function compileHighShader({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  const { vertex: vertex4, fragment: fragment4 } = compileInputsAndOutputs(template, bits);
  cacheMap[cacheId] = compileBits(vertex4, fragment4, bits);
  return cacheMap[cacheId];
}
function compileHighShaderGl({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
  return cacheMap[cacheId];
}
function compileInputsAndOutputs(template, bits) {
  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
  compiledVertex = compileOutputs(vertexFragments, compiledVertex);
  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
  return {
    vertex: compiledVertex,
    fragment: compiledFragment
  };
}
function generateCacheId(template, bits) {
  return bits.map((highFragment) => {
    if (!bitCacheMap.has(highFragment)) {
      bitCacheMap.set(highFragment, CACHE_UID++);
    }
    return bitCacheMap.get(highFragment);
  }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
}
function compileBits(vertex4, fragment4, bits) {
  const vertexParts = compileHooks(vertex4);
  const fragmentParts = compileHooks(fragment4);
  bits.forEach((shaderBit) => {
    addBits(shaderBit.vertex, vertexParts, shaderBit.name);
    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
  });
  return {
    vertex: injectBits(vertex4, vertexParts),
    fragment: injectBits(fragment4, fragmentParts)
  };
}
var cacheMap, bitCacheMap, CACHE_UID;
var init_compileHighShader = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
    init_addBits();
    init_compileHooks();
    init_compileInputs();
    init_compileOutputs();
    init_injectBits();
    cacheMap = /* @__PURE__ */ Object.create(null);
    bitCacheMap = /* @__PURE__ */ new Map();
    CACHE_UID = 0;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
var init_defaultProgramTemplate = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
    "use strict";
    vertexGPUTemplate = /* wgsl */
    `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`;
    fragmentGPUTemplate = /* wgsl */
    `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`;
    vertexGlTemplate = /* glsl */
    `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`;
    fragmentGlTemplate = /* glsl */
    `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
var globalUniformsBit, globalUniformsBitGl;
var init_globalUniformsBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
    "use strict";
    globalUniformsBit = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* wgsl */
          `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        )
      }
    };
    globalUniformsBitGl = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* glsl */
          `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
function compileHighShaderGpuProgram({ bits, name }) {
  const source3 = compileHighShader({
    template: {
      fragment: fragmentGPUTemplate,
      vertex: vertexGPUTemplate
    },
    bits: [
      globalUniformsBit,
      ...bits
    ]
  });
  return GpuProgram.from({
    name,
    vertex: {
      source: source3.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: source3.fragment,
      entryPoint: "main"
    }
  });
}
function compileHighShaderGlProgram({ bits, name }) {
  return new GlProgram({
    name,
    ...compileHighShaderGl({
      template: {
        vertex: vertexGlTemplate,
        fragment: fragmentGlTemplate
      },
      bits: [
        globalUniformsBitGl,
        ...bits
      ]
    })
  });
}
var init_compileHighShaderToProgram = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_compileHighShader();
    init_defaultProgramTemplate();
    init_globalUniformsBit();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
var colorBit, colorBitGl;
var init_colorBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
    "use strict";
    colorBit = {
      name: "color-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            @in aColor: vec4<f32>;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
    colorBitGl = {
      name: "color-bit",
      vertex: {
        header: (
          /* glsl */
          `
            in vec4 aColor;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
function generateBindingSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i2 = 0; i2 < maxTextures; i2++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
    }
  }
  return src.join("\n");
}
function generateSampleSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  } else {
    src.push("switch vTextureId {");
    for (let i2 = 0; i2 < maxTextures; i2++) {
      if (i2 === maxTextures - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i2}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join("\n");
}
function generateTextureBatchBit(maxTextures) {
  if (!textureBatchBitGpuCache[maxTextures]) {
    textureBatchBitGpuCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGpuCache[maxTextures];
}
function generateSampleGlSrc(maxTextures) {
  const src = [];
  for (let i2 = 0; i2 < maxTextures; i2++) {
    if (i2 > 0) {
      src.push("else");
    }
    if (i2 < maxTextures - 1) {
      src.push(`if(vTextureId < ${i2}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uTextures[${i2}], vUV);`);
    src.push("}");
  }
  return src.join("\n");
}
function generateTextureBatchBitGl(maxTextures) {
  if (!textureBatchBitGlCache[maxTextures]) {
    textureBatchBitGlCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures}];

            `,
        main: `

                ${generateSampleGlSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGlCache[maxTextures];
}
var textureBatchBitGpuCache, textureBatchBitGlCache;
var init_generateTextureBatchBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
    "use strict";
    textureBatchBitGpuCache = {};
    textureBatchBitGlCache = {};
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
var roundPixelsBit, roundPixelsBitGl;
var init_roundPixelsBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
    "use strict";
    roundPixelsBit = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
    roundPixelsBitGl = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* glsl */
          `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs
var UNIFORM_TYPES_VALUES, UNIFORM_TYPES_MAP;
var init_types = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs"() {
    "use strict";
    UNIFORM_TYPES_VALUES = [
      "f32",
      "i32",
      "vec2<f32>",
      "vec3<f32>",
      "vec4<f32>",
      "mat2x2<f32>",
      "mat3x3<f32>",
      "mat4x4<f32>",
      "mat3x2<f32>",
      "mat4x2<f32>",
      "mat2x3<f32>",
      "mat4x3<f32>",
      "mat2x4<f32>",
      "mat3x4<f32>",
      "vec2<i32>",
      "vec3<i32>",
      "vec4<i32>"
    ];
    UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
      acc[type] = true;
      return acc;
    }, {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
function getDefaultUniformValue(type, size) {
  switch (type) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size);
    case "vec3<f32>":
      return new Float32Array(3 * size);
    case "vec4<f32>":
      return new Float32Array(4 * size);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_getDefaultUniformValue = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
var _UniformGroup, UniformGroup;
var init_UniformGroup = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
    init_uid();
    init_createIdFromString();
    init_types();
    init_getDefaultUniformValue();
    _UniformGroup = class _UniformGroup2 {
      /**
       * Create a new Uniform group
       * @param uniformStructures - The structures of the uniform group
       * @param options - The optional parameters of this uniform group
       */
      constructor(uniformStructures, options) {
        this._touched = 0;
        this.uid = uid("uniform");
        this._resourceType = "uniformGroup";
        this._resourceId = uid("resource");
        this.isUniformGroup = true;
        this._dirtyId = 0;
        this.destroyed = false;
        options = { ..._UniformGroup2.defaultOptions, ...options };
        this.uniformStructures = uniformStructures;
        const uniforms = {};
        for (const i2 in uniformStructures) {
          const uniformData = uniformStructures[i2];
          uniformData.name = i2;
          uniformData.size = uniformData.size ?? 1;
          if (!UNIFORM_TYPES_MAP[uniformData.type]) {
            const arrayMatch = uniformData.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
            if (arrayMatch) {
              const [, innerType, size] = arrayMatch;
              throw new Error(
                `Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size} instead.`
              );
            }
            throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
          }
          uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
          uniforms[i2] = uniformData.value;
        }
        this.uniforms = uniforms;
        this._dirtyId = 1;
        this.ubo = options.ubo;
        this.isStatic = options.isStatic;
        this._signature = createIdFromString(Object.keys(uniforms).map(
          (i2) => `${i2}-${uniformStructures[i2].type}`
        ).join("-"), "uniform-group");
      }
      /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
      update() {
        this._dirtyId++;
      }
    };
    _UniformGroup.defaultOptions = {
      /** if true the UniformGroup is handled as an Uniform buffer object. */
      ubo: false,
      /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
      isStatic: false
    };
    UniformGroup = _UniformGroup;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs
function getBatchSamplersUniformGroup(maxTextures) {
  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];
  if (batchSamplersUniformGroup)
    return batchSamplersUniformGroup;
  const sampleValues = new Int32Array(maxTextures);
  for (let i2 = 0; i2 < maxTextures; i2++) {
    sampleValues[i2] = i2;
  }
  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({
    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }
  }, { isStatic: true });
  return batchSamplersUniformGroup;
}
var batchSamplersUniformGroupHash;
var init_getBatchSamplersUniformGroup = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs"() {
    init_UniformGroup();
    batchSamplersUniformGroupHash = {};
  }
});

// node_modules/pixi.js/lib/rendering/renderers/types.mjs
var RendererType;
var init_types2 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
    "use strict";
    RendererType = /* @__PURE__ */ ((RendererType2) => {
      RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
      RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
      RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
      return RendererType2;
    })(RendererType || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
var Shader;
var init_Shader = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
    init_eventemitter3();
    init_uid();
    init_GlProgram();
    init_BindGroup();
    init_GpuProgram();
    init_types2();
    init_UniformGroup();
    Shader = class _Shader extends eventemitter3_default {
      constructor(options) {
        super();
        this.uid = uid("shader");
        this._uniformBindMap = /* @__PURE__ */ Object.create(null);
        this._ownedBindGroups = [];
        let {
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          groups,
          resources,
          compatibleRenderers,
          groupMap
        } = options;
        this.gpuProgram = gpuProgram3;
        this.glProgram = glProgram3;
        if (compatibleRenderers === void 0) {
          compatibleRenderers = 0;
          if (gpuProgram3)
            compatibleRenderers |= RendererType.WEBGPU;
          if (glProgram3)
            compatibleRenderers |= RendererType.WEBGL;
        }
        this.compatibleRenderers = compatibleRenderers;
        const nameHash = {};
        if (!resources && !groups) {
          resources = {};
        }
        if (resources && groups) {
          throw new Error("[Shader] Cannot have both resources and groups");
        } else if (!gpuProgram3 && groups && !groupMap) {
          throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        } else if (!gpuProgram3 && groups && groupMap) {
          for (const i2 in groupMap) {
            for (const j2 in groupMap[i2]) {
              const uniformName = groupMap[i2][j2];
              nameHash[uniformName] = {
                group: i2,
                binding: j2,
                name: uniformName
              };
            }
          }
        } else if (gpuProgram3 && groups && !groupMap) {
          const groupData = gpuProgram3.structsAndGroups.groups;
          groupMap = {};
          groupData.forEach((data) => {
            groupMap[data.group] = groupMap[data.group] || {};
            groupMap[data.group][data.binding] = data.name;
            nameHash[data.name] = data;
          });
        } else if (resources) {
          groups = {};
          groupMap = {};
          if (gpuProgram3) {
            const groupData = gpuProgram3.structsAndGroups.groups;
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          }
          let bindTick = 0;
          for (const i2 in resources) {
            if (nameHash[i2])
              continue;
            if (!groups[99]) {
              groups[99] = new BindGroup();
              this._ownedBindGroups.push(groups[99]);
            }
            nameHash[i2] = { group: 99, binding: bindTick, name: i2 };
            groupMap[99] = groupMap[99] || {};
            groupMap[99][bindTick] = i2;
            bindTick++;
          }
          for (const i2 in resources) {
            const name = i2;
            let value = resources[i2];
            if (!value.source && !value._resourceType) {
              value = new UniformGroup(value);
            }
            const data = nameHash[name];
            if (data) {
              if (!groups[data.group]) {
                groups[data.group] = new BindGroup();
                this._ownedBindGroups.push(groups[data.group]);
              }
              groups[data.group].setResource(value, data.binding);
            }
          }
        }
        this.groups = groups;
        this._uniformBindMap = groupMap;
        this.resources = this._buildResourceAccessor(groups, nameHash);
      }
      /**
       * Sometimes a resource group will be provided later (for example global uniforms)
       * In such cases, this method can be used to let the shader know about the group.
       * @param name - the name of the resource group
       * @param groupIndex - the index of the group (should match the webGPU shader group location)
       * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
       */
      addResource(name, groupIndex, bindIndex) {
        var _a, _b;
        (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
        (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
        if (!this.groups[groupIndex]) {
          this.groups[groupIndex] = new BindGroup();
          this._ownedBindGroups.push(this.groups[groupIndex]);
        }
      }
      _buildResourceAccessor(groups, nameHash) {
        const uniformsOut = {};
        for (const i2 in nameHash) {
          const data = nameHash[i2];
          Object.defineProperty(uniformsOut, data.name, {
            get() {
              return groups[data.group].getResource(data.binding);
            },
            set(value) {
              groups[data.group].setResource(value, data.binding);
            }
          });
        }
        return uniformsOut;
      }
      /**
       * Use to destroy the shader when its not longer needed.
       * It will destroy the resources and remove listeners.
       * @param destroyPrograms - if the programs should be destroyed as well.
       * Make sure its not being used by other shaders!
       */
      destroy(destroyPrograms = false) {
        this.emit("destroy", this);
        if (destroyPrograms) {
          this.gpuProgram?.destroy();
          this.glProgram?.destroy();
        }
        this.gpuProgram = null;
        this.glProgram = null;
        this.removeAllListeners();
        this._uniformBindMap = null;
        this._ownedBindGroups.forEach((bindGroup) => {
          bindGroup.destroy();
        });
        this._ownedBindGroups = null;
        this.resources = null;
        this.groups = null;
      }
      static from(options) {
        const { gpu, gl, ...rest } = options;
        let gpuProgram3;
        let glProgram3;
        if (gpu) {
          gpuProgram3 = GpuProgram.from(gpu);
        }
        if (gl) {
          glProgram3 = GlProgram.from(gl);
        }
        return new _Shader({
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          ...rest
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs
var DefaultShader;
var init_DefaultShader = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs"() {
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_getBatchSamplersUniformGroup();
    init_Shader();
    DefaultShader = class extends Shader {
      constructor(maxTextures) {
        const glProgram3 = compileHighShaderGlProgram({
          name: "batch",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(maxTextures),
            roundPixelsBitGl
          ]
        });
        const gpuProgram3 = compileHighShaderGpuProgram({
          name: "batch",
          bits: [
            colorBit,
            generateTextureBatchBit(maxTextures),
            roundPixelsBit
          ]
        });
        super({
          glProgram: glProgram3,
          gpuProgram: gpuProgram3,
          resources: {
            batchSamplers: getBatchSamplersUniformGroup(maxTextures)
          }
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs
var defaultShader, _DefaultBatcher, DefaultBatcher;
var init_DefaultBatcher = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs"() {
    init_Extensions();
    init_Batcher();
    init_BatchGeometry();
    init_DefaultShader();
    defaultShader = null;
    _DefaultBatcher = class _DefaultBatcher2 extends Batcher {
      constructor(options) {
        super(options);
        this.geometry = new BatchGeometry();
        this.name = _DefaultBatcher2.extension.name;
        this.vertexSize = 6;
        defaultShader ?? (defaultShader = new DefaultShader(options.maxTextures));
        this.shader = defaultShader;
      }
      /**
       * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
       * @param element - The DefaultBatchableMeshElement to pack.
       * @param float32View - The Float32Array view to pack into.
       * @param uint32View - The Uint32Array view to pack into.
       * @param index - The starting index in the views.
       * @param textureId - The texture ID to use.
       */
      packAttributes(element, float32View, uint32View, index, textureId) {
        const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
        const wt = element.transform;
        const a2 = wt.a;
        const b2 = wt.b;
        const c2 = wt.c;
        const d2 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const { positions, uvs } = element;
        const argb = element.color;
        const offset = element.attributeOffset;
        const end = offset + element.attributeSize;
        for (let i2 = offset; i2 < end; i2++) {
          const i22 = i2 * 2;
          const x2 = positions[i22];
          const y2 = positions[i22 + 1];
          float32View[index++] = a2 * x2 + c2 * y2 + tx;
          float32View[index++] = d2 * y2 + b2 * x2 + ty;
          float32View[index++] = uvs[i22];
          float32View[index++] = uvs[i22 + 1];
          uint32View[index++] = argb;
          uint32View[index++] = textureIdAndRound;
        }
      }
      /**
       * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
       * @param element - The DefaultBatchableQuadElement to pack.
       * @param float32View - The Float32Array view to pack into.
       * @param uint32View - The Uint32Array view to pack into.
       * @param index - The starting index in the views.
       * @param textureId - The texture ID to use.
       */
      packQuadAttributes(element, float32View, uint32View, index, textureId) {
        const texture = element.texture;
        const wt = element.transform;
        const a2 = wt.a;
        const b2 = wt.b;
        const c2 = wt.c;
        const d2 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const bounds = element.bounds;
        const w0 = bounds.maxX;
        const w1 = bounds.minX;
        const h0 = bounds.maxY;
        const h1 = bounds.minY;
        const uvs = texture.uvs;
        const argb = element.color;
        const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
        float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
        float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
        float32View[index + 2] = uvs.x0;
        float32View[index + 3] = uvs.y0;
        uint32View[index + 4] = argb;
        uint32View[index + 5] = textureIdAndRound;
        float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
        float32View[index + 7] = d2 * h1 + b2 * w0 + ty;
        float32View[index + 8] = uvs.x1;
        float32View[index + 9] = uvs.y1;
        uint32View[index + 10] = argb;
        uint32View[index + 11] = textureIdAndRound;
        float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
        float32View[index + 13] = d2 * h0 + b2 * w0 + ty;
        float32View[index + 14] = uvs.x2;
        float32View[index + 15] = uvs.y2;
        uint32View[index + 16] = argb;
        uint32View[index + 17] = textureIdAndRound;
        float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
        float32View[index + 19] = d2 * h0 + b2 * w1 + ty;
        float32View[index + 20] = uvs.x3;
        float32View[index + 21] = uvs.y3;
        uint32View[index + 22] = argb;
        uint32View[index + 23] = textureIdAndRound;
      }
    };
    _DefaultBatcher.extension = {
      type: [
        ExtensionType.Batcher
      ],
      name: "default"
    };
    DefaultBatcher = _DefaultBatcher;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
  let index = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index < size) {
    const x2 = vertices[verticesOffset];
    const y2 = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
    uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
  let index = 0;
  uvsOffset *= uvsStride;
  while (index < size) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index++;
  }
}
var init_buildUvs = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
function transformVertices(vertices, m2, offset, stride, size) {
  const a2 = m2.a;
  const b2 = m2.b;
  const c2 = m2.c;
  const d2 = m2.d;
  const tx = m2.tx;
  const ty = m2.ty;
  offset || (offset = 0);
  stride || (stride = 2);
  size || (size = vertices.length / stride - offset);
  let index = offset * stride;
  for (let i2 = 0; i2 < size; i2++) {
    const x2 = vertices[index];
    const y2 = vertices[index + 1];
    vertices[index] = a2 * x2 + c2 * y2 + tx;
    vertices[index + 1] = b2 * x2 + d2 * y2 + ty;
    index += stride;
  }
}
var init_transformVertices = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
var identityMatrix2, BatchableGraphics;
var init_BatchableGraphics = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
    init_Matrix();
    init_multiplyHexColors();
    identityMatrix2 = new Matrix();
    BatchableGraphics = class {
      constructor() {
        this.packAsQuad = false;
        this.batcherName = "default";
        this.topology = "triangle-list";
        this.applyTransform = true;
        this.roundPixels = 0;
        this._batcher = null;
        this._batch = null;
      }
      get uvs() {
        return this.geometryData.uvs;
      }
      get positions() {
        return this.geometryData.vertices;
      }
      get indices() {
        return this.geometryData.indices;
      }
      get blendMode() {
        if (this.renderable && this.applyTransform) {
          return this.renderable.groupBlendMode;
        }
        return "normal";
      }
      get color() {
        const rgb = this.baseColor;
        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
        const renderable = this.renderable;
        if (renderable) {
          return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
        }
        return bgr + (this.alpha * 255 << 24);
      }
      get transform() {
        return this.renderable?.groupTransform || identityMatrix2;
      }
      copyTo(gpuBuffer) {
        gpuBuffer.indexOffset = this.indexOffset;
        gpuBuffer.indexSize = this.indexSize;
        gpuBuffer.attributeOffset = this.attributeOffset;
        gpuBuffer.attributeSize = this.attributeSize;
        gpuBuffer.baseColor = this.baseColor;
        gpuBuffer.alpha = this.alpha;
        gpuBuffer.texture = this.texture;
        gpuBuffer.geometryData = this.geometryData;
        gpuBuffer.topology = this.topology;
      }
      reset() {
        this.applyTransform = true;
        this.renderable = null;
        this.topology = "triangle-list";
      }
      destroy() {
        this.renderable = null;
        this.texture = null;
        this.geometryData = null;
        this._batcher = null;
        this._batch = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
var buildCircle, buildEllipse, buildRoundedRectangle;
var init_buildCircle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
    init_Extensions();
    buildCircle = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "circle"
      },
      build(shape, points) {
        let x2;
        let y2;
        let dx;
        let dy;
        let rx;
        let ry;
        if (shape.type === "circle") {
          const circle = shape;
          rx = ry = circle.radius;
          if (rx <= 0) {
            return false;
          }
          x2 = circle.x;
          y2 = circle.y;
          dx = dy = 0;
        } else if (shape.type === "ellipse") {
          const ellipse = shape;
          rx = ellipse.halfWidth;
          ry = ellipse.halfHeight;
          if (rx <= 0 || ry <= 0) {
            return false;
          }
          x2 = ellipse.x;
          y2 = ellipse.y;
          dx = dy = 0;
        } else {
          const roundedRect = shape;
          const halfWidth = roundedRect.width / 2;
          const halfHeight = roundedRect.height / 2;
          x2 = roundedRect.x + halfWidth;
          y2 = roundedRect.y + halfHeight;
          rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
          dx = halfWidth - rx;
          dy = halfHeight - ry;
        }
        if (dx < 0 || dy < 0) {
          return false;
        }
        const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
        const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
        if (m2 === 0) {
          return false;
        }
        if (n2 === 0) {
          points[0] = points[6] = x2 + dx;
          points[1] = points[3] = y2 + dy;
          points[2] = points[4] = x2 - dx;
          points[5] = points[7] = y2 - dy;
          return true;
        }
        let j1 = 0;
        let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
        let j3 = j2;
        let j4 = m2;
        let x0 = dx + rx;
        let y0 = dy;
        let x1 = x2 + x0;
        let x22 = x2 - x0;
        let y1 = y2 + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x22;
        if (dy) {
          const y222 = y2 - y0;
          points[j3++] = x22;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x1;
        }
        for (let i2 = 1; i2 < n2; i2++) {
          const a2 = Math.PI / 2 * (i2 / n2);
          const x02 = dx + Math.cos(a2) * rx;
          const y02 = dy + Math.sin(a2) * ry;
          const x12 = x2 + x02;
          const x222 = x2 - x02;
          const y12 = y2 + y02;
          const y222 = y2 - y02;
          points[j1++] = x12;
          points[j1++] = y12;
          points[--j2] = y12;
          points[--j2] = x222;
          points[j3++] = x222;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x12;
        }
        x0 = dx;
        y0 = dy + ry;
        x1 = x2 + x0;
        x22 = x2 - x0;
        y1 = y2 + y0;
        const y22 = y2 - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x1;
        if (dx) {
          points[j1++] = x22;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x22;
        }
        return true;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        if (points.length === 0) {
          return;
        }
        let centerX = 0;
        let centerY = 0;
        for (let i2 = 0; i2 < points.length; i2 += 2) {
          centerX += points[i2];
          centerY += points[i2 + 1];
        }
        centerX /= points.length / 2;
        centerY /= points.length / 2;
        let count2 = verticesOffset;
        vertices[count2 * verticesStride] = centerX;
        vertices[count2 * verticesStride + 1] = centerY;
        const centerIndex = count2++;
        for (let i2 = 0; i2 < points.length; i2 += 2) {
          vertices[count2 * verticesStride] = points[i2];
          vertices[count2 * verticesStride + 1] = points[i2 + 1];
          if (i2 > 0) {
            indices[indicesOffset++] = count2;
            indices[indicesOffset++] = centerIndex;
            indices[indicesOffset++] = count2 - 1;
          }
          count2++;
        }
        indices[indicesOffset++] = centerIndex + 1;
        indices[indicesOffset++] = centerIndex;
        indices[indicesOffset++] = count2 - 1;
      }
    };
    buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };
    buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
var closePointEps, curveEps;
var init_const6 = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/const.mjs"() {
    "use strict";
    closePointEps = 1e-4;
    curveEps = 1e-4;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
function getOrientationOfPoints(points) {
  const m2 = points.length;
  if (m2 < 6) {
    return 1;
  }
  let area2 = 0;
  for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
    const x2 = points[i2];
    const y2 = points[i2 + 1];
    area2 += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (area2 < 0) {
    return -1;
  }
  return 1;
}
var init_getOrientationOfPoints = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x2 - nx * innerWeight;
  const iy = y2 - ny * innerWeight;
  const ox = x2 + nx * outerWeight;
  const oy = y2 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = getOrientationOfPoints(points);
    if (flipAlignment)
      orientation *= -1;
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x0 - perpX * (innerWeight - outerWeight) * 0.5,
        y0 - perpY * (innerWeight - outerWeight) * 0.5,
        x0 - perpX * innerWeight,
        y0 - perpY * innerWeight,
        x0 + perpX * outerWeight,
        y0 + perpY * outerWeight,
        verts,
        true
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(
    x0 - perpX * innerWeight,
    y0 - perpY * innerWeight
  );
  verts.push(
    x0 + perpX * outerWeight,
    y0 + perpY * outerWeight
  );
  for (let i2 = 1; i2 < length - 1; ++i2) {
    x0 = points[(i2 - 1) * 2];
    y0 = points[(i2 - 1) * 2 + 1];
    x1 = points[i2 * 2];
    y1 = points[i2 * 2 + 1];
    x2 = points[(i2 + 1) * 2];
    y2 = points[(i2 + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight
      );
      verts.push(
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight
      );
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight
        );
        verts.push(
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        );
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2;
        } else {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x1 - perpX * (innerWeight - outerWeight) * 0.5,
        y1 - perpY * (innerWeight - outerWeight) * 0.5,
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight,
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight,
        verts,
        false
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = curveEps * curveEps;
  for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
    x0 = verts[i2 * 2];
    y0 = verts[i2 * 2 + 1];
    x1 = verts[(i2 + 1) * 2];
    y1 = verts[(i2 + 1) * 2 + 1];
    x2 = verts[(i2 + 2) * 2];
    y2 = verts[(i2 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i2, i2 + 1, i2 + 2);
  }
}
var init_buildLine = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
    init_Point();
    init_const6();
    init_getOrientationOfPoints();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs
function buildPixelLine(points, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const fx = points[0];
  const fy = points[1];
  const lx = points[points.length - 2];
  const ly = points[points.length - 1];
  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;
  const verts = vertices;
  const length = points.length / 2;
  const indexStart = verts.length / 2;
  for (let i2 = 0; i2 < length; i2++) {
    verts.push(points[i2 * 2]);
    verts.push(points[i2 * 2 + 1]);
  }
  for (let i2 = 0; i2 < length - 1; i2++) {
    indices.push(indexStart + i2, indexStart + i2 + 1);
  }
  if (closePath) {
    indices.push(indexStart + length - 1, indexStart);
  }
}
var init_buildPixelLine = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs"() {
    init_const6();
  }
});

// node_modules/earcut/src/earcut.js
function earcut(data, holeIndices, dim = 2) {
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  let outerNode = linkedList(data, 0, outerLen, dim, true);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  let minX, minY, invSize;
  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = data[0];
    minY = data[1];
    let maxX = minX;
    let maxY = minY;
    for (let i2 = dim; i2 < outerLen; i2 += dim) {
      const x2 = data[i2];
      const y2 = data[i2 + 1];
      if (x2 < minX) minX = x2;
      if (y2 < minY) minY = y2;
      if (x2 > maxX) maxX = x2;
      if (y2 > maxY) maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  let last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (let i2 = start; i2 < end; i2 += dim) last = insertNode(i2 / dim | 0, data[i2], data[i2 + 1], last);
  } else {
    for (let i2 = end - dim; i2 >= start; i2 -= dim) last = insertNode(i2 / dim | 0, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next) break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  while (ear.prev !== ear.next) {
    const prev = ear.prev;
    const next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i, ear.i, next.i);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
  let p2 = c2.next;
  while (p2 !== a2) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles) {
  let p2 = start;
  do {
    const a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i, p2.i, b2.i);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        let c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  for (let i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    const start = holeIndices[i2] * dim;
    const end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    const list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareXYSlope);
  for (let i2 = 0; i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
  }
  return outerNode;
}
function compareXYSlope(a2, b2) {
  let result = a2.x - b2.x;
  if (result === 0) {
    result = a2.y - b2.y;
    if (result === 0) {
      const aSlope = (a2.next.y - a2.y) / (a2.next.x - a2.x);
      const bSlope = (b2.next.y - b2.y) / (b2.next.x - b2.x);
      result = aSlope - bSlope;
    }
  }
  return result;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m2;
  if (equals(hole, p2)) return p2;
  do {
    if (equals(hole, p2.next)) return p2.next;
    else if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m2 = p2.x < p2.next.x ? p2 : p2.next;
        if (x2 === hx) return m2;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2) return null;
  const stop = m2;
  const mx = m2.x;
  const my = m2.y;
  let tanMin = Infinity;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      const tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let numMerges;
  let inSize = 1;
  do {
    let p2 = list;
    let e2;
    list = null;
    let tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      let q = p2;
      let pSize = 0;
      for (let i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      let qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e2;
        else list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = (x2 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
  return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // doesn't intersect other edges
  (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
  (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
  equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q, r2) {
  return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p2, q, r2) {
  return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  let p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2)) return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  let p2 = a2;
  let inside = false;
  const px = (a2.x + b2.x) / 2;
  const py = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  const a22 = createNode(a2.i, a2.x, a2.y), b22 = createNode(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last) {
  const p2 = createNode(i2, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
}
function createNode(i2, x2, y2) {
  return {
    i: i2,
    // vertex index in coordinates array
    x: x2,
    y: y2,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: false
    // indicates whether this is a steiner point
  };
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
var init_earcut = __esm({
  "node_modules/earcut/src/earcut.js"() {
  }
});

// node_modules/pixi.js/lib/utils/utils.mjs
var earcut2;
var init_utils = __esm({
  "node_modules/pixi.js/lib/utils/utils.mjs"() {
    init_earcut();
    init_eventemitter3();
    earcut2 = earcut.default || earcut;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = earcut2(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i2 = 0; i2 < triangles.length; i2 += 3) {
    indices[indicesOffset++] = triangles[i2] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
  }
  let index = verticesOffset * verticesStride;
  for (let i2 = 0; i2 < points.length; i2 += 2) {
    vertices[index] = points[i2];
    vertices[index + 1] = points[i2 + 1];
    index += verticesStride;
  }
}
var init_triangulateWithHoles = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
    init_utils();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
var emptyArray, buildPolygon;
var init_buildPolygon = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
    init_Extensions();
    init_triangulateWithHoles();
    emptyArray = [];
    buildPolygon = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "polygon"
      },
      build(shape, points) {
        for (let i2 = 0; i2 < shape.points.length; i2++) {
          points[i2] = shape.points[i2];
        }
        return true;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
var buildRectangle;
var init_buildRectangle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
    init_Extensions();
    buildRectangle = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "rectangle"
      },
      build(shape, points) {
        const rectData = shape;
        const x2 = rectData.x;
        const y2 = rectData.y;
        const width = rectData.width;
        const height = rectData.height;
        if (!(width > 0 && height > 0)) {
          return false;
        }
        points[0] = x2;
        points[1] = y2;
        points[2] = x2 + width;
        points[3] = y2;
        points[4] = x2 + width;
        points[5] = y2 + height;
        points[6] = x2;
        points[7] = y2 + height;
        return true;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[6];
        vertices[verticesOffset + count2 + 1] = points[7];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        count2 += verticesStride;
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 3;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
var buildTriangle;
var init_buildTriangle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
    init_Extensions();
    buildTriangle = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "triangle"
      },
      build(shape, points) {
        points[0] = shape.x;
        points[1] = shape.y;
        points[2] = shape.x2;
        points[3] = shape.y2;
        points[4] = shape.x3;
        points[5] = shape.y3;
        return true;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
function addColorStops(gradient, colorStops) {
  for (let i2 = 0; i2 < colorStops.length; i2++) {
    const stop = colorStops[i2];
    gradient.addColorStop(stop.offset, stop.color);
  }
}
function getCanvas(width, height) {
  const canvas = DOMAdapter.get().createCanvas(width, height);
  const context2 = canvas.getContext("2d");
  return { canvas, context: context2 };
}
function ensureGradientOptions(args) {
  let options = args[0] ?? {};
  if (typeof options === "number" || args[1]) {
    deprecation("8.5.2", `use options object instead`);
    options = {
      type: "linear",
      start: { x: args[0], y: args[1] },
      end: { x: args[2], y: args[3] },
      textureSpace: args[4],
      textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize
    };
  }
  return options;
}
var emptyColorStops, _FillGradient, FillGradient;
var init_FillGradient = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
    init_Color();
    init_adapter();
    init_Matrix();
    init_ImageSource();
    init_Texture();
    init_uid();
    init_deprecation();
    init_definedProps();
    emptyColorStops = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }];
    _FillGradient = class _FillGradient2 {
      constructor(...args) {
        this.uid = uid("fillGradient");
        this._tick = 0;
        this.type = "linear";
        this.colorStops = [];
        let options = ensureGradientOptions(args);
        const defaults = options.type === "radial" ? _FillGradient2.defaultRadialOptions : _FillGradient2.defaultLinearOptions;
        options = { ...defaults, ...definedProps(options) };
        this._textureSize = options.textureSize;
        this._wrapMode = options.wrapMode;
        if (options.type === "radial") {
          this.center = options.center;
          this.outerCenter = options.outerCenter ?? this.center;
          this.innerRadius = options.innerRadius;
          this.outerRadius = options.outerRadius;
          this.scale = options.scale;
          this.rotation = options.rotation;
        } else {
          this.start = options.start;
          this.end = options.end;
        }
        this.textureSpace = options.textureSpace;
        this.type = options.type;
        options.colorStops.forEach((stop) => {
          this.addColorStop(stop.offset, stop.color);
        });
      }
      /**
       * Adds a color stop to the gradient
       * @param offset - Position of the stop (0-1)
       * @param color - Color of the stop
       * @returns This gradient instance for chaining
       */
      addColorStop(offset, color) {
        this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });
        return this;
      }
      /**
       * Builds the internal texture and transform for the gradient.
       * Called automatically when the gradient is first used.
       * @internal
       */
      buildLinearGradient() {
        if (this.texture)
          return;
        let { x: x0, y: y0 } = this.start;
        let { x: x1, y: y1 } = this.end;
        let dx = x1 - x0;
        let dy = y1 - y0;
        const flip = dx < 0 || dy < 0;
        if (this._wrapMode === "clamp-to-edge") {
          if (dx < 0) {
            const temp = x0;
            x0 = x1;
            x1 = temp;
            dx *= -1;
          }
          if (dy < 0) {
            const temp = y0;
            y0 = y1;
            y1 = temp;
            dy *= -1;
          }
        }
        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
        const defaultSize = this._textureSize;
        const { canvas, context: context2 } = getCanvas(defaultSize, 1);
        const gradient = !flip ? context2.createLinearGradient(0, 0, this._textureSize, 0) : context2.createLinearGradient(this._textureSize, 0, 0, 0);
        addColorStops(gradient, colorStops);
        context2.fillStyle = gradient;
        context2.fillRect(0, 0, defaultSize, 1);
        this.texture = new Texture({
          source: new ImageSource({
            resource: canvas,
            addressMode: this._wrapMode
          })
        });
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const m2 = new Matrix();
        m2.scale(dist / defaultSize, 1);
        m2.rotate(angle);
        m2.translate(x0, y0);
        if (this.textureSpace === "local") {
          m2.scale(defaultSize, defaultSize);
        }
        this.transform = m2;
      }
      /**
       * Builds the internal texture and transform for the gradient.
       * Called automatically when the gradient is first used.
       * @internal
       */
      buildGradient() {
        if (!this.texture)
          this._tick++;
        if (this.type === "linear") {
          this.buildLinearGradient();
        } else {
          this.buildRadialGradient();
        }
      }
      /**
       * Builds the internal texture and transform for the radial gradient.
       * Called automatically when the gradient is first used.
       * @internal
       */
      buildRadialGradient() {
        if (this.texture)
          return;
        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
        const defaultSize = this._textureSize;
        const { canvas, context: context2 } = getCanvas(defaultSize, defaultSize);
        const { x: x0, y: y0 } = this.center;
        const { x: x1, y: y1 } = this.outerCenter;
        const r0 = this.innerRadius;
        const r1 = this.outerRadius;
        const ox = x1 - r1;
        const oy = y1 - r1;
        const scale = defaultSize / (r1 * 2);
        const cx = (x0 - ox) * scale;
        const cy = (y0 - oy) * scale;
        const gradient = context2.createRadialGradient(
          cx,
          cy,
          r0 * scale,
          (x1 - ox) * scale,
          (y1 - oy) * scale,
          r1 * scale
        );
        addColorStops(gradient, colorStops);
        context2.fillStyle = colorStops[colorStops.length - 1].color;
        context2.fillRect(0, 0, defaultSize, defaultSize);
        context2.fillStyle = gradient;
        context2.translate(cx, cy);
        context2.rotate(this.rotation);
        context2.scale(1, this.scale);
        context2.translate(-cx, -cy);
        context2.fillRect(0, 0, defaultSize, defaultSize);
        this.texture = new Texture({
          source: new ImageSource({
            resource: canvas,
            addressMode: this._wrapMode
          })
        });
        const m2 = new Matrix();
        m2.scale(1 / scale, 1 / scale);
        m2.translate(ox, oy);
        if (this.textureSpace === "local") {
          m2.scale(defaultSize, defaultSize);
        }
        this.transform = m2;
      }
      /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */
      destroy() {
        this.texture?.destroy(true);
        this.texture = null;
        this.transform = null;
        this.colorStops = [];
        this.start = null;
        this.end = null;
        this.center = null;
        this.outerCenter = null;
      }
      /**
       * Returns a unique key for this gradient instance.
       * This key is used for caching and texture management.
       * @returns {string} Unique key for the gradient
       */
      get styleKey() {
        return `fill-gradient-${this.uid}-${this._tick}`;
      }
    };
    _FillGradient.defaultLinearOptions = {
      start: { x: 0, y: 0 },
      end: { x: 0, y: 1 },
      colorStops: [],
      textureSpace: "local",
      type: "linear",
      textureSize: 256,
      wrapMode: "clamp-to-edge"
    };
    _FillGradient.defaultRadialOptions = {
      center: { x: 0.5, y: 0.5 },
      innerRadius: 0,
      outerRadius: 0.5,
      colorStops: [],
      scale: 1,
      textureSpace: "local",
      type: "radial",
      textureSize: 256,
      wrapMode: "clamp-to-edge"
    };
    FillGradient = _FillGradient;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs
function generateTextureMatrix(out2, style, shape, matrix) {
  const textureMatrix = style.matrix ? out2.copyFrom(style.matrix).invert() : out2.identity();
  if (style.textureSpace === "local") {
    const bounds = shape.getBounds(tempRect);
    if (style.width) {
      bounds.pad(style.width);
    }
    const { x: tx, y: ty } = bounds;
    const sx = 1 / bounds.width;
    const sy = 1 / bounds.height;
    const mTx = -tx * sx;
    const mTy = -ty * sy;
    const a1 = textureMatrix.a;
    const b1 = textureMatrix.b;
    const c1 = textureMatrix.c;
    const d1 = textureMatrix.d;
    textureMatrix.a *= sx;
    textureMatrix.b *= sx;
    textureMatrix.c *= sy;
    textureMatrix.d *= sy;
    textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;
    textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;
  } else {
    textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);
    textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
  }
  const sourceStyle = style.texture.source.style;
  if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === "clamp-to-edge") {
    sourceStyle.addressMode = "repeat";
    sourceStyle.update();
  }
  if (matrix) {
    textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());
  }
  return textureMatrix;
}
var tempTextureMatrix, tempRect;
var init_generateTextureFillMatrix = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs"() {
    init_Matrix();
    init_Rectangle();
    init_FillGradient();
    tempTextureMatrix = new Matrix();
    tempRect = new Rectangle();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
function buildContextBatches(context2, gpuContext) {
  const { geometryData, batches } = gpuContext;
  batches.length = 0;
  geometryData.indices.length = 0;
  geometryData.vertices.length = 0;
  geometryData.uvs.length = 0;
  for (let i2 = 0; i2 < context2.instructions.length; i2++) {
    const instruction = context2.instructions[i2];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);
      }
      if (hole) {
        shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;
      }
      addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);
    }
  }
}
function addTextureToGeometryData(data, batches, geometryData) {
  const points = [];
  const build = shapeBuilders.rectangle;
  const rect = tempRect2;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  if (!build.build(rect, points)) {
    return;
  }
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  if (matrix) {
    transformVertices(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const texture = data.image;
  const textureUvs = texture.uvs;
  uvs.push(
    textureUvs.x0,
    textureUvs.y0,
    textureUvs.x1,
    textureUvs.y1,
    textureUvs.x3,
    textureUvs.y3,
    textureUvs.x2,
    textureUvs.y2
  );
  const graphicsBatch = BigPool.get(BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.attributeOffset = vertOffset;
  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
  graphicsBatch.baseColor = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) => {
    const points = [];
    const build = shapeBuilders[shape.type];
    if (!build.build(shape, points)) {
      return;
    }
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    let topology = "triangle-list";
    if (matrix) {
      transformVertices(points, matrix);
    }
    if (!isStroke) {
      if (holes) {
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(holes);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      if (!lineStyle.pixelLine) {
        buildLine(points, lineStyle, false, close, vertices, indices);
      } else {
        buildPixelLine(points, close, vertices, indices);
        topology = "line-list";
      }
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== Texture.WHITE) {
      const textureMatrix = generateTextureMatrix(tempTextureMatrix2, style, shape, matrix);
      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    graphicsBatch.topology = topology;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(holePrimitives) {
  const holeArrays = [];
  for (let k2 = 0; k2 < holePrimitives.length; k2++) {
    const holePrimitive = holePrimitives[k2].shape;
    const holePoints = [];
    const holeBuilder = shapeBuilders[holePrimitive.type];
    if (holeBuilder.build(holePrimitive, holePoints)) {
      holeArrays.push(holePoints);
    }
  }
  return holeArrays;
}
var shapeBuilders, tempRect2, tempTextureMatrix2;
var init_buildContextBatches = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Rectangle();
    init_buildUvs();
    init_transformVertices();
    init_Texture();
    init_PoolGroup();
    init_BatchableGraphics();
    init_buildCircle();
    init_buildLine();
    init_buildPixelLine();
    init_buildPolygon();
    init_buildRectangle();
    init_buildTriangle();
    init_generateTextureFillMatrix();
    init_triangulateWithHoles();
    shapeBuilders = {};
    extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
    extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
    tempRect2 = new Rectangle();
    tempTextureMatrix2 = new Matrix();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
var GpuGraphicsContext, GraphicsContextRenderData, _GraphicsContextSystem, GraphicsContextSystem;
var init_GraphicsContextSystem = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
    init_Extensions();
    init_getTextureBatchBindGroup();
    init_DefaultBatcher();
    init_InstructionSet();
    init_deprecation();
    init_PoolGroup();
    init_buildContextBatches();
    GpuGraphicsContext = class {
      constructor() {
        this.batches = [];
        this.geometryData = {
          vertices: [],
          uvs: [],
          indices: []
        };
      }
    };
    GraphicsContextRenderData = class {
      constructor() {
        this.instructions = new InstructionSet();
      }
      init(maxTextures) {
        this.batcher = new DefaultBatcher({
          maxTextures
        });
        this.instructions.reset();
      }
      /**
       * @deprecated since version 8.0.0
       * Use `batcher.geometry` instead.
       * @see {Batcher#geometry}
       */
      get geometry() {
        deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
        return this.batcher.geometry;
      }
      destroy() {
        this.batcher.destroy();
        this.instructions.destroy();
        this.batcher = null;
        this.instructions = null;
      }
    };
    _GraphicsContextSystem = class _GraphicsContextSystem2 {
      constructor(renderer) {
        this._gpuContextHash = {};
        this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        renderer.renderableGC.addManagedHash(this, "_gpuContextHash");
        renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
      }
      /**
       * Runner init called, update the default options
       * @ignore
       */
      init(options) {
        _GraphicsContextSystem2.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
      }
      /**
       * Returns the render data for a given GraphicsContext.
       * @param context - The GraphicsContext to get the render data for.
       * @internal
       */
      getContextRenderData(context2) {
        return this._graphicsDataContextHash[context2.uid] || this._initContextRenderData(context2);
      }
      /**
       * Updates the GPU context for a given GraphicsContext.
       * If the context is dirty, it will rebuild the batches and geometry data.
       * @param context - The GraphicsContext to update.
       * @returns The updated GpuGraphicsContext.
       * @internal
       */
      updateGpuContext(context2) {
        let gpuContext = this._gpuContextHash[context2.uid] || this._initContext(context2);
        if (context2.dirty) {
          if (gpuContext) {
            this._cleanGraphicsContextData(context2);
          } else {
            gpuContext = this._initContext(context2);
          }
          buildContextBatches(context2, gpuContext);
          const batchMode = context2.batchMode;
          if (context2.customShader || batchMode === "no-batch") {
            gpuContext.isBatchable = false;
          } else if (batchMode === "auto") {
            gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
          } else {
            gpuContext.isBatchable = true;
          }
          context2.dirty = false;
        }
        return gpuContext;
      }
      /**
       * Returns the GpuGraphicsContext for a given GraphicsContext.
       * If it does not exist, it will initialize a new one.
       * @param context - The GraphicsContext to get the GpuGraphicsContext for.
       * @returns The GpuGraphicsContext for the given GraphicsContext.
       * @internal
       */
      getGpuContext(context2) {
        return this._gpuContextHash[context2.uid] || this._initContext(context2);
      }
      _initContextRenderData(context2) {
        const graphicsData = BigPool.get(GraphicsContextRenderData, {
          maxTextures: this._renderer.limits.maxBatchableTextures
        });
        const { batches, geometryData } = this._gpuContextHash[context2.uid];
        const vertexSize = geometryData.vertices.length;
        const indexSize = geometryData.indices.length;
        for (let i2 = 0; i2 < batches.length; i2++) {
          batches[i2].applyTransform = false;
        }
        const batcher = graphicsData.batcher;
        batcher.ensureAttributeBuffer(vertexSize);
        batcher.ensureIndexBuffer(indexSize);
        batcher.begin();
        for (let i2 = 0; i2 < batches.length; i2++) {
          const batch = batches[i2];
          batcher.add(batch);
        }
        batcher.finish(graphicsData.instructions);
        const geometry = batcher.geometry;
        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
        const drawBatches = batcher.batches;
        for (let i2 = 0; i2 < drawBatches.length; i2++) {
          const batch = drawBatches[i2];
          batch.bindGroup = getTextureBatchBindGroup(
            batch.textures.textures,
            batch.textures.count,
            this._renderer.limits.maxBatchableTextures
          );
        }
        this._graphicsDataContextHash[context2.uid] = graphicsData;
        return graphicsData;
      }
      _initContext(context2) {
        const gpuContext = new GpuGraphicsContext();
        gpuContext.context = context2;
        this._gpuContextHash[context2.uid] = gpuContext;
        context2.on("destroy", this.onGraphicsContextDestroy, this);
        return this._gpuContextHash[context2.uid];
      }
      onGraphicsContextDestroy(context2) {
        this._cleanGraphicsContextData(context2);
        context2.off("destroy", this.onGraphicsContextDestroy, this);
        this._gpuContextHash[context2.uid] = null;
      }
      _cleanGraphicsContextData(context2) {
        const gpuContext = this._gpuContextHash[context2.uid];
        if (!gpuContext.isBatchable) {
          if (this._graphicsDataContextHash[context2.uid]) {
            BigPool.return(this.getContextRenderData(context2));
            this._graphicsDataContextHash[context2.uid] = null;
          }
        }
        if (gpuContext.batches) {
          gpuContext.batches.forEach((batch) => {
            BigPool.return(batch);
          });
        }
      }
      destroy() {
        for (const i2 in this._gpuContextHash) {
          if (this._gpuContextHash[i2]) {
            this.onGraphicsContextDestroy(this._gpuContextHash[i2].context);
          }
        }
      }
    };
    _GraphicsContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "graphicsContext"
    };
    _GraphicsContextSystem.defaultOptions = {
      /**
       * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
       * @default 0.5
       */
      bezierSmoothness: 0.5
    };
    GraphicsContextSystem = _GraphicsContextSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, _State, State;
var init_State = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
    "use strict";
    blendModeIds = {
      normal: 0,
      add: 1,
      multiply: 2,
      screen: 3,
      overlay: 4,
      erase: 5,
      "normal-npm": 6,
      "add-npm": 7,
      "screen-npm": 8,
      min: 9,
      max: 10
    };
    BLEND = 0;
    OFFSET = 1;
    CULLING = 2;
    DEPTH_TEST = 3;
    WINDING = 4;
    DEPTH_MASK = 5;
    _State = class _State2 {
      constructor() {
        this.data = 0;
        this.blendMode = "normal";
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get blend() {
        return !!(this.data & 1 << BLEND);
      }
      set blend(value) {
        if (!!(this.data & 1 << BLEND) !== value) {
          this.data ^= 1 << BLEND;
        }
      }
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get offsets() {
        return !!(this.data & 1 << OFFSET);
      }
      set offsets(value) {
        if (!!(this.data & 1 << OFFSET) !== value) {
          this.data ^= 1 << OFFSET;
        }
      }
      /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
      set cullMode(value) {
        if (value === "none") {
          this.culling = false;
          return;
        }
        this.culling = true;
        this.clockwiseFrontFace = value === "front";
      }
      get cullMode() {
        if (!this.culling) {
          return "none";
        }
        return this.clockwiseFrontFace ? "front" : "back";
      }
      /**
       * Activates culling of polygons.
       * @default false
       */
      get culling() {
        return !!(this.data & 1 << CULLING);
      }
      set culling(value) {
        if (!!(this.data & 1 << CULLING) !== value) {
          this.data ^= 1 << CULLING;
        }
      }
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get depthTest() {
        return !!(this.data & 1 << DEPTH_TEST);
      }
      set depthTest(value) {
        if (!!(this.data & 1 << DEPTH_TEST) !== value) {
          this.data ^= 1 << DEPTH_TEST;
        }
      }
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get depthMask() {
        return !!(this.data & 1 << DEPTH_MASK);
      }
      set depthMask(value) {
        if (!!(this.data & 1 << DEPTH_MASK) !== value) {
          this.data ^= 1 << DEPTH_MASK;
        }
      }
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get clockwiseFrontFace() {
        return !!(this.data & 1 << WINDING);
      }
      set clockwiseFrontFace(value) {
        if (!!(this.data & 1 << WINDING) !== value) {
          this.data ^= 1 << WINDING;
        }
      }
      /**
       * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default 'normal'
       */
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(value) {
        this.blend = value !== "none";
        this._blendMode = value;
        this._blendModeId = blendModeIds[value] || 0;
      }
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get polygonOffset() {
        return this._polygonOffset;
      }
      set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      }
      toString() {
        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      }
      /**
       * A quickly getting an instance of a State that is configured for 2d rendering.
       * @returns a new State with values set for 2d rendering
       */
      static for2d() {
        const state = new _State2();
        state.depthTest = false;
        state.blend = true;
        return state;
      }
    };
    _State.default2d = _State.for2d();
    State = _State;
  }
});

// node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
function color32BitToUniform(abgr, out2, offset) {
  const alpha = (abgr >> 24 & 255) / 255;
  out2[offset++] = (abgr & 255) / 255 * alpha;
  out2[offset++] = (abgr >> 8 & 255) / 255 * alpha;
  out2[offset++] = (abgr >> 16 & 255) / 255 * alpha;
  out2[offset++] = alpha;
}
var init_colorToUniform = __esm({
  "node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
var GraphicsGpuData, GraphicsPipe;
var init_GraphicsPipe = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
    init_Extensions();
    init_State();
    init_PoolGroup();
    init_colorToUniform();
    init_BatchableGraphics();
    GraphicsGpuData = class {
      constructor() {
        this.batches = [];
        this.batched = false;
      }
      destroy() {
        this.batches.forEach((batch) => {
          BigPool.return(batch);
        });
        this.batches.length = 0;
      }
    };
    GraphicsPipe = class {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this.renderer = renderer;
        this._adaptor = adaptor;
        this.renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._adaptor.contextChange(this.renderer);
      }
      validateRenderable(graphics) {
        const context2 = graphics.context;
        const wasBatched = !!graphics._gpuData;
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context2);
        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
          return true;
        }
        return false;
      }
      addRenderable(graphics, instructionSet) {
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
        if (graphics.didViewUpdate) {
          this._rebuild(graphics);
        }
        if (gpuContext.isBatchable) {
          this._addToBatcher(graphics, instructionSet);
        } else {
          this.renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(graphics);
        }
      }
      updateRenderable(graphics) {
        const gpuData = this._getGpuDataForRenderable(graphics);
        const batches = gpuData.batches;
        for (let i2 = 0; i2 < batches.length; i2++) {
          const batch = batches[i2];
          batch._batcher.updateElement(batch);
        }
      }
      execute(graphics) {
        if (!graphics.isRenderable)
          return;
        const renderer = this.renderer;
        const context2 = graphics.context;
        const contextSystem = renderer.graphicsContext;
        if (!contextSystem.getGpuContext(context2).batches.length) {
          return;
        }
        const shader = context2.customShader || this._adaptor.shader;
        this.state.blendMode = graphics.groupBlendMode;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = graphics.groupTransform;
        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
        color32BitToUniform(
          graphics.groupColorAlpha,
          localUniforms.uColor,
          0
        );
        this._adaptor.execute(this, graphics);
      }
      _rebuild(graphics) {
        const gpuData = this._getGpuDataForRenderable(graphics);
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
        gpuData.destroy();
        if (gpuContext.isBatchable) {
          this._updateBatchesForRenderable(graphics, gpuData);
        }
      }
      _addToBatcher(graphics, instructionSet) {
        const batchPipe = this.renderer.renderPipes.batch;
        const batches = this._getGpuDataForRenderable(graphics).batches;
        for (let i2 = 0; i2 < batches.length; i2++) {
          const batch = batches[i2];
          batchPipe.addToBatch(batch, instructionSet);
        }
      }
      _getGpuDataForRenderable(graphics) {
        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);
      }
      _initGpuDataForRenderable(graphics) {
        const gpuData = new GraphicsGpuData();
        graphics._gpuData[this.renderer.uid] = gpuData;
        return gpuData;
      }
      _updateBatchesForRenderable(graphics, gpuData) {
        const context2 = graphics.context;
        const gpuContext = this.renderer.graphicsContext.getGpuContext(context2);
        const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
        gpuData.batches = gpuContext.batches.map((batch) => {
          const batchClone = BigPool.get(BatchableGraphics);
          batch.copyTo(batchClone);
          batchClone.renderable = graphics;
          batchClone.roundPixels = roundPixels;
          return batchClone;
        });
      }
      destroy() {
        this.renderer = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.state = null;
      }
    };
    GraphicsPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "graphics"
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/init.mjs
var init_init7 = __esm({
  "node_modules/pixi.js/lib/scene/graphics/init.mjs"() {
    init_Extensions();
    init_GraphicsContextSystem();
    init_GraphicsPipe();
    extensions.add(GraphicsPipe);
    extensions.add(GraphicsContextSystem);
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
var BatchableMesh;
var init_BatchableMesh = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"() {
    "use strict";
    BatchableMesh = class {
      constructor() {
        this.batcherName = "default";
        this.packAsQuad = false;
        this.indexOffset = 0;
        this.attributeOffset = 0;
        this.roundPixels = 0;
        this._batcher = null;
        this._batch = null;
        this._textureMatrixUpdateId = -1;
        this._uvUpdateId = -1;
      }
      get blendMode() {
        return this.renderable.groupBlendMode;
      }
      get topology() {
        return this._topology || this.geometry.topology;
      }
      set topology(value) {
        this._topology = value;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this._batcher = null;
        this._batch = null;
        this.geometry = null;
        this._uvUpdateId = -1;
        this._textureMatrixUpdateId = -1;
      }
      /**
       * Sets the texture for the batchable mesh.
       * As it does so, it resets the texture matrix update ID.
       * this is to ensure that the texture matrix is recalculated when the uvs are referenced
       * @param value - The texture to set.
       */
      setTexture(value) {
        if (this.texture === value)
          return;
        this.texture = value;
        this._textureMatrixUpdateId = -1;
      }
      get uvs() {
        const geometry = this.geometry;
        const uvBuffer = geometry.getBuffer("aUV");
        const uvs = uvBuffer.data;
        let transformedUvs = uvs;
        const textureMatrix = this.texture.textureMatrix;
        if (!textureMatrix.isSimple) {
          transformedUvs = this._transformedUvs;
          if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
            if (!transformedUvs || transformedUvs.length < uvs.length) {
              transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
            }
            this._textureMatrixUpdateId = textureMatrix._updateID;
            this._uvUpdateId = uvBuffer._updateID;
            textureMatrix.multiplyUvs(uvs, transformedUvs);
          }
        }
        return transformedUvs;
      }
      get positions() {
        return this.geometry.positions;
      }
      get indices() {
        return this.geometry.indices;
      }
      get color() {
        return this.renderable.groupColorAlpha;
      }
      get groupTransform() {
        return this.renderable.groupTransform;
      }
      get attributeSize() {
        return this.geometry.positions.length / 2;
      }
      get indexSize() {
        return this.geometry.indices.length;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
var MeshGpuData, MeshPipe;
var init_MeshPipe = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs"() {
    init_Extensions();
    init_Matrix();
    init_BindGroup();
    init_UniformGroup();
    init_getAdjustedBlendModeBlend();
    init_colorToUniform();
    init_BatchableMesh();
    MeshGpuData = class {
      destroy() {
      }
    };
    MeshPipe = class {
      constructor(renderer, adaptor) {
        this.localUniforms = new UniformGroup({
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        this.localUniformsBindGroup = new BindGroup({
          0: this.localUniforms
        });
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
      }
      validateRenderable(mesh) {
        const meshData = this._getMeshData(mesh);
        const wasBatched = meshData.batched;
        const isBatched = mesh.batched;
        meshData.batched = isBatched;
        if (wasBatched !== isBatched) {
          return true;
        } else if (isBatched) {
          const geometry = mesh._geometry;
          if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
            meshData.indexSize = geometry.indices.length;
            meshData.vertexSize = geometry.positions.length;
            return true;
          }
          const batchableMesh = this._getBatchableMesh(mesh);
          if (batchableMesh.texture.uid !== mesh._texture.uid) {
            batchableMesh._textureMatrixUpdateId = -1;
          }
          return !batchableMesh._batcher.checkAndUpdateTexture(
            batchableMesh,
            mesh._texture
          );
        }
        return false;
      }
      addRenderable(mesh, instructionSet) {
        const batcher = this.renderer.renderPipes.batch;
        const meshData = this._getMeshData(mesh);
        if (mesh.didViewUpdate) {
          meshData.indexSize = mesh._geometry.indices?.length;
          meshData.vertexSize = mesh._geometry.positions?.length;
        }
        if (meshData.batched) {
          const gpuBatchableMesh = this._getBatchableMesh(mesh);
          gpuBatchableMesh.setTexture(mesh._texture);
          gpuBatchableMesh.geometry = mesh._geometry;
          batcher.addToBatch(gpuBatchableMesh, instructionSet);
        } else {
          batcher.break(instructionSet);
          instructionSet.add(mesh);
        }
      }
      updateRenderable(mesh) {
        if (mesh.batched) {
          const gpuBatchableMesh = this._getBatchableMesh(mesh);
          gpuBatchableMesh.setTexture(mesh._texture);
          gpuBatchableMesh.geometry = mesh._geometry;
          gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
        }
      }
      execute(mesh) {
        if (!mesh.isRenderable)
          return;
        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
        const localUniforms = this.localUniforms;
        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
        localUniforms.update();
        color32BitToUniform(
          mesh.groupColorAlpha,
          localUniforms.uniforms.uColor,
          0
        );
        this._adaptor.execute(this, mesh);
      }
      _getMeshData(mesh) {
        var _a, _b;
        (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());
        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);
      }
      _initMeshData(mesh) {
        mesh._gpuData[this.renderer.uid].meshData = {
          batched: mesh.batched,
          indexSize: 0,
          vertexSize: 0
        };
        return mesh._gpuData[this.renderer.uid].meshData;
      }
      _getBatchableMesh(mesh) {
        var _a, _b;
        (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());
        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);
      }
      _initBatchableMesh(mesh) {
        const gpuMesh = new BatchableMesh();
        gpuMesh.renderable = mesh;
        gpuMesh.setTexture(mesh._texture);
        gpuMesh.transform = mesh.groupTransform;
        gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;
        return gpuMesh;
      }
      destroy() {
        this.localUniforms = null;
        this.localUniformsBindGroup = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.renderer = null;
      }
    };
    MeshPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "mesh"
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/init.mjs
var init_init8 = __esm({
  "node_modules/pixi.js/lib/scene/mesh/init.mjs"() {
    init_Extensions();
    init_MeshPipe();
    extensions.add(MeshPipe);
  }
});

// node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs
var GlParticleContainerAdaptor;
var init_GlParticleContainerAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs"() {
    "use strict";
    GlParticleContainerAdaptor = class {
      execute(particleContainerPipe, container) {
        const state = particleContainerPipe.state;
        const renderer = particleContainerPipe.renderer;
        const shader = container.shader || particleContainerPipe.defaultShader;
        shader.resources.uTexture = container.texture._source;
        shader.resources.uniforms = particleContainerPipe.localUniforms;
        const gl = renderer.gl;
        const buffer = particleContainerPipe.getBuffers(container);
        renderer.shader.bind(shader);
        renderer.state.set(state);
        renderer.geometry.bind(buffer.geometry, shader.glProgram);
        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs
function createIndicesForQuads(size, outBuffer = null) {
  const totalIndices = size * 6;
  if (totalIndices > 65535) {
    outBuffer || (outBuffer = new Uint32Array(totalIndices));
  } else {
    outBuffer || (outBuffer = new Uint16Array(totalIndices));
  }
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {
    outBuffer[i2 + 0] = j2 + 0;
    outBuffer[i2 + 1] = j2 + 1;
    outBuffer[i2 + 2] = j2 + 2;
    outBuffer[i2 + 3] = j2 + 0;
    outBuffer[i2 + 4] = j2 + 2;
    outBuffer[i2 + 5] = j2 + 3;
  }
  return outBuffer;
}
var init_createIndicesForQuads = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs
function generateParticleUpdateFunction(properties) {
  return {
    dynamicUpdate: generateUpdateFunction(properties, true),
    staticUpdate: generateUpdateFunction(properties, false)
  };
}
function generateUpdateFunction(properties, dynamic) {
  const funcFragments = [];
  funcFragments.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
  let offset = 0;
  for (const i2 in properties) {
    const property = properties[i2];
    if (dynamic !== property.dynamic)
      continue;
    funcFragments.push(`offset = index + ${offset}`);
    funcFragments.push(property.code);
    const attributeInfo = getAttributeInfoFromFormat(property.format);
    offset += attributeInfo.stride / 4;
  }
  funcFragments.push(`
            index += stride * 4;
        }
    `);
  funcFragments.unshift(`
        var stride = ${offset};
    `);
  const functionSource = funcFragments.join("\n");
  return new Function("ps", "f32v", "u32v", functionSource);
}
var init_generateParticleUpdateFunction = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs"() {
    init_getAttributeInfoFromFormat();
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs
function getParticleSyncKey(properties) {
  const keyGen = [];
  for (const key in properties) {
    const property = properties[key];
    keyGen.push(key, property.code, property.dynamic ? "d" : "s");
  }
  return keyGen.join("_");
}
var ParticleBuffer;
var init_ParticleBuffer = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs"() {
    init_Buffer();
    init_const4();
    init_Geometry();
    init_getAttributeInfoFromFormat();
    init_ViewableBuffer();
    init_createIndicesForQuads();
    init_generateParticleUpdateFunction();
    ParticleBuffer = class {
      constructor(options) {
        this._size = 0;
        this._generateParticleUpdateCache = {};
        const size = this._size = options.size ?? 1e3;
        const properties = options.properties;
        let staticVertexSize = 0;
        let dynamicVertexSize = 0;
        for (const i2 in properties) {
          const property = properties[i2];
          const attributeInfo = getAttributeInfoFromFormat(property.format);
          if (property.dynamic) {
            dynamicVertexSize += attributeInfo.stride;
          } else {
            staticVertexSize += attributeInfo.stride;
          }
        }
        this._dynamicStride = dynamicVertexSize / 4;
        this._staticStride = staticVertexSize / 4;
        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);
        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);
        this.indexBuffer = createIndicesForQuads(size);
        const geometry = new Geometry();
        let dynamicOffset = 0;
        let staticOffset = 0;
        this._staticBuffer = new Buffer2({
          data: new Float32Array(1),
          label: "static-particle-buffer",
          shrinkToFit: false,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        this._dynamicBuffer = new Buffer2({
          data: new Float32Array(1),
          label: "dynamic-particle-buffer",
          shrinkToFit: false,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        for (const i2 in properties) {
          const property = properties[i2];
          const attributeInfo = getAttributeInfoFromFormat(property.format);
          if (property.dynamic) {
            geometry.addAttribute(property.attributeName, {
              buffer: this._dynamicBuffer,
              stride: this._dynamicStride * 4,
              offset: dynamicOffset * 4,
              format: property.format
            });
            dynamicOffset += attributeInfo.size;
          } else {
            geometry.addAttribute(property.attributeName, {
              buffer: this._staticBuffer,
              stride: this._staticStride * 4,
              offset: staticOffset * 4,
              format: property.format
            });
            staticOffset += attributeInfo.size;
          }
        }
        geometry.addIndex(this.indexBuffer);
        const uploadFunction = this.getParticleUpdate(properties);
        this._dynamicUpload = uploadFunction.dynamicUpdate;
        this._staticUpload = uploadFunction.staticUpdate;
        this.geometry = geometry;
      }
      getParticleUpdate(properties) {
        const key = getParticleSyncKey(properties);
        if (this._generateParticleUpdateCache[key]) {
          return this._generateParticleUpdateCache[key];
        }
        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);
        return this._generateParticleUpdateCache[key];
      }
      generateParticleUpdate(properties) {
        return generateParticleUpdateFunction(properties);
      }
      update(particles, uploadStatic) {
        if (particles.length > this._size) {
          uploadStatic = true;
          this._size = Math.max(particles.length, this._size * 1.5 | 0);
          this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);
          this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);
          this.indexBuffer = createIndicesForQuads(this._size);
          this.geometry.indexBuffer.setDataWithSize(
            this.indexBuffer,
            this.indexBuffer.byteLength,
            true
          );
        }
        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
        this._dynamicBuffer.setDataWithSize(
          this.dynamicAttributeBuffer.float32View,
          particles.length * this._dynamicStride * 4,
          true
        );
        if (uploadStatic) {
          const staticAttributeBuffer = this.staticAttributeBuffer;
          this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
          this._staticBuffer.setDataWithSize(
            staticAttributeBuffer.float32View,
            particles.length * this._staticStride * 4,
            true
          );
        }
      }
      destroy() {
        this._staticBuffer.destroy();
        this._dynamicBuffer.destroy();
        this.geometry.destroy();
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs
var fragment;
var init_particles_frag = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs"() {
    fragment = "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}";
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs
var vertex;
var init_particles_vert = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs"() {
    vertex = "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n";
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs
var wgsl;
var init_particles_wgsl = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs"() {
    wgsl = "\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs
var ParticleShader;
var init_ParticleShader = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs"() {
    init_Color();
    init_Matrix();
    init_GlProgram();
    init_GpuProgram();
    init_Shader();
    init_Texture();
    init_TextureStyle();
    init_particles_frag();
    init_particles_vert();
    init_particles_wgsl();
    ParticleShader = class extends Shader {
      constructor() {
        const glProgram3 = GlProgram.from({
          vertex,
          fragment
        });
        const gpuProgram3 = GpuProgram.from({
          fragment: {
            source: wgsl,
            entryPoint: "mainFragment"
          },
          vertex: {
            source: wgsl,
            entryPoint: "mainVertex"
          }
        });
        super({
          glProgram: glProgram3,
          gpuProgram: gpuProgram3,
          resources: {
            // this will be replaced with the texture from the particle container
            uTexture: Texture.WHITE.source,
            // this will be replaced with the texture style from the particle container
            uSampler: new TextureStyle({}),
            // this will be replaced with the local uniforms from the particle container
            uniforms: {
              uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
              uColor: { value: new Color(16777215), type: "vec4<f32>" },
              uRound: { value: 1, type: "f32" },
              uResolution: { value: [0, 0], type: "vec2<f32>" }
            }
          }
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs
var ParticleContainerPipe;
var init_ParticleContainerPipe = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs"() {
    init_Matrix();
    init_UniformGroup();
    init_getAdjustedBlendModeBlend();
    init_State();
    init_colorToUniform();
    init_ParticleBuffer();
    init_ParticleShader();
    ParticleContainerPipe = class {
      /**
       * @param renderer - The renderer this sprite batch works for.
       * @param adaptor
       */
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this.localUniforms = new UniformGroup({
          uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array(4), type: "vec4<f32>" },
          uRound: { value: 1, type: "f32" },
          uResolution: { value: [0, 0], type: "vec2<f32>" }
        });
        this.renderer = renderer;
        this.adaptor = adaptor;
        this.defaultShader = new ParticleShader();
        this.state = State.for2d();
      }
      validateRenderable(_renderable) {
        return false;
      }
      addRenderable(renderable, instructionSet) {
        this.renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(renderable);
      }
      getBuffers(renderable) {
        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);
      }
      _initBuffer(renderable) {
        renderable._gpuData[this.renderer.uid] = new ParticleBuffer({
          size: renderable.particleChildren.length,
          properties: renderable._properties
        });
        return renderable._gpuData[this.renderer.uid];
      }
      updateRenderable(_renderable) {
      }
      execute(container) {
        const children = container.particleChildren;
        if (children.length === 0) {
          return;
        }
        const renderer = this.renderer;
        const buffer = this.getBuffers(container);
        container.texture || (container.texture = children[0].texture);
        const state = this.state;
        buffer.update(children, container._childrenDirty);
        container._childrenDirty = false;
        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);
        const uniforms = this.localUniforms.uniforms;
        const transformationMatrix = uniforms.uTranslationMatrix;
        container.worldTransform.copyTo(transformationMatrix);
        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;
        uniforms.uRound = renderer._roundPixels | container._roundPixels;
        color32BitToUniform(
          container.groupColorAlpha,
          uniforms.uColor,
          0
        );
        this.adaptor.execute(this, container);
      }
      /** Destroys the ParticleRenderer. */
      destroy() {
        this.renderer = null;
        if (this.defaultShader) {
          this.defaultShader.destroy();
          this.defaultShader = null;
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs
var GlParticleContainerPipe;
var init_GlParticleContainerPipe = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs"() {
    init_Extensions();
    init_GlParticleContainerAdaptor();
    init_ParticleContainerPipe();
    GlParticleContainerPipe = class extends ParticleContainerPipe {
      constructor(renderer) {
        super(renderer, new GlParticleContainerAdaptor());
      }
    };
    GlParticleContainerPipe.extension = {
      type: [
        ExtensionType.WebGLPipes
      ],
      name: "particle"
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs
var GpuParticleContainerAdaptor;
var init_GpuParticleContainerAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs"() {
    "use strict";
    GpuParticleContainerAdaptor = class {
      execute(particleContainerPipe, container) {
        const renderer = particleContainerPipe.renderer;
        const shader = container.shader || particleContainerPipe.defaultShader;
        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);
        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);
        const state = particleContainerPipe.state;
        const buffer = particleContainerPipe.getBuffers(container);
        renderer.encoder.draw({
          geometry: buffer.geometry,
          shader: container.shader || particleContainerPipe.defaultShader,
          state,
          size: container.particleChildren.length * 6
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs
var GpuParticleContainerPipe;
var init_GpuParticleContainerPipe = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs"() {
    init_Extensions();
    init_GpuParticleContainerAdaptor();
    init_ParticleContainerPipe();
    GpuParticleContainerPipe = class extends ParticleContainerPipe {
      constructor(renderer) {
        super(renderer, new GpuParticleContainerAdaptor());
      }
    };
    GpuParticleContainerPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "particle"
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/init.mjs
var init_init9 = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/init.mjs"() {
    init_Extensions();
    init_GlParticleContainerPipe();
    init_GpuParticleContainerPipe();
    extensions.add(GlParticleContainerPipe);
    extensions.add(GpuParticleContainerPipe);
  }
});

// node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs
function updateTextBounds(batchableSprite, text) {
  const { texture, bounds } = batchableSprite;
  const padding = text._style._getFinalPadding();
  updateQuadBounds(bounds, text._anchor, texture);
  const paddingOffset = text._anchor._x * padding * 2;
  const paddingOffsetY = text._anchor._y * padding * 2;
  bounds.minX -= padding - paddingOffset;
  bounds.minY -= padding - paddingOffsetY;
  bounds.maxX -= padding - paddingOffset;
  bounds.maxY -= padding - paddingOffsetY;
}
var init_updateTextBounds = __esm({
  "node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs"() {
    init_updateQuadBounds();
  }
});

// node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
var BatchableSprite;
var init_BatchableSprite = __esm({
  "node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"() {
    "use strict";
    BatchableSprite = class {
      constructor() {
        this.batcherName = "default";
        this.topology = "triangle-list";
        this.attributeSize = 4;
        this.indexSize = 6;
        this.packAsQuad = true;
        this.roundPixels = 0;
        this._attributeStart = 0;
        this._batcher = null;
        this._batch = null;
      }
      get blendMode() {
        return this.renderable.groupBlendMode;
      }
      get color() {
        return this.renderable.groupColorAlpha;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this._batcher = null;
        this._batch = null;
        this.bounds = null;
      }
      destroy() {
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs
var BatchableText;
var init_BatchableText = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs"() {
    init_BatchableSprite();
    BatchableText = class extends BatchableSprite {
      constructor(renderer) {
        super();
        this._renderer = renderer;
        renderer.runners.resolutionChange.add(this);
      }
      resolutionChange() {
        const text = this.renderable;
        if (text._autoResolution) {
          text.onViewUpdate();
        }
      }
      destroy() {
        const { canvasText } = this._renderer;
        const refCount = canvasText.getReferenceCount(this.currentKey);
        if (refCount > 0) {
          canvasText.decreaseReferenceCount(this.currentKey);
        } else if (this.texture) {
          canvasText.returnTexture(this.texture);
        }
        this._renderer.runners.resolutionChange.remove(this);
        this._renderer = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
var CanvasTextPipe;
var init_CanvasTextPipe = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
    init_Extensions();
    init_updateTextBounds();
    init_BatchableText();
    CanvasTextPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      validateRenderable(text) {
        const gpuText = this._getGpuText(text);
        const newKey = text.styleKey;
        if (gpuText.currentKey !== newKey)
          return true;
        return text._didTextUpdate;
      }
      addRenderable(text, instructionSet) {
        const batchableText = this._getGpuText(text);
        if (text._didTextUpdate) {
          const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
          if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution) {
            this._updateGpuText(text);
          }
          text._didTextUpdate = false;
          updateTextBounds(batchableText, text);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);
      }
      updateRenderable(text) {
        const batchableText = this._getGpuText(text);
        batchableText._batcher.updateElement(batchableText);
      }
      _updateGpuText(text) {
        const batchableText = this._getGpuText(text);
        if (batchableText.texture) {
          this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);
        }
        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
        batchableText.texture = this._renderer.canvasText.getManagedTexture(text);
        batchableText.currentKey = text.styleKey;
      }
      _getGpuText(text) {
        return text._gpuData[this._renderer.uid] || this.initGpuText(text);
      }
      initGpuText(text) {
        const batchableText = new BatchableText(this._renderer);
        batchableText.currentKey = "--";
        batchableText.renderable = text;
        batchableText.transform = text.groupTransform;
        batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
        batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;
        text._gpuData[this._renderer.uid] = batchableText;
        return batchableText;
      }
      destroy() {
        this._renderer = null;
      }
    };
    CanvasTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "text"
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
var repetitionMap, FillPattern;
var init_FillPattern = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
    init_Matrix();
    init_uid();
    repetitionMap = {
      repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
      },
      "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
      },
      "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      },
      "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    };
    FillPattern = class {
      constructor(texture, repetition) {
        this.uid = uid("fillPattern");
        this._tick = 0;
        this.transform = new Matrix();
        this.texture = texture;
        this.transform.scale(
          1 / texture.frame.width,
          1 / texture.frame.height
        );
        if (repetition) {
          texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
          texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
        }
      }
      /**
       * Sets the transform for the pattern
       * @param transform - The transform matrix to apply to the pattern.
       * If not provided, the pattern will use the default transform.
       */
      setTransform(transform) {
        const texture = this.texture;
        this.transform.copyFrom(transform);
        this.transform.invert();
        this.transform.scale(
          1 / texture.frame.width,
          1 / texture.frame.height
        );
        this._tick++;
      }
      /** Internal texture used to render the gradient */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this._texture === value)
          return;
        this._texture = value;
        this._tick++;
      }
      /**
       * Returns a unique key for this instance.
       * This key is used for caching.
       * @returns {string} Unique key for the instance
       */
      get styleKey() {
        return `fill-pattern-${this.uid}-${this._tick}`;
      }
      /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */
      destroy() {
        this.texture.destroy(true);
        this.texture = null;
      }
    };
  }
});

// node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "node_modules/parse-svg-path/index.js"(exports, module) {
    module.exports = parse2;
    var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse2(path2) {
      var data = [];
      path2.replace(segment, function(_, command, args) {
        var type = command.toLowerCase();
        args = parseValues(args);
        if (type == "m" && args.length > 2) {
          data.push([command].concat(args.splice(0, 2)));
          type = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length[type]) {
            args.unshift(command);
            return data.push(args);
          }
          if (args.length < length[type]) throw new Error("malformed path data");
          data.push([command].concat(args.splice(0, length[type])));
        }
      });
      return data;
    }
    var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number);
      return numbers ? numbers.map(Number) : [];
    }
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs
function parseSVGPath(svgPath, path2) {
  const commands = (0, import_parse_svg_path.default)(svgPath);
  const subpaths = [];
  let currentSubPath = null;
  let lastX = 0;
  let lastY = 0;
  for (let i2 = 0; i2 < commands.length; i2++) {
    const command = commands[i2];
    const type = command[0];
    const data = command;
    switch (type) {
      case "M":
        lastX = data[1];
        lastY = data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[1];
        lastY += data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[1];
        lastY = data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[1];
        lastY += data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[5];
        lastY = data[6];
        path2.bezierCurveTo(
          data[1],
          data[2],
          // First control point
          data[3],
          data[4],
          // Second control point
          lastX,
          lastY
          // End point
        );
        break;
      case "c":
        path2.bezierCurveTo(
          lastX + data[1],
          lastY + data[2],
          // First control point
          lastX + data[3],
          lastY + data[4],
          // Second control point
          lastX + data[5],
          lastY + data[6]
          // End point
        );
        lastX += data[5];
        lastY += data[6];
        break;
      case "S":
        lastX = data[3];
        lastY = data[4];
        path2.bezierCurveToShort(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "s":
        path2.bezierCurveToShort(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "Q":
        lastX = data[3];
        lastY = data[4];
        path2.quadraticCurveTo(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "q":
        path2.quadraticCurveTo(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "T":
        lastX = data[1];
        lastY = data[2];
        path2.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "t":
        lastX += data[1];
        lastY += data[2];
        path2.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "A":
        lastX = data[6];
        lastY = data[7];
        path2.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "a":
        lastX += data[6];
        lastY += data[7];
        path2.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "Z":
      case "z":
        path2.closePath();
        if (subpaths.length > 0) {
          currentSubPath = subpaths.pop();
          if (currentSubPath) {
            lastX = currentSubPath.startX;
            lastY = currentSubPath.startY;
          } else {
            lastX = 0;
            lastY = 0;
          }
        }
        currentSubPath = null;
        break;
      default:
        warn(`Unknown SVG path command: ${type}`);
    }
    if (type !== "Z" && type !== "z") {
      if (currentSubPath === null) {
        currentSubPath = { startX: lastX, startY: lastY };
        subpaths.push(currentSubPath);
      }
    }
  }
  return path2;
}
var import_parse_svg_path;
var init_parseSVGPath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs"() {
    import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
    init_warn();
  }
});

// node_modules/pixi.js/lib/maths/shapes/Circle.mjs
var Circle;
var init_Circle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
    init_Rectangle();
    Circle = class _Circle {
      /**
       * @param x - The X coordinate of the center of this circle
       * @param y - The Y coordinate of the center of this circle
       * @param radius - The radius of the circle
       */
      constructor(x2 = 0, y2 = 0, radius = 0) {
        this.type = "circle";
        this.x = x2;
        this.y = y2;
        this.radius = radius;
      }
      /**
       * Creates a clone of this Circle instance.
       * @example
       * ```ts
       * // Basic circle cloning
       * const original = new Circle(100, 100, 50);
       * const copy = original.clone();
       *
       * // Clone and modify
       * const modified = original.clone();
       * modified.radius = 75;
       *
       * // Verify independence
       * console.log(original.radius); // 50
       * console.log(modified.radius); // 75
       * ```
       * @returns A copy of the Circle
       * @see {@link Circle.copyFrom} For copying into existing circle
       * @see {@link Circle.copyTo} For copying to another circle
       */
      clone() {
        return new _Circle(this.x, this.y, this.radius);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle.
       *
       * Uses the distance formula to determine if a point is inside the circle's radius.
       *
       * Commonly used for hit testing in PixiJS events and graphics.
       * @example
       * ```ts
       * // Basic containment check
       * const circle = new Circle(100, 100, 50);
       * const isInside = circle.contains(120, 120);
       *
       * // Check mouse position
       * const circle = new Circle(0, 0, 100);
       * container.hitArea = circle;
       * container.on('pointermove', (e) => {
       *     // only called if pointer is within circle
       * });
       * ```
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Circle
       * @see {@link Circle.strokeContains} For checking stroke intersection
       * @see {@link Circle.getBounds} For getting bounding box
       */
      contains(x2, y2) {
        if (this.radius <= 0)
          return false;
        const r2 = this.radius * this.radius;
        let dx = this.x - x2;
        let dy = this.y - y2;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle including the stroke.
       * @example
       * ```ts
       * // Basic stroke check
       * const circle = new Circle(100, 100, 50);
       * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width
       *
       * // Check with different alignments
       * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside
       * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered
       * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside
       * ```
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param width - The width of the line to check
       * @param alignment - The alignment of the stroke, 0.5 by default
       * @returns Whether the x/y coordinates are within this Circle's stroke
       * @see {@link Circle.contains} For checking fill containment
       * @see {@link Circle.getBounds} For getting stroke bounds
       */
      strokeContains(x2, y2, width, alignment = 0.5) {
        if (this.radius === 0)
          return false;
        const dx = this.x - x2;
        const dy = this.y - y2;
        const radius = this.radius;
        const outerWidth = (1 - alignment) * width;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance <= radius + outerWidth && distance > radius - (width - outerWidth);
      }
      /**
       * Returns the framing rectangle of the circle as a Rectangle object.
       * @example
       * ```ts
       * // Basic bounds calculation
       * const circle = new Circle(100, 100, 50);
       * const bounds = circle.getBounds();
       * // bounds: x=50, y=50, width=100, height=100
       *
       * // Reuse existing rectangle
       * const rect = new Rectangle();
       * circle.getBounds(rect);
       * ```
       * @param out - Optional Rectangle object to store the result
       * @returns The framing rectangle
       * @see {@link Rectangle} For rectangle properties
       * @see {@link Circle.contains} For point containment
       */
      getBounds(out2) {
        out2 || (out2 = new Rectangle());
        out2.x = this.x - this.radius;
        out2.y = this.y - this.radius;
        out2.width = this.radius * 2;
        out2.height = this.radius * 2;
        return out2;
      }
      /**
       * Copies another circle to this one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Circle(100, 100, 50);
       * const target = new Circle();
       * target.copyFrom(source);
       * ```
       * @param circle - The circle to copy from
       * @returns Returns itself
       * @see {@link Circle.copyTo} For copying to another circle
       * @see {@link Circle.clone} For creating new circle copy
       */
      copyFrom(circle) {
        this.x = circle.x;
        this.y = circle.y;
        this.radius = circle.radius;
        return this;
      }
      /**
       * Copies this circle to another one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Circle(100, 100, 50);
       * const target = new Circle();
       * source.copyTo(target);
       * ```
       * @param circle - The circle to copy to
       * @returns Returns given parameter
       * @see {@link Circle.copyFrom} For copying from another circle
       * @see {@link Circle.clone} For creating new circle copy
       */
      copyTo(circle) {
        circle.copyFrom(this);
        return circle;
      }
      toString() {
        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
var Ellipse;
var init_Ellipse = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
    init_Rectangle();
    Ellipse = class _Ellipse {
      /**
       * @param x - The X coordinate of the center of this ellipse
       * @param y - The Y coordinate of the center of this ellipse
       * @param halfWidth - The half width of this ellipse
       * @param halfHeight - The half height of this ellipse
       */
      constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
        this.type = "ellipse";
        this.x = x2;
        this.y = y2;
        this.halfWidth = halfWidth;
        this.halfHeight = halfHeight;
      }
      /**
       * Creates a clone of this Ellipse instance.
       * @example
       * ```ts
       * // Basic cloning
       * const original = new Ellipse(100, 100, 50, 25);
       * const copy = original.clone();
       *
       * // Clone and modify
       * const modified = original.clone();
       * modified.halfWidth *= 2;
       * modified.halfHeight *= 2;
       *
       * // Verify independence
       * console.log(original.halfWidth);  // 50
       * console.log(modified.halfWidth);  // 100
       * ```
       * @returns A copy of the ellipse
       * @see {@link Ellipse.copyFrom} For copying into existing ellipse
       * @see {@link Ellipse.copyTo} For copying to another ellipse
       */
      clone() {
        return new _Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse.
       * Uses normalized coordinates and the ellipse equation to determine containment.
       * @example
       * ```ts
       * // Basic containment check
       * const ellipse = new Ellipse(100, 100, 50, 25);
       * const isInside = ellipse.contains(120, 110);
       * ```
       * @remarks
       * - Uses ellipse equation (x²/a² + y²/b² ≤ 1)
       * - Returns false if dimensions are 0 or negative
       * - Normalized to center (0,0) for calculation
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coords are within this ellipse
       * @see {@link Ellipse.strokeContains} For checking stroke intersection
       * @see {@link Ellipse.getBounds} For getting containing rectangle
       */
      contains(x2, y2) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) {
          return false;
        }
        let normx = (x2 - this.x) / this.halfWidth;
        let normy = (y2 - this.y) / this.halfHeight;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse including stroke.
       * @example
       * ```ts
       * // Basic stroke check
       * const ellipse = new Ellipse(100, 100, 50, 25);
       * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width
       *
       * // Check with different alignments
       * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside
       * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered
       * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside
       * ```
       * @remarks
       * - Uses normalized ellipse equations
       * - Considers stroke alignment
       * - Returns false if dimensions are 0
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
       * @returns Whether the x/y coords are within this ellipse's stroke
       * @see {@link Ellipse.contains} For checking fill containment
       * @see {@link Ellipse.getBounds} For getting stroke bounds
       */
      strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
        const { halfWidth, halfHeight } = this;
        if (halfWidth <= 0 || halfHeight <= 0) {
          return false;
        }
        const strokeOuterWidth = strokeWidth * (1 - alignment);
        const strokeInnerWidth = strokeWidth - strokeOuterWidth;
        const innerHorizontal = halfWidth - strokeInnerWidth;
        const innerVertical = halfHeight - strokeInnerWidth;
        const outerHorizontal = halfWidth + strokeOuterWidth;
        const outerVertical = halfHeight + strokeOuterWidth;
        const normalizedX = x2 - this.x;
        const normalizedY = y2 - this.y;
        const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);
        const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);
        return innerEllipse > 1 && outerEllipse <= 1;
      }
      /**
       * Returns the framing rectangle of the ellipse as a Rectangle object.
       * @example
       * ```ts
       * // Basic bounds calculation
       * const ellipse = new Ellipse(100, 100, 50, 25);
       * const bounds = ellipse.getBounds();
       * // bounds: x=50, y=75, width=100, height=50
       *
       * // Reuse existing rectangle
       * const rect = new Rectangle();
       * ellipse.getBounds(rect);
       * ```
       * @remarks
       * - Creates Rectangle if none provided
       * - Top-left is (x-halfWidth, y-halfHeight)
       * - Width is halfWidth * 2
       * - Height is halfHeight * 2
       * @param out - Optional Rectangle object to store the result
       * @returns The framing rectangle
       * @see {@link Rectangle} For rectangle properties
       * @see {@link Ellipse.contains} For checking if a point is inside
       */
      getBounds(out2) {
        out2 || (out2 = new Rectangle());
        out2.x = this.x - this.halfWidth;
        out2.y = this.y - this.halfHeight;
        out2.width = this.halfWidth * 2;
        out2.height = this.halfHeight * 2;
        return out2;
      }
      /**
       * Copies another ellipse to this one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Ellipse(100, 100, 50, 25);
       * const target = new Ellipse();
       * target.copyFrom(source);
       * ```
       * @param ellipse - The ellipse to copy from
       * @returns Returns itself
       * @see {@link Ellipse.copyTo} For copying to another ellipse
       * @see {@link Ellipse.clone} For creating new ellipse copy
       */
      copyFrom(ellipse) {
        this.x = ellipse.x;
        this.y = ellipse.y;
        this.halfWidth = ellipse.halfWidth;
        this.halfHeight = ellipse.halfHeight;
        return this;
      }
      /**
       * Copies this ellipse to another one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Ellipse(100, 100, 50, 25);
       * const target = new Ellipse();
       * source.copyTo(target);
       * ```
       * @param ellipse - The ellipse to copy to
       * @returns Returns given parameter
       * @see {@link Ellipse.copyFrom} For copying from another ellipse
       * @see {@link Ellipse.clone} For creating new ellipse copy
       */
      copyTo(ellipse) {
        ellipse.copyFrom(this);
        return ellipse;
      }
      toString() {
        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs
function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
  const a2 = x2 - x1;
  const b2 = y2 - y1;
  const c2 = x22 - x1;
  const d2 = y22 - y1;
  const dot = a2 * c2 + b2 * d2;
  const lenSq = c2 * c2 + d2 * d2;
  let param = -1;
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  let xx;
  let yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x22;
    yy = y22;
  } else {
    xx = x1 + param * c2;
    yy = y1 + param * d2;
  }
  const dx = x2 - xx;
  const dy = y2 - yy;
  return dx * dx + dy * dy;
}
var init_squaredDistanceToLineSegment = __esm({
  "node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
var tempRect3, tempRect22, Polygon;
var init_Polygon = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
    init_deprecation();
    init_squaredDistanceToLineSegment();
    init_Rectangle();
    Polygon = class _Polygon {
      /**
       * @param points - This can be an array of Points
       *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
       *  the arguments passed can be all the points of the polygon e.g.
       *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
       *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
       */
      constructor(...points) {
        this.type = "polygon";
        let flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          const p2 = [];
          for (let i2 = 0, il = flat.length; i2 < il; i2++) {
            p2.push(flat[i2].x, flat[i2].y);
          }
          flat = p2;
        }
        this.points = flat;
        this.closePath = true;
      }
      /**
       * Determines whether the polygon's points are arranged in a clockwise direction.
       * Uses the shoelace formula (surveyor's formula) to calculate the signed area.
       *
       * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
       *
       * The formula sums up the cross products of adjacent vertices:
       * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
       * The final sum divided by 2 gives the signed area - positive for clockwise.
       * @example
       * ```ts
       * // Check polygon winding
       * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
       * console.log(polygon.isClockwise()); // Check direction
       *
       * // Use in path construction
       * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);
       * if (hole.isClockwise() === shape.isClockwise()) {
       *     hole.points.reverse(); // Reverse for proper hole winding
       * }
       * ```
       * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
       */
      isClockwise() {
        let area2 = 0;
        const points = this.points;
        const length = points.length;
        for (let i2 = 0; i2 < length; i2 += 2) {
          const x1 = points[i2];
          const y1 = points[i2 + 1];
          const x2 = points[(i2 + 2) % length];
          const y2 = points[(i2 + 3) % length];
          area2 += (x2 - x1) * (y2 + y1);
        }
        return area2 < 0;
      }
      /**
       * Checks if this polygon completely contains another polygon.
       * Used for detecting holes in shapes, like when parsing SVG paths.
       * @example
       * ```ts
       * // Basic containment check
       * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
       * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
       *
       * outerSquare.containsPolygon(innerSquare); // Returns true
       * innerSquare.containsPolygon(outerSquare); // Returns false
       * ```
       * @remarks
       * - Uses bounds check for quick rejection
       * - Tests all points for containment
       * @param polygon - The polygon to test for containment
       * @returns True if this polygon completely contains the other polygon
       * @see {@link Polygon.contains} For single point testing
       * @see {@link Polygon.getBounds} For bounds calculation
       */
      containsPolygon(polygon) {
        const thisBounds = this.getBounds(tempRect3);
        const otherBounds = polygon.getBounds(tempRect22);
        if (!thisBounds.containsRect(otherBounds)) {
          return false;
        }
        const points = polygon.points;
        for (let i2 = 0; i2 < points.length; i2 += 2) {
          const x2 = points[i2];
          const y2 = points[i2 + 1];
          if (!this.contains(x2, y2)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Creates a clone of this polygon.
       * @example
       * ```ts
       * // Basic cloning
       * const original = new Polygon([0, 0, 100, 0, 50, 100]);
       * const copy = original.clone();
       *
       * // Clone and modify
       * const modified = original.clone();
       * modified.points[0] = 10; // Modify first x coordinate
       * ```
       * @returns A copy of the polygon
       * @see {@link Polygon.copyFrom} For copying into existing polygon
       * @see {@link Polygon.copyTo} For copying to another polygon
       */
      clone() {
        const points = this.points.slice();
        const polygon = new _Polygon(points);
        polygon.closePath = this.closePath;
        return polygon;
      }
      /**
       * Checks whether the x and y coordinates passed to this function are contained within this polygon.
       * Uses raycasting algorithm for point-in-polygon testing.
       * @example
       * ```ts
       * // Basic containment check
       * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
       * const isInside = polygon.contains(25, 25); // true
       * ```
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this polygon
       * @see {@link Polygon.strokeContains} For checking stroke intersection
       * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing
       */
      contains(x2, y2) {
        let inside = false;
        const length = this.points.length / 2;
        for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
          const xi = this.points[i2 * 2];
          const yi = this.points[i2 * 2 + 1];
          const xj = this.points[j2 * 2];
          const yj = this.points[j2 * 2 + 1];
          const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
       * @example
       * ```ts
       * // Basic stroke check
       * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
       * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width
       *
       * // Check with different alignments
       * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside
       * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered
       * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside
       * ```
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
       * @returns Whether the x/y coordinates are within this polygon's stroke
       * @see {@link Polygon.contains} For checking fill containment
       * @see {@link Polygon.getBounds} For getting stroke bounds
       */
      strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
        const strokeWidthSquared = strokeWidth * strokeWidth;
        const rightWidthSquared = strokeWidthSquared * (1 - alignment);
        const leftWidthSquared = strokeWidthSquared - rightWidthSquared;
        const { points } = this;
        const iterationLength = points.length - (this.closePath ? 0 : 2);
        for (let i2 = 0; i2 < iterationLength; i2 += 2) {
          const x1 = points[i2];
          const y1 = points[i2 + 1];
          const x22 = points[(i2 + 2) % points.length];
          const y22 = points[(i2 + 3) % points.length];
          const distanceSquared = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
          const sign2 = Math.sign((x22 - x1) * (y2 - y1) - (y22 - y1) * (x2 - x1));
          if (distanceSquared <= (sign2 < 0 ? leftWidthSquared : rightWidthSquared)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Returns the framing rectangle of the polygon as a Rectangle object.
       * @example
       * ```ts
       * // Basic bounds calculation
       * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
       * const bounds = polygon.getBounds();
       * // bounds: x=0, y=0, width=100, height=100
       *
       * // Reuse existing rectangle
       * const rect = new Rectangle();
       * polygon.getBounds(rect);
       * ```
       * @param out - Optional rectangle to store the result
       * @returns The framing rectangle
       * @see {@link Rectangle} For rectangle properties
       * @see {@link Polygon.contains} For checking if a point is inside
       */
      getBounds(out2) {
        out2 || (out2 = new Rectangle());
        const points = this.points;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
          const x2 = points[i2];
          const y2 = points[i2 + 1];
          minX = x2 < minX ? x2 : minX;
          maxX = x2 > maxX ? x2 : maxX;
          minY = y2 < minY ? y2 : minY;
          maxY = y2 > maxY ? y2 : maxY;
        }
        out2.x = minX;
        out2.width = maxX - minX;
        out2.y = minY;
        out2.height = maxY - minY;
        return out2;
      }
      /**
       * Copies another polygon to this one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Polygon([0, 0, 100, 0, 50, 100]);
       * const target = new Polygon();
       * target.copyFrom(source);
       * ```
       * @param polygon - The polygon to copy from
       * @returns Returns itself
       * @see {@link Polygon.copyTo} For copying to another polygon
       * @see {@link Polygon.clone} For creating new polygon copy
       */
      copyFrom(polygon) {
        this.points = polygon.points.slice();
        this.closePath = polygon.closePath;
        return this;
      }
      /**
       * Copies this polygon to another one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new Polygon([0, 0, 100, 0, 50, 100]);
       * const target = new Polygon();
       * source.copyTo(target);
       * ```
       * @param polygon - The polygon to copy to
       * @returns Returns given parameter
       * @see {@link Polygon.copyFrom} For copying from another polygon
       * @see {@link Polygon.clone} For creating new polygon copy
       */
      copyTo(polygon) {
        polygon.copyFrom(this);
        return polygon;
      }
      toString() {
        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
      }
      /**
       * Get the last X coordinate of the polygon.
       * @example
       * ```ts
       * // Basic coordinate access
       * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
       * console.log(polygon.lastX); // 300
       * ```
       * @readonly
       * @returns The x-coordinate of the last vertex
       * @see {@link Polygon.lastY} For last Y coordinate
       * @see {@link Polygon.points} For raw points array
       */
      get lastX() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the last Y coordinate of the polygon.
       * @example
       * ```ts
       * // Basic coordinate access
       * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
       * console.log(polygon.lastY); // 400
       * ```
       * @readonly
       * @returns The y-coordinate of the last vertex
       * @see {@link Polygon.lastX} For last X coordinate
       * @see {@link Polygon.points} For raw points array
       */
      get lastY() {
        return this.points[this.points.length - 1];
      }
      /**
       * Get the last X coordinate of the polygon.
       * @readonly
       * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.
       */
      get x() {
        deprecation("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead.");
        return this.points[this.points.length - 2];
      }
      /**
       * Get the last Y coordinate of the polygon.
       * @readonly
       * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.
       */
      get y() {
        deprecation("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead.");
        return this.points[this.points.length - 1];
      }
      /**
       * Get the first X coordinate of the polygon.
       * @example
       * ```ts
       * // Basic coordinate access
       * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
       * console.log(polygon.x); // 0
       * ```
       * @readonly
       * @returns The x-coordinate of the first vertex
       * @see {@link Polygon.startY} For first Y coordinate
       * @see {@link Polygon.points} For raw points array
       */
      get startX() {
        return this.points[0];
      }
      /**
       * Get the first Y coordinate of the polygon.
       * @example
       * ```ts
       * // Basic coordinate access
       * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
       * console.log(polygon.y); // 0
       * ```
       * @readonly
       * @returns The y-coordinate of the first vertex
       * @see {@link Polygon.startX} For first X coordinate
       * @see {@link Polygon.points} For raw points array
       */
      get startY() {
        return this.points[1];
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
var isCornerWithinStroke, RoundedRectangle;
var init_RoundedRectangle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
    init_Rectangle();
    isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {
      const dx = pX - cornerX;
      const dy = pY - cornerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;
    };
    RoundedRectangle = class _RoundedRectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rounded rectangle
       * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
       * @param width - The overall width of this rounded rectangle
       * @param height - The overall height of this rounded rectangle
       * @param radius - Controls the radius of the rounded corners
       */
      constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
        this.type = "roundedRectangle";
        this.x = x2;
        this.y = y2;
        this.width = width;
        this.height = height;
        this.radius = radius;
      }
      /**
       * Returns the framing rectangle of the rounded rectangle as a Rectangle object
       * @example
       * ```ts
       * // Basic bounds calculation
       * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
       * const bounds = rect.getBounds();
       * // bounds: x=100, y=100, width=200, height=150
       *
       * // Reuse existing rectangle
       * const out = new Rectangle();
       * rect.getBounds(out);
       * ```
       * @remarks
       * - Rectangle matches outer dimensions
       * - Ignores corner radius
       * @param out - Optional rectangle to store the result
       * @returns The framing rectangle
       * @see {@link Rectangle} For rectangle properties
       * @see {@link RoundedRectangle.contains} For checking if a point is inside
       */
      getBounds(out2) {
        out2 || (out2 = new Rectangle());
        out2.x = this.x;
        out2.y = this.y;
        out2.width = this.width;
        out2.height = this.height;
        return out2;
      }
      /**
       * Creates a clone of this Rounded Rectangle.
       * @example
       * ```ts
       * // Basic cloning
       * const original = new RoundedRectangle(100, 100, 200, 150, 20);
       * const copy = original.clone();
       *
       * // Clone and modify
       * const modified = original.clone();
       * modified.radius = 30;
       * modified.width *= 2;
       *
       * // Verify independence
       * console.log(original.radius);  // 20
       * console.log(modified.radius);  // 30
       * ```
       * @returns A copy of the rounded rectangle
       * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle
       * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
       */
      clone() {
        return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
      }
      /**
       * Copies another rectangle to this one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new RoundedRectangle(100, 100, 200, 150, 20);
       * const target = new RoundedRectangle();
       * target.copyFrom(source);
       *
       * // Chain with other operations
       * const rect = new RoundedRectangle()
       *     .copyFrom(source)
       *     .getBounds(rect);
       * ```
       * @param rectangle - The rectangle to copy from
       * @returns Returns itself
       * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
       * @see {@link RoundedRectangle.clone} For creating new rectangle copy
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @example
       * ```ts
       * // Basic copying
       * const source = new RoundedRectangle(100, 100, 200, 150, 20);
       * const target = new RoundedRectangle();
       * source.copyTo(target);
       *
       * // Chain with other operations
       * const result = source
       *     .copyTo(new RoundedRectangle())
       *     .getBounds();
       * ```
       * @param rectangle - The rectangle to copy to
       * @returns Returns given parameter
       * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle
       * @see {@link RoundedRectangle.clone} For creating new rectangle copy
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
       * @example
       * ```ts
       * // Basic containment check
       * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
       * const isInside = rect.contains(150, 125); // true
       * // Check corner radius
       * const corner = rect.contains(100, 100); // false if within corner curve
       * ```
       * @remarks
       * - Returns false if width/height is 0 or negative
       * - Handles rounded corners with radius check
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Rounded Rectangle
       * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection
       * @see {@link RoundedRectangle.getBounds} For getting containing rectangle
       */
      contains(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 <= this.x + this.width) {
          if (y2 >= this.y && y2 <= this.y + this.height) {
            const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
              return true;
            }
            let dx = x2 - (this.x + radius);
            let dy = y2 - (this.y + radius);
            const radius2 = radius * radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + this.width - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y2 - (this.y + this.height - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
       * @example
       * ```ts
       * // Basic stroke check
       * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
       * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
       *
       * // Check with different alignments
       * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
       * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
       * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
       * ```
       * @param pX - The X coordinate of the point to test
       * @param pY - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
       * @returns Whether the x/y coordinates are within this rectangle's stroke
       * @see {@link RoundedRectangle.contains} For checking fill containment
       * @see {@link RoundedRectangle.getBounds} For getting stroke bounds
       */
      strokeContains(pX, pY, strokeWidth, alignment = 0.5) {
        const { x: x2, y: y2, width, height, radius } = this;
        const strokeWidthOuter = strokeWidth * (1 - alignment);
        const strokeWidthInner = strokeWidth - strokeWidthOuter;
        const innerX = x2 + radius;
        const innerY = y2 + radius;
        const innerWidth = width - radius * 2;
        const innerHeight = height - radius * 2;
        const rightBound = x2 + width;
        const bottomBound = y2 + height;
        if ((pX >= x2 - strokeWidthOuter && pX <= x2 + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {
          return true;
        }
        if ((pY >= y2 - strokeWidthOuter && pY <= y2 + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {
          return true;
        }
        return (
          // Top-left
          pX < innerX && pY < innerY && isCornerWithinStroke(
            pX,
            pY,
            innerX,
            innerY,
            radius,
            strokeWidthInner,
            strokeWidthOuter
          ) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(
            pX,
            pY,
            rightBound - radius,
            innerY,
            radius,
            strokeWidthInner,
            strokeWidthOuter
          ) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(
            pX,
            pY,
            rightBound - radius,
            bottomBound - radius,
            radius,
            strokeWidthInner,
            strokeWidthOuter
          ) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(
            pX,
            pY,
            innerX,
            bottomBound - radius,
            radius,
            strokeWidthInner,
            strokeWidthOuter
          )
        );
      }
      toString() {
        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    let da1;
    let da2;
    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        const a23 = Math.atan2(y3 - y2, x3 - x2);
        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da2 >= pi)
          da2 = 2 * pi - da2;
        if (da1 + da2 < mAngleTolerance) {
          points.push(x1234, y1234);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
          if (da2 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else if (d2 > FLT_EPSILON) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
        }
      }
    } else if (d3 > FLT_EPSILON) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}
var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
var init_buildAdaptiveBezier = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
    init_GraphicsContextSystem();
    RECURSION_LIMIT = 8;
    FLT_EPSILON = 11920929e-14;
    PATH_DISTANCE_EPSILON = 1;
    curveAngleToleranceEpsilon = 0.01;
    mAngleTolerance = 0;
    mCuspLimit = 0;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
  if (level > RECURSION_LIMIT2) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
  if (d2 > FLT_EPSILON2) {
    if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
      if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
        points.push(x123, y123);
        return;
      }
      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
      if (da >= pi)
        da = 2 * pi - da;
      if (da < mAngleTolerance2) {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}
var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
var init_buildAdaptiveQuadratic = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
    init_GraphicsContextSystem();
    RECURSION_LIMIT2 = 8;
    FLT_EPSILON2 = 11920929e-14;
    PATH_DISTANCE_EPSILON2 = 1;
    curveAngleToleranceEpsilon2 = 0.01;
    mAngleTolerance2 = 0;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
function buildArc(points, x2, y2, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));
  steps = Math.max(steps, 3);
  let f2 = dist / steps;
  let t2 = start;
  f2 *= clockwise ? -1 : 1;
  for (let i2 = 0; i2 < steps + 1; i2++) {
    const cs = Math.cos(t2);
    const sn = Math.sin(t2);
    const nx = x2 + cs * radius;
    const ny = y2 + sn * radius;
    points.push(nx, ny);
    t2 += f2;
  }
}
var init_buildArc = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
function buildArcTo(points, x1, y1, x2, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b2 = x2 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a2);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b2 * b2;
  const tt = a1 * a2 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k2 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j2 = k2 * tt / cc;
  const cx = k1 * b2 + k2 * b1;
  const cy = k1 * a2 + k2 * a1;
  const px = b1 * (k2 + j1);
  const py = a1 * (k2 + j1);
  const qx = b2 * (k1 + j2);
  const qy = a2 * (k1 + j2);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a2 > b2 * a1
  );
}
var init_buildArcTo = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
    init_buildArc();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x2 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a2,
      y: y1 + x1 * a2
    },
    {
      x: x2 + y2 * a2,
      y: y2 - x2 * a2
    },
    {
      x: x2,
      y: y2
    }
  ];
}
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out
  );
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i2 = 0; i2 < segments; i2++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x2,
      y2,
      x3,
      y3
    );
    lastX = x3;
    lastY = y3;
    ang1 += ang2;
  }
}
var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
var init_buildArcToSvg = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
    init_buildAdaptiveBezier();
    TAU = Math.PI * 2;
    out = {
      centerX: 0,
      centerY: 0,
      ang1: 0,
      ang2: 0
    };
    mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
      x2 *= rx;
      y2 *= ry;
      const xp = cosPhi * x2 - sinPhi * y2;
      const yp = sinPhi * x2 + cosPhi * y2;
      out2.x = xp + centerX;
      out2.y = yp + centerY;
      return out2;
    };
    vectorAngle = (ux2, uy2, vx2, vy2) => {
      const sign2 = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
      let dot = ux2 * vx2 + uy2 * vy2;
      if (dot > 1) {
        dot = 1;
      }
      if (dot < -1) {
        dot = -1;
      }
      return sign2 * Math.acos(dot);
    };
    getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
      const rxSq = Math.pow(rx, 2);
      const rySq = Math.pow(ry, 2);
      const pxpSq = Math.pow(pxp, 2);
      const pypSq = Math.pow(pyp, 2);
      let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
      if (radicant < 0) {
        radicant = 0;
      }
      radicant /= rxSq * pypSq + rySq * pxpSq;
      radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
      const centerXp = radicant * rx / ry * pyp;
      const centerYp = radicant * -ry / rx * pxp;
      const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
      const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
      const vx1 = (pxp - centerXp) / rx;
      const vy1 = (pyp - centerYp) / ry;
      const vx2 = (-pxp - centerXp) / rx;
      const vy2 = (-pyp - centerYp) / ry;
      const ang1 = vectorAngle(1, 0, vx1, vy1);
      let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
      if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
      }
      if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
      }
      out2.centerX = centerX;
      out2.centerY = centerY;
      out2.ang1 = ang1;
      out2.ang2 = ang2;
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs
function roundedShapeArc(g2, points, radius) {
  const vecFrom = (p2, pp) => {
    const x2 = pp.x - p2.x;
    const y2 = pp.y - p2.y;
    const len = Math.sqrt(x2 * x2 + y2 * y2);
    const nx = x2 / len;
    const ny = y2 / len;
    return { len, nx, ny };
  };
  const sharpCorner = (i2, p2) => {
    if (i2 === 0) {
      g2.moveTo(p2.x, p2.y);
    } else {
      g2.lineTo(p2.x, p2.y);
    }
  };
  let p1 = points[points.length - 1];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p2 = points[i2 % points.length];
    const pRadius = p2.radius ?? radius;
    if (pRadius <= 0) {
      sharpCorner(i2, p2);
      p1 = p2;
      continue;
    }
    const p3 = points[(i2 + 1) % points.length];
    const v1 = vecFrom(p2, p1);
    const v2 = vecFrom(p2, p3);
    if (v1.len < 1e-4 || v2.len < 1e-4) {
      sharpCorner(i2, p2);
      p1 = p2;
      continue;
    }
    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
    let radDirection = 1;
    let drawDirection = false;
    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else if (angle > 0) {
      radDirection = -1;
      drawDirection = true;
    }
    const halfAngle = angle / 2;
    let cRadius;
    let lenOut = Math.abs(
      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
    );
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = pRadius;
    }
    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
    if (i2 === 0) {
      g2.moveTo(
        cX + Math.cos(startAngle) * cRadius,
        cY + Math.sin(startAngle) * cRadius
      );
    }
    g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
    p1 = p2;
  }
}
function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  const pointLerp = (p1, p2, t2) => ({
    x: p1.x + (p2.x - p1.x) * t2,
    y: p1.y + (p2.y - p1.y) * t2
  });
  const numPoints = points.length;
  for (let i2 = 0; i2 < numPoints; i2++) {
    const thisPoint = points[(i2 + 1) % numPoints];
    const pRadius = thisPoint.radius ?? radius;
    if (pRadius <= 0) {
      if (i2 === 0) {
        g2.moveTo(thisPoint.x, thisPoint.y);
      } else {
        g2.lineTo(thisPoint.x, thisPoint.y);
      }
      continue;
    }
    const lastPoint = points[i2];
    const nextPoint = points[(i2 + 2) % numPoints];
    const lastEdgeLength = distance(lastPoint, thisPoint);
    let start;
    if (lastEdgeLength < 1e-4) {
      start = thisPoint;
    } else {
      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
      start = pointLerp(
        thisPoint,
        lastPoint,
        lastOffsetDistance / lastEdgeLength
      );
    }
    const nextEdgeLength = distance(nextPoint, thisPoint);
    let end;
    if (nextEdgeLength < 1e-4) {
      end = thisPoint;
    } else {
      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
      end = pointLerp(
        thisPoint,
        nextPoint,
        nextOffsetDistance / nextEdgeLength
      );
    }
    if (i2 === 0) {
      g2.moveTo(start.x, start.y);
    } else {
      g2.lineTo(start.x, start.y);
    }
    g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
  }
}
var init_roundShape = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
var tempRectangle, ShapePath;
var init_ShapePath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
    init_Circle();
    init_Ellipse();
    init_Polygon();
    init_Rectangle();
    init_RoundedRectangle();
    init_Bounds();
    init_buildAdaptiveBezier();
    init_buildAdaptiveQuadratic();
    init_buildArc();
    init_buildArcTo();
    init_buildArcToSvg();
    init_roundShape();
    tempRectangle = new Rectangle();
    ShapePath = class {
      constructor(graphicsPath2D) {
        this.shapePrimitives = [];
        this._currentPoly = null;
        this._bounds = new Bounds();
        this._graphicsPath2D = graphicsPath2D;
        this.signed = graphicsPath2D.checkForHoles;
      }
      /**
       * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
       * @param x - The x-coordinate for the starting point.
       * @param y - The y-coordinate for the starting point.
       * @returns The instance of the current object for chaining.
       */
      moveTo(x2, y2) {
        this.startPoly(x2, y2);
        return this;
      }
      /**
       * Connects the current point to a new point with a straight line. This method updates the current path.
       * @param x - The x-coordinate of the new point to connect to.
       * @param y - The y-coordinate of the new point to connect to.
       * @returns The instance of the current object for chaining.
       */
      lineTo(x2, y2) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        if (fromX !== x2 || fromY !== y2) {
          points.push(x2, y2);
        }
        return this;
      }
      /**
       * Adds an arc to the path. The arc is centered at (x, y)
       *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
       * @param x - The x-coordinate of the arc's center.
       * @param y - The y-coordinate of the arc's center.
       * @param radius - The radius of the arc.
       * @param startAngle - The starting angle of the arc, in radians.
       * @param endAngle - The ending angle of the arc, in radians.
       * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
       * @returns The instance of the current object for chaining.
       */
      arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
        this._ensurePoly(false);
        const points = this._currentPoly.points;
        buildArc(points, x2, y2, radius, startAngle, endAngle, counterclockwise);
        return this;
      }
      /**
       * Adds an arc to the path with the arc tangent to the line joining two specified points.
       * The arc radius is specified by `radius`.
       * @param x1 - The x-coordinate of the first point.
       * @param y1 - The y-coordinate of the first point.
       * @param x2 - The x-coordinate of the second point.
       * @param y2 - The y-coordinate of the second point.
       * @param radius - The radius of the arc.
       * @returns The instance of the current object for chaining.
       */
      arcTo(x1, y1, x2, y2, radius) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        buildArcTo(points, x1, y1, x2, y2, radius);
        return this;
      }
      /**
       * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
       * @param rx - The x-radius of the ellipse.
       * @param ry - The y-radius of the ellipse.
       * @param xAxisRotation - The rotation of the ellipse's x-axis relative
       * to the x-axis of the coordinate system, in degrees.
       * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
       * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
       * @param x - The x-coordinate of the arc's end point.
       * @param y - The y-coordinate of the arc's end point.
       * @returns The instance of the current object for chaining.
       */
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
        const points = this._currentPoly.points;
        buildArcToSvg(
          points,
          this._currentPoly.lastX,
          this._currentPoly.lastY,
          x2,
          y2,
          rx,
          ry,
          xAxisRotation,
          largeArcFlag,
          sweepFlag
        );
        return this;
      }
      /**
       * Adds a cubic Bezier curve to the path.
       * It requires three points: the first two are control points and the third one is the end point.
       * The starting point is the last point in the current path.
       * @param cp1x - The x-coordinate of the first control point.
       * @param cp1y - The y-coordinate of the first control point.
       * @param cp2x - The x-coordinate of the second control point.
       * @param cp2y - The y-coordinate of the second control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveBezier(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          cp2x,
          cp2y,
          x2,
          y2,
          smoothness
        );
        return this;
      }
      /**
       * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
       * The starting point is the last point in the current path.
       * @param cp1x - The x-coordinate of the control point.
       * @param cp1y - The y-coordinate of the control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothing - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveQuadratic(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          x2,
          y2,
          smoothing
        );
        return this;
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        this.endPoly(true);
        return this;
      }
      /**
       * Adds another path to the current path. This method allows for the combination of multiple paths into one.
       * @param path - The `GraphicsPath` object representing the path to add.
       * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
       * @returns The instance of the current object for chaining.
       */
      addPath(path2, transform) {
        this.endPoly();
        if (transform && !transform.isIdentity()) {
          path2 = path2.clone(true);
          path2.transform(transform);
        }
        const shapePrimitives = this.shapePrimitives;
        const start = shapePrimitives.length;
        for (let i2 = 0; i2 < path2.instructions.length; i2++) {
          const instruction = path2.instructions[i2];
          this[instruction.action](...instruction.data);
        }
        if (path2.checkForHoles && shapePrimitives.length - start > 1) {
          let mainShape = null;
          for (let i2 = start; i2 < shapePrimitives.length; i2++) {
            const shapePrimitive = shapePrimitives[i2];
            if (shapePrimitive.shape.type === "polygon") {
              const polygon = shapePrimitive.shape;
              const mainPolygon = mainShape?.shape;
              if (mainPolygon && mainPolygon.containsPolygon(polygon)) {
                mainShape.holes || (mainShape.holes = []);
                mainShape.holes.push(shapePrimitive);
                shapePrimitives.copyWithin(i2, i2 + 1);
                shapePrimitives.length--;
                i2--;
              } else {
                mainShape = shapePrimitive;
              }
            }
          }
        }
        return this;
      }
      /**
       * Finalizes the drawing of the current path. Optionally, it can close the path.
       * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
       */
      finish(closePath = false) {
        this.endPoly(closePath);
      }
      /**
       * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
       * @returns The instance of the current object for chaining.
       */
      rect(x2, y2, w2, h2, transform) {
        this.drawShape(new Rectangle(x2, y2, w2, h2), transform);
        return this;
      }
      /**
       * Draws a circle shape. This method adds a new circle path to the current drawing.
       * @param x - The x-coordinate of the center of the circle.
       * @param y - The y-coordinate of the center of the circle.
       * @param radius - The radius of the circle.
       * @param transform - An optional `Matrix` object to apply a transformation to the circle.
       * @returns The instance of the current object for chaining.
       */
      circle(x2, y2, radius, transform) {
        this.drawShape(new Circle(x2, y2, radius), transform);
        return this;
      }
      /**
       * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
       * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
       * representing the x and y coordinates of the polygon's vertices, in sequence.
       * @param close - A boolean indicating whether to close the polygon path. True by default.
       * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
       * @returns The instance of the current object for chaining.
       */
      poly(points, close, transform) {
        const polygon = new Polygon(points);
        polygon.closePath = close;
        this.drawShape(polygon, transform);
        return this;
      }
      /**
       * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
       * @returns The instance of the current object for chaining.
       */
      regularPoly(x2, y2, radius, sides, rotation = 0, transform) {
        sides = Math.max(sides | 0, 3);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const delta = Math.PI * 2 / sides;
        const polygon = [];
        for (let i2 = 0; i2 < sides; i2++) {
          const angle = startAngle - i2 * delta;
          polygon.push(
            x2 + radius * Math.cos(angle),
            y2 + radius * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform);
        return this;
      }
      /**
       * Draws a polygon with rounded corners.
       * Similar to `regularPoly` but with the ability to round the corners of the polygon.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param corner - The radius of the rounding of the corners.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
       * @returns The instance of the current object for chaining.
       */
      roundPoly(x2, y2, radius, sides, corner, rotation = 0, smoothness) {
        sides = Math.max(sides | 0, 3);
        if (corner <= 0) {
          return this.regularPoly(x2, y2, radius, sides, rotation);
        }
        const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
        corner = Math.min(corner, sideLength);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const delta = Math.PI * 2 / sides;
        const internalAngle = (sides - 2) * Math.PI / sides / 2;
        for (let i2 = 0; i2 < sides; i2++) {
          const angle = i2 * delta + startAngle;
          const x0 = x2 + radius * Math.cos(angle);
          const y0 = y2 + radius * Math.sin(angle);
          const a1 = angle + Math.PI + internalAngle;
          const a2 = angle - Math.PI - internalAngle;
          const x1 = x0 + corner * Math.cos(a1);
          const y1 = y0 + corner * Math.sin(a1);
          const x3 = x0 + corner * Math.cos(a2);
          const y3 = y0 + corner * Math.sin(a2);
          if (i2 === 0) {
            this.moveTo(x1, y1);
          } else {
            this.lineTo(x1, y1);
          }
          this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
        }
        return this.closePath();
      }
      /**
       * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
       * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
       * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
       * A minimum of 3 points is required.
       * @param radius - The default radius for the corners.
       * This radius is applied to all corners unless overridden in `points`.
       * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
       *  method instead of an arc method. Defaults to false.
       * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
       * Higher values make the curve smoother.
       * @returns The instance of the current object for chaining.
       */
      roundShape(points, radius, useQuadratic = false, smoothness) {
        if (points.length < 3) {
          return this;
        }
        if (useQuadratic) {
          roundedShapeQuadraticCurve(this, points, radius, smoothness);
        } else {
          roundedShapeArc(this, points, radius);
        }
        return this.closePath();
      }
      /**
       * Draw Rectangle with fillet corners. This is much like rounded rectangle
       * however it support negative numbers as well for the corner radius.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param fillet - accept negative or positive values
       */
      filletRect(x2, y2, width, height, fillet) {
        if (fillet === 0) {
          return this.rect(x2, y2, width, height);
        }
        const maxFillet = Math.min(width, height) / 2;
        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
        const right = x2 + width;
        const bottom = y2 + height;
        const dir = inset < 0 ? -inset : 0;
        const size = Math.abs(inset);
        return this.moveTo(x2, y2 + size).arcTo(x2 + dir, y2 + dir, x2 + size, y2, size).lineTo(right - size, y2).arcTo(right - dir, y2 + dir, right, y2 + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x2 + width - size, bottom, size).lineTo(x2 + size, bottom).arcTo(x2 + dir, bottom - dir, x2, bottom - size, size).closePath();
      }
      /**
       * Draw Rectangle with chamfer corners. These are angled corners.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param chamfer - non-zero real number, size of corner cutout
       * @param transform
       */
      chamferRect(x2, y2, width, height, chamfer, transform) {
        if (chamfer <= 0) {
          return this.rect(x2, y2, width, height);
        }
        const inset = Math.min(chamfer, Math.min(width, height) / 2);
        const right = x2 + width;
        const bottom = y2 + height;
        const points = [
          x2 + inset,
          y2,
          right - inset,
          y2,
          right,
          y2 + inset,
          right,
          bottom - inset,
          right - inset,
          bottom,
          x2 + inset,
          bottom,
          x2,
          bottom - inset,
          x2,
          y2 + inset
        ];
        for (let i2 = points.length - 1; i2 >= 2; i2 -= 2) {
          if (points[i2] === points[i2 - 2] && points[i2 - 1] === points[i2 - 3]) {
            points.splice(i2 - 1, 2);
          }
        }
        return this.poly(points, true, transform);
      }
      /**
       * Draws an ellipse at the specified location and with the given x and y radii.
       * An optional transformation can be applied, allowing for rotation, scaling, and translation.
       * @param x - The x-coordinate of the center of the ellipse.
       * @param y - The y-coordinate of the center of the ellipse.
       * @param radiusX - The horizontal radius of the ellipse.
       * @param radiusY - The vertical radius of the ellipse.
       * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
       * @returns The instance of the current object for chaining.
       */
      ellipse(x2, y2, radiusX, radiusY, transform) {
        this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform);
        return this;
      }
      /**
       * Draws a rectangle with rounded corners.
       * The corner radius can be specified to determine how rounded the corners should be.
       * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
       * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
       * @returns The instance of the current object for chaining.
       */
      roundRect(x2, y2, w2, h2, radius, transform) {
        this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radius), transform);
        return this;
      }
      /**
       * Draws a given shape on the canvas.
       * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
       * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
       * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
       * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
       * scaling, and translations.
       * @returns The instance of the current object for chaining.
       */
      drawShape(shape, matrix) {
        this.endPoly();
        this.shapePrimitives.push({ shape, transform: matrix });
        return this;
      }
      /**
       * Starts a new polygon path from the specified starting point.
       * This method initializes a new polygon or ends the current one if it exists.
       * @param x - The x-coordinate of the starting point of the new polygon.
       * @param y - The y-coordinate of the starting point of the new polygon.
       * @returns The instance of the current object for chaining.
       */
      startPoly(x2, y2) {
        let currentPoly = this._currentPoly;
        if (currentPoly) {
          this.endPoly();
        }
        currentPoly = new Polygon();
        currentPoly.points.push(x2, y2);
        this._currentPoly = currentPoly;
        return this;
      }
      /**
       * Ends the current polygon path. If `closePath` is set to true,
       * the path is closed by connecting the last point to the first one.
       * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
       * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
       *  back to the starting point. False by default.
       * @returns The instance of the current object for chaining.
       */
      endPoly(closePath = false) {
        const shape = this._currentPoly;
        if (shape && shape.points.length > 2) {
          shape.closePath = closePath;
          this.shapePrimitives.push({ shape });
        }
        this._currentPoly = null;
        return this;
      }
      _ensurePoly(start = true) {
        if (this._currentPoly)
          return;
        this._currentPoly = new Polygon();
        if (start) {
          const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
          if (lastShape) {
            let lx = lastShape.shape.x;
            let ly = lastShape.shape.y;
            if (lastShape.transform && !lastShape.transform.isIdentity()) {
              const t2 = lastShape.transform;
              const tempX = lx;
              lx = t2.a * lx + t2.c * ly + t2.tx;
              ly = t2.b * tempX + t2.d * ly + t2.ty;
            }
            this._currentPoly.points.push(lx, ly);
          } else {
            this._currentPoly.points.push(0, 0);
          }
        }
      }
      /** Builds the path. */
      buildPath() {
        const path2 = this._graphicsPath2D;
        this.shapePrimitives.length = 0;
        this._currentPoly = null;
        for (let i2 = 0; i2 < path2.instructions.length; i2++) {
          const instruction = path2.instructions[i2];
          this[instruction.action](...instruction.data);
        }
        this.finish();
      }
      /** Gets the bounds of the path. */
      get bounds() {
        const bounds = this._bounds;
        bounds.clear();
        const shapePrimitives = this.shapePrimitives;
        for (let i2 = 0; i2 < shapePrimitives.length; i2++) {
          const shapePrimitive = shapePrimitives[i2];
          const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
          if (shapePrimitive.transform) {
            bounds.addRect(boundsRect, shapePrimitive.transform);
          } else {
            bounds.addRect(boundsRect);
          }
        }
        return bounds;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
function adjustTransform(currentMatrix, transform) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform);
  }
  return transform.clone();
}
var GraphicsPath;
var init_GraphicsPath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
    init_Point();
    init_uid();
    init_warn();
    init_parseSVGPath();
    init_ShapePath();
    GraphicsPath = class _GraphicsPath {
      /**
       * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
       * @param instructions - An SVG path string or an array of `PathInstruction` objects.
       * @param signed
       */
      constructor(instructions, signed = false) {
        this.instructions = [];
        this.uid = uid("graphicsPath");
        this._dirty = true;
        this.checkForHoles = signed;
        if (typeof instructions === "string") {
          parseSVGPath(instructions, this);
        } else {
          this.instructions = instructions?.slice() ?? [];
        }
      }
      /**
       * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
       * @returns The `ShapePath` instance associated with this `GraphicsPath`.
       */
      get shapePath() {
        if (!this._shapePath) {
          this._shapePath = new ShapePath(this);
        }
        if (this._dirty) {
          this._dirty = false;
          this._shapePath.buildPath();
        }
        return this._shapePath;
      }
      /**
       * Adds another `GraphicsPath` to this path, optionally applying a transformation.
       * @param path - The `GraphicsPath` to add.
       * @param transform - An optional transformation to apply to the added path.
       * @returns The instance of the current object for chaining.
       */
      addPath(path2, transform) {
        path2 = path2.clone();
        this.instructions.push({ action: "addPath", data: [path2, transform] });
        this._dirty = true;
        return this;
      }
      arc(...args) {
        this.instructions.push({ action: "arc", data: args });
        this._dirty = true;
        return this;
      }
      arcTo(...args) {
        this.instructions.push({ action: "arcTo", data: args });
        this._dirty = true;
        return this;
      }
      arcToSvg(...args) {
        this.instructions.push({ action: "arcToSvg", data: args });
        this._dirty = true;
        return this;
      }
      bezierCurveTo(...args) {
        this.instructions.push({ action: "bezierCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      /**
       * Adds a cubic Bezier curve to the path.
       * It requires two points: the second control point and the end point. The first control point is assumed to be
       * The starting point is the last point in the current path.
       * @param cp2x - The x-coordinate of the second control point.
       * @param cp2y - The y-coordinate of the second control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(Point.shared);
        let cp1x = 0;
        let cp1y = 0;
        if (!last || last.action !== "bezierCurveTo") {
          cp1x = lastPoint.x;
          cp1y = lastPoint.y;
        } else {
          cp1x = last.data[2];
          cp1y = last.data[3];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cp1x = currentX + (currentX - cp1x);
          cp1y = currentY + (currentY - cp1y);
        }
        this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness] });
        this._dirty = true;
        return this;
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        this.instructions.push({ action: "closePath", data: [] });
        this._dirty = true;
        return this;
      }
      ellipse(...args) {
        this.instructions.push({ action: "ellipse", data: args });
        this._dirty = true;
        return this;
      }
      lineTo(...args) {
        this.instructions.push({ action: "lineTo", data: args });
        this._dirty = true;
        return this;
      }
      moveTo(...args) {
        this.instructions.push({ action: "moveTo", data: args });
        return this;
      }
      quadraticCurveTo(...args) {
        this.instructions.push({ action: "quadraticCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      /**
       * Adds a quadratic curve to the path. It uses the previous point as the control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      quadraticCurveToShort(x2, y2, smoothness) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(Point.shared);
        let cpx1 = 0;
        let cpy1 = 0;
        if (!last || last.action !== "quadraticCurveTo") {
          cpx1 = lastPoint.x;
          cpy1 = lastPoint.y;
        } else {
          cpx1 = last.data[0];
          cpy1 = last.data[1];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cpx1 = currentX + (currentX - cpx1);
          cpy1 = currentY + (currentY - cpy1);
        }
        this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness] });
        this._dirty = true;
        return this;
      }
      /**
       * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
       * @returns The instance of the current object for chaining.
       */
      rect(x2, y2, w2, h2, transform) {
        this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform] });
        this._dirty = true;
        return this;
      }
      /**
       * Draws a circle shape. This method adds a new circle path to the current drawing.
       * @param x - The x-coordinate of the center of the circle.
       * @param y - The y-coordinate of the center of the circle.
       * @param radius - The radius of the circle.
       * @param transform - An optional `Matrix` object to apply a transformation to the circle.
       * @returns The instance of the current object for chaining.
       */
      circle(x2, y2, radius, transform) {
        this.instructions.push({ action: "circle", data: [x2, y2, radius, transform] });
        this._dirty = true;
        return this;
      }
      roundRect(...args) {
        this.instructions.push({ action: "roundRect", data: args });
        this._dirty = true;
        return this;
      }
      poly(...args) {
        this.instructions.push({ action: "poly", data: args });
        this._dirty = true;
        return this;
      }
      regularPoly(...args) {
        this.instructions.push({ action: "regularPoly", data: args });
        this._dirty = true;
        return this;
      }
      roundPoly(...args) {
        this.instructions.push({ action: "roundPoly", data: args });
        this._dirty = true;
        return this;
      }
      roundShape(...args) {
        this.instructions.push({ action: "roundShape", data: args });
        this._dirty = true;
        return this;
      }
      filletRect(...args) {
        this.instructions.push({ action: "filletRect", data: args });
        this._dirty = true;
        return this;
      }
      chamferRect(...args) {
        this.instructions.push({ action: "chamferRect", data: args });
        this._dirty = true;
        return this;
      }
      /**
       * Draws a star shape centered at a specified location. This method allows for the creation
       *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
       * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
       * An optional transformation can be applied to scale, rotate, or translate the star as needed.
       * @param x - The x-coordinate of the center of the star.
       * @param y - The y-coordinate of the center of the star.
       * @param points - The number of points of the star.
       * @param radius - The outer radius of the star (distance from the center to the outer points).
       * @param innerRadius - Optional. The inner radius of the star
       * (distance from the center to the inner points between the outer points).
       * If not provided, defaults to half of the `radius`.
       * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
       * Defaults to 0, meaning one point is directly upward.
       * @param transform - An optional `Matrix` object to apply a transformation to the star.
       * This can include rotations, scaling, and translations.
       * @returns The instance of the current object for chaining further drawing commands.
       */
      // eslint-disable-next-line max-len
      star(x2, y2, points, radius, innerRadius, rotation, transform) {
        innerRadius || (innerRadius = radius / 2);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const len = points * 2;
        const delta = Math.PI * 2 / len;
        const polygon = [];
        for (let i2 = 0; i2 < len; i2++) {
          const r2 = i2 % 2 ? innerRadius : radius;
          const angle = i2 * delta + startAngle;
          polygon.push(
            x2 + r2 * Math.cos(angle),
            y2 + r2 * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform);
        return this;
      }
      /**
       * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
       * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
       * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
       * do not affect the original `GraphicsPath` and vice versa.
       * @param deep - A boolean flag indicating whether the clone should be deep.
       * @returns A new `GraphicsPath` instance that is a clone of the current instance.
       */
      clone(deep = false) {
        const newGraphicsPath2D = new _GraphicsPath();
        newGraphicsPath2D.checkForHoles = this.checkForHoles;
        if (!deep) {
          newGraphicsPath2D.instructions = this.instructions.slice();
        } else {
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
          }
        }
        return newGraphicsPath2D;
      }
      clear() {
        this.instructions.length = 0;
        this._dirty = true;
        return this;
      }
      /**
       * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
       * This method enables the modification of the path's geometry according to the provided
       * transformation matrix, which can include translations, rotations, scaling, and skewing.
       *
       * Each drawing instruction in the path is updated to reflect the transformation,
       * ensuring the visual representation of the path is consistent with the applied matrix.
       *
       * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
       * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
       * allowing for fine-grained control over the path's appearance.
       * @param matrix - A `Matrix` object representing the transformation to apply.
       * @returns The instance of the current object for chaining further operations.
       */
      transform(matrix) {
        if (matrix.isIdentity())
          return this;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d2 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let x2 = 0;
        let y2 = 0;
        let cpx1 = 0;
        let cpy1 = 0;
        let cpx2 = 0;
        let cpy2 = 0;
        let rx = 0;
        let ry = 0;
        for (let i2 = 0; i2 < this.instructions.length; i2++) {
          const instruction = this.instructions[i2];
          const data = instruction.data;
          switch (instruction.action) {
            case "moveTo":
            case "lineTo":
              x2 = data[0];
              y2 = data[1];
              data[0] = a2 * x2 + c2 * y2 + tx;
              data[1] = b2 * x2 + d2 * y2 + ty;
              break;
            case "bezierCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              cpx2 = data[2];
              cpy2 = data[3];
              x2 = data[4];
              y2 = data[5];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b2 * cpx1 + d2 * cpy1 + ty;
              data[2] = a2 * cpx2 + c2 * cpy2 + tx;
              data[3] = b2 * cpx2 + d2 * cpy2 + ty;
              data[4] = a2 * x2 + c2 * y2 + tx;
              data[5] = b2 * x2 + d2 * y2 + ty;
              break;
            case "quadraticCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              x2 = data[2];
              y2 = data[3];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b2 * cpx1 + d2 * cpy1 + ty;
              data[2] = a2 * x2 + c2 * y2 + tx;
              data[3] = b2 * x2 + d2 * y2 + ty;
              break;
            case "arcToSvg":
              x2 = data[5];
              y2 = data[6];
              rx = data[0];
              ry = data[1];
              data[0] = a2 * rx + c2 * ry;
              data[1] = b2 * rx + d2 * ry;
              data[5] = a2 * x2 + c2 * y2 + tx;
              data[6] = b2 * x2 + d2 * y2 + ty;
              break;
            case "circle":
              data[4] = adjustTransform(data[3], matrix);
              break;
            case "rect":
              data[4] = adjustTransform(data[4], matrix);
              break;
            case "ellipse":
              data[8] = adjustTransform(data[8], matrix);
              break;
            case "roundRect":
              data[5] = adjustTransform(data[5], matrix);
              break;
            case "addPath":
              data[0].transform(matrix);
              break;
            case "poly":
              data[2] = adjustTransform(data[2], matrix);
              break;
            default:
              warn("unknown transform action", instruction.action);
              break;
          }
        }
        this._dirty = true;
        return this;
      }
      get bounds() {
        return this.shapePath.bounds;
      }
      /**
       * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
       * This method is useful for operations that depend on the path's current endpoint,
       * such as connecting subsequent shapes or paths. It supports various drawing instructions,
       * ensuring the last point's position is accurately determined regardless of the path's complexity.
       *
       * If the last instruction is a `closePath`, the method iterates backward through the instructions
       *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
       * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
       * the last point from the nested path.
       * @param out - A `Point` object where the last point's coordinates will be stored.
       * This object is modified directly to contain the result.
       * @returns The `Point` object containing the last point's coordinates.
       */
      getLastPoint(out2) {
        let index = this.instructions.length - 1;
        let lastInstruction = this.instructions[index];
        if (!lastInstruction) {
          out2.x = 0;
          out2.y = 0;
          return out2;
        }
        while (lastInstruction.action === "closePath") {
          index--;
          if (index < 0) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          lastInstruction = this.instructions[index];
        }
        switch (lastInstruction.action) {
          case "moveTo":
          case "lineTo":
            out2.x = lastInstruction.data[0];
            out2.y = lastInstruction.data[1];
            break;
          case "quadraticCurveTo":
            out2.x = lastInstruction.data[2];
            out2.y = lastInstruction.data[3];
            break;
          case "bezierCurveTo":
            out2.x = lastInstruction.data[4];
            out2.y = lastInstruction.data[5];
            break;
          case "arc":
          case "arcToSvg":
            out2.x = lastInstruction.data[5];
            out2.y = lastInstruction.data[6];
            break;
          case "addPath":
            lastInstruction.data[0].getLastPoint(out2);
            break;
        }
        return out2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs
function parseSVGFloatAttribute(svg, id, defaultValue2) {
  const value = svg.getAttribute(id);
  return value ? Number(value) : defaultValue2;
}
var init_parseSVGFloatAttribute = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs
function parseSVGDefinitions(svg, session) {
  const definitions = svg.querySelectorAll("defs");
  for (let i2 = 0; i2 < definitions.length; i2++) {
    const definition = definitions[i2];
    for (let j2 = 0; j2 < definition.children.length; j2++) {
      const child = definition.children[j2];
      switch (child.nodeName.toLowerCase()) {
        case "lineargradient":
          session.defs[child.id] = parseLinearGradient(child);
          break;
        case "radialgradient":
          session.defs[child.id] = parseRadialGradient(child);
          break;
        default:
          break;
      }
    }
  }
}
function parseLinearGradient(child) {
  const x0 = parseSVGFloatAttribute(child, "x1", 0);
  const y0 = parseSVGFloatAttribute(child, "y1", 0);
  const x1 = parseSVGFloatAttribute(child, "x2", 1);
  const y1 = parseSVGFloatAttribute(child, "y2", 0);
  const gradientUnit = child.getAttribute("gradientUnits") || "objectBoundingBox";
  const gradient = new FillGradient(
    x0,
    y0,
    x1,
    y1,
    gradientUnit === "objectBoundingBox" ? "local" : "global"
  );
  for (let k2 = 0; k2 < child.children.length; k2++) {
    const stop = child.children[k2];
    const offset = parseSVGFloatAttribute(stop, "offset", 0);
    const color = Color.shared.setValue(stop.getAttribute("stop-color")).toNumber();
    gradient.addColorStop(offset, color);
  }
  return gradient;
}
function parseRadialGradient(_child) {
  warn("[SVG Parser] Radial gradients are not yet supported");
  return new FillGradient(0, 0, 1, 0);
}
var init_parseSVGDefinitions = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs"() {
    init_Color();
    init_warn();
    init_FillGradient();
    init_parseSVGFloatAttribute();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs
function extractSvgUrlId(url) {
  const match = url.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
  return match ? match[1] : "";
}
var init_extractSvgUrlId = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs
function parseSVGStyle(svg, session) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  const result = {
    strokeStyle,
    fillStyle,
    useFill: false,
    useStroke: false
  };
  for (const key in styleAttributes) {
    const attribute = svg.getAttribute(key);
    if (attribute) {
      parseAttribute(session, result, key, attribute.trim());
    }
  }
  if (style) {
    const styleParts = style.split(";");
    for (let i2 = 0; i2 < styleParts.length; i2++) {
      const stylePart = styleParts[i2].trim();
      const [key, value] = stylePart.split(":");
      if (styleAttributes[key]) {
        parseAttribute(session, result, key, value.trim());
      }
    }
  }
  return {
    strokeStyle: result.useStroke ? strokeStyle : null,
    fillStyle: result.useFill ? fillStyle : null,
    useFill: result.useFill,
    useStroke: result.useStroke
  };
}
function parseAttribute(session, result, id, value) {
  switch (id) {
    case "stroke":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = extractSvgUrlId(value);
          result.strokeStyle.fill = session.defs[id2];
        } else {
          result.strokeStyle.color = Color.shared.setValue(value).toNumber();
        }
        result.useStroke = true;
      }
      break;
    case "stroke-width":
      result.strokeStyle.width = Number(value);
      break;
    case "fill":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = extractSvgUrlId(value);
          result.fillStyle.fill = session.defs[id2];
        } else {
          result.fillStyle.color = Color.shared.setValue(value).toNumber();
        }
        result.useFill = true;
      }
      break;
    case "fill-opacity":
      result.fillStyle.alpha = Number(value);
      break;
    case "stroke-opacity":
      result.strokeStyle.alpha = Number(value);
      break;
    case "opacity":
      result.fillStyle.alpha = Number(value);
      result.strokeStyle.alpha = Number(value);
      break;
  }
}
var styleAttributes;
var init_parseSVGStyle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs"() {
    init_Color();
    init_extractSvgUrlId();
    styleAttributes = {
      // Fill properties
      fill: { type: "paint", default: 0 },
      // Fill color/gradient
      "fill-opacity": { type: "number", default: 1 },
      // Fill transparency
      // Stroke properties
      stroke: { type: "paint", default: 0 },
      // Stroke color/gradient
      "stroke-width": { type: "number", default: 1 },
      // Width of stroke
      "stroke-opacity": { type: "number", default: 1 },
      // Stroke transparency
      "stroke-linecap": { type: "string", default: "butt" },
      // End cap style: butt, round, square
      "stroke-linejoin": { type: "string", default: "miter" },
      // Join style: miter, round, bevel
      "stroke-miterlimit": { type: "number", default: 10 },
      // Limit on miter join sharpness
      "stroke-dasharray": { type: "string", default: "none" },
      // Dash pattern
      "stroke-dashoffset": { type: "number", default: 0 },
      // Offset for dash pattern
      // Global properties
      opacity: { type: "number", default: 1 }
      // Overall opacity
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/fillOperations.mjs
function checkForNestedPattern(subpathsWithArea) {
  if (subpathsWithArea.length <= 2) {
    return true;
  }
  const areas = subpathsWithArea.map((s2) => s2.area).sort((a2, b2) => b2 - a2);
  const [largestArea, secondArea] = areas;
  const smallestArea = areas[areas.length - 1];
  const largestToSecondRatio = largestArea / secondArea;
  const secondToSmallestRatio = secondArea / smallestArea;
  if (largestToSecondRatio > 3 && secondToSmallestRatio < 2) {
    return false;
  }
  return true;
}
var init_fillOperations = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/fillOperations.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/pathOperations.mjs
function extractSubpaths(pathData) {
  const parts = pathData.split(/(?=[Mm])/);
  const subpaths = parts.filter((part) => part.trim().length > 0);
  return subpaths;
}
function calculatePathArea(pathData) {
  const coords = pathData.match(/[-+]?[0-9]*\.?[0-9]+/g);
  if (!coords || coords.length < 4)
    return 0;
  const numbers = coords.map(Number);
  const xs = [];
  const ys = [];
  for (let i2 = 0; i2 < numbers.length; i2 += 2) {
    if (i2 + 1 < numbers.length) {
      xs.push(numbers[i2]);
      ys.push(numbers[i2 + 1]);
    }
  }
  if (xs.length === 0 || ys.length === 0)
    return 0;
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  const area2 = (maxX - minX) * (maxY - minY);
  return area2;
}
function appendSVGPath(pathData, graphicsPath) {
  const tempPath = new GraphicsPath(pathData, false);
  for (const instruction of tempPath.instructions) {
    graphicsPath.instructions.push(instruction);
  }
}
var init_pathOperations = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/pathOperations.mjs"() {
    init_GraphicsPath();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    defs: {},
    path: new GraphicsPath()
  };
  parseSVGDefinitions(svg, session);
  const children = svg.children;
  const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (child.nodeName.toLowerCase() === "defs")
      continue;
    renderChildren(child, session, fillStyle, strokeStyle);
  }
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  const noStyle = !fillStyle && !strokeStyle;
  if (noStyle) {
    fillStyle = { color: 0 };
  }
  let x2;
  let y2;
  let x1;
  let y1;
  let x22;
  let y22;
  let cx;
  let cy;
  let r2;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d2;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path": {
      d2 = svg.getAttribute("d");
      const fillRule = svg.getAttribute("fill-rule");
      const subpaths = extractSubpaths(d2);
      const hasExplicitEvenodd = fillRule === "evenodd";
      const hasMultipleSubpaths = subpaths.length > 1;
      const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;
      if (shouldProcessHoles) {
        const subpathsWithArea = subpaths.map((subpath) => ({
          path: subpath,
          area: calculatePathArea(subpath)
        }));
        subpathsWithArea.sort((a2, b2) => b2.area - a2.area);
        const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);
        if (useMultipleHolesApproach) {
          for (let i2 = 0; i2 < subpathsWithArea.length; i2++) {
            const subpath = subpathsWithArea[i2];
            const isMainShape = i2 === 0;
            session.context.beginPath();
            const newPath = new GraphicsPath(void 0, true);
            appendSVGPath(subpath.path, newPath);
            session.context.path(newPath);
            if (isMainShape) {
              if (fillStyle)
                session.context.fill(fillStyle);
              if (strokeStyle)
                session.context.stroke(strokeStyle);
            } else {
              session.context.cut();
            }
          }
        } else {
          for (let i2 = 0; i2 < subpathsWithArea.length; i2++) {
            const subpath = subpathsWithArea[i2];
            const isHole = i2 % 2 === 1;
            session.context.beginPath();
            const newPath = new GraphicsPath(void 0, true);
            appendSVGPath(subpath.path, newPath);
            session.context.path(newPath);
            if (isHole) {
              session.context.cut();
            } else {
              if (fillStyle)
                session.context.fill(fillStyle);
              if (strokeStyle)
                session.context.stroke(strokeStyle);
            }
          }
        }
      } else {
        const useEvenoddForGraphicsPath = fillRule ? fillRule === "evenodd" : true;
        graphicsPath = new GraphicsPath(d2, useEvenoddForGraphicsPath);
        session.context.path(graphicsPath);
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
      }
      break;
    }
    case "circle":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      r2 = parseSVGFloatAttribute(svg, "r", 0);
      session.context.ellipse(cx, cy, r2, r2);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "rect":
      x2 = parseSVGFloatAttribute(svg, "x", 0);
      y2 = parseSVGFloatAttribute(svg, "y", 0);
      width = parseSVGFloatAttribute(svg, "width", 0);
      height = parseSVGFloatAttribute(svg, "height", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x2, y2, width, height, rx || ry);
      } else {
        session.context.rect(x2, y2, width, height);
      }
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "ellipse":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "line":
      x1 = parseSVGFloatAttribute(svg, "x1", 0);
      y1 = parseSVGFloatAttribute(svg, "y1", 0);
      x22 = parseSVGFloatAttribute(svg, "x2", 0);
      y22 = parseSVGFloatAttribute(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x22, y22);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "g":
    case "svg":
      break;
    default: {
      warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  if (noStyle) {
    fillStyle = null;
  }
  for (let i2 = 0; i2 < children.length; i2++) {
    renderChildren(children[i2], session, fillStyle, strokeStyle);
  }
}
var init_SVGParser = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
    init_warn();
    init_GraphicsPath();
    init_parseSVGDefinitions();
    init_parseSVGFloatAttribute();
    init_parseSVGStyle();
    init_fillOperations();
    init_pathOperations();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
function isColorLike(value) {
  return Color.isColorLike(value);
}
function isFillPattern(value) {
  return value instanceof FillPattern;
}
function isFillGradient(value) {
  return value instanceof FillGradient;
}
function isTexture(value) {
  return value instanceof Texture;
}
function handleColorLike(fill, value, defaultStyle) {
  const temp = Color.shared.setValue(value ?? 0);
  fill.color = temp.toNumber();
  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
  fill.texture = Texture.WHITE;
  return { ...defaultStyle, ...fill };
}
function handleTexture(fill, value, defaultStyle) {
  fill.texture = value;
  return { ...defaultStyle, ...fill };
}
function handleFillPattern(fill, value, defaultStyle) {
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  return { ...defaultStyle, ...fill };
}
function handleFillGradient(fill, value, defaultStyle) {
  value.buildGradient();
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  fill.textureSpace = value.textureSpace;
  return { ...defaultStyle, ...fill };
}
function handleFillObject(value, defaultStyle) {
  const style = { ...defaultStyle, ...value };
  const color = Color.shared.setValue(style.color);
  style.alpha *= color.alpha;
  style.color = color.toNumber();
  return style;
}
function toFillStyle(value, defaultStyle) {
  if (value === void 0 || value === null) {
    return null;
  }
  const fill = {};
  const objectStyle = value;
  if (isColorLike(value)) {
    return handleColorLike(fill, value, defaultStyle);
  } else if (isTexture(value)) {
    return handleTexture(fill, value, defaultStyle);
  } else if (isFillPattern(value)) {
    return handleFillPattern(fill, value, defaultStyle);
  } else if (isFillGradient(value)) {
    return handleFillGradient(fill, value, defaultStyle);
  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
  }
  return handleFillObject(objectStyle, defaultStyle);
}
function toStrokeStyle(value, defaultStyle) {
  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;
  const fill = toFillStyle(value, rest);
  if (!fill) {
    return null;
  }
  return {
    width,
    alignment,
    miterLimit,
    cap,
    join,
    pixelLine,
    ...fill
  };
}
var init_convertFillInputToFillStyle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
    init_Color();
    init_Texture();
    init_FillGradient();
    init_FillPattern();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
var tmpPoint, tempMatrix4, _GraphicsContext, GraphicsContext;
var init_GraphicsContext = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
    init_eventemitter3();
    init_Color();
    init_Matrix();
    init_Point();
    init_Texture();
    init_uid();
    init_deprecation();
    init_Bounds();
    init_GraphicsPath();
    init_SVGParser();
    init_convertFillInputToFillStyle();
    tmpPoint = new Point();
    tempMatrix4 = new Matrix();
    _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.uid = uid("graphicsContext");
        this.dirty = true;
        this.batchMode = "auto";
        this.instructions = [];
        this._activePath = new GraphicsPath();
        this._transform = new Matrix();
        this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
        this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
        this._stateStack = [];
        this._tick = 0;
        this._bounds = new Bounds();
        this._boundsDirty = true;
      }
      /**
       * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
       * including the current drawing state, transformations, styles, and instructions.
       * @returns A new GraphicsContext instance with the same properties and state as this one.
       */
      clone() {
        const clone = new _GraphicsContext2();
        clone.batchMode = this.batchMode;
        clone.instructions = this.instructions.slice();
        clone._activePath = this._activePath.clone();
        clone._transform = this._transform.clone();
        clone._fillStyle = { ...this._fillStyle };
        clone._strokeStyle = { ...this._strokeStyle };
        clone._stateStack = this._stateStack.slice();
        clone._bounds = this._bounds.clone();
        clone._boundsDirty = true;
        return clone;
      }
      /**
       * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
       */
      get fillStyle() {
        return this._fillStyle;
      }
      set fillStyle(value) {
        this._fillStyle = toFillStyle(value, _GraphicsContext2.defaultFillStyle);
      }
      /**
       * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
       */
      get strokeStyle() {
        return this._strokeStyle;
      }
      set strokeStyle(value) {
        this._strokeStyle = toStrokeStyle(value, _GraphicsContext2.defaultStrokeStyle);
      }
      /**
       * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
       * pattern, or a more complex style defined by a FillStyle object.
       * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
       *                or a FillStyle or ConvertedFillStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setFillStyle(style) {
        this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
        return this;
      }
      /**
       * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
       * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
       * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
       *                or a StrokeStyle or ConvertedStrokeStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setStrokeStyle(style) {
        this._strokeStyle = toFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
        return this;
      }
      texture(texture, tint, dx, dy, dw, dh) {
        this.instructions.push({
          action: "texture",
          data: {
            image: texture,
            dx: dx || 0,
            dy: dy || 0,
            dw: dw || texture.frame.width,
            dh: dh || texture.frame.height,
            transform: this._transform.clone(),
            alpha: this._fillStyle.alpha,
            style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
          }
        });
        this.onUpdate();
        return this;
      }
      /**
       * Resets the current path. Any previous path and its commands are discarded and a new path is
       * started. This is typically called before beginning a new shape or series of drawing commands.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      beginPath() {
        this._activePath = new GraphicsPath();
        return this;
      }
      fill(style, alpha) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this._activePath.clone();
        }
        if (!path2)
          return this;
        if (style != null) {
          if (alpha !== void 0 && typeof style === "number") {
            deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
            style = { color: style, alpha };
          }
          this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
        }
        this.instructions.push({
          action: "fill",
          // TODO copy fill style!
          data: { style: this.fillStyle, path: path2 }
        });
        this.onUpdate();
        this._initNextPathLocation();
        this._tick = 0;
        return this;
      }
      _initNextPathLocation() {
        const { x: x2, y: y2 } = this._activePath.getLastPoint(Point.shared);
        this._activePath.clear();
        this._activePath.moveTo(x2, y2);
      }
      /**
       * Strokes the current path with the current stroke style. This method can take an optional
       * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
       * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      stroke(style) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this._activePath.clone();
        }
        if (!path2)
          return this;
        if (style != null) {
          this._strokeStyle = toStrokeStyle(style, _GraphicsContext2.defaultStrokeStyle);
        }
        this.instructions.push({
          action: "stroke",
          // TODO copy fill style!
          data: { style: this.strokeStyle, path: path2 }
        });
        this.onUpdate();
        this._initNextPathLocation();
        this._tick = 0;
        return this;
      }
      /**
       * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
       * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
       * fail to cut correctly!
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      cut() {
        for (let i2 = 0; i2 < 2; i2++) {
          const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
          const holePath = this._activePath.clone();
          if (lastInstruction) {
            if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
              if (lastInstruction.data.hole) {
                lastInstruction.data.hole.addPath(holePath);
              } else {
                lastInstruction.data.hole = holePath;
                break;
              }
            }
          }
        }
        this._initNextPathLocation();
        return this;
      }
      /**
       * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
       * starting and ending angles, and direction.
       * @param x - The x-coordinate of the arc's center.
       * @param y - The y-coordinate of the arc's center.
       * @param radius - The arc's radius.
       * @param startAngle - The starting angle, in radians.
       * @param endAngle - The ending angle, in radians.
       * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arc(
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty,
          radius,
          startAngle,
          endAngle,
          counterclockwise
        );
        return this;
      }
      /**
       * Adds an arc to the current path with the given control points and radius, connected to the previous point
       * by a straight line if necessary.
       * @param x1 - The x-coordinate of the first control point.
       * @param y1 - The y-coordinate of the first control point.
       * @param x2 - The x-coordinate of the second control point.
       * @param y2 - The y-coordinate of the second control point.
       * @param radius - The arc's radius.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      arcTo(x1, y1, x2, y2, radius) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcTo(
          t2.a * x1 + t2.c * y1 + t2.tx,
          t2.b * x1 + t2.d * y1 + t2.ty,
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty,
          radius
        );
        return this;
      }
      /**
       * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
       * @param rx - The x-radius of the ellipse.
       * @param ry - The y-radius of the ellipse.
       * @param xAxisRotation - The rotation of the ellipse's x-axis relative
       * to the x-axis of the coordinate system, in degrees.
       * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
       * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
       * @param x - The x-coordinate of the arc's end point.
       * @param y - The y-coordinate of the arc's end point.
       * @returns The instance of the current object for chaining.
       */
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcToSvg(
          rx,
          ry,
          xAxisRotation,
          // should we rotate this with transform??
          largeArcFlag,
          sweepFlag,
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty
        );
        return this;
      }
      /**
       * Adds a cubic Bezier curve to the path.
       * It requires three points: the first two are control points and the third one is the end point.
       * The starting point is the last point in the current path.
       * @param cp1x - The x-coordinate of the first control point.
       * @param cp1y - The y-coordinate of the first control point.
       * @param cp2x - The x-coordinate of the second control point.
       * @param cp2y - The y-coordinate of the second control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.bezierCurveTo(
          t2.a * cp1x + t2.c * cp1y + t2.tx,
          t2.b * cp1x + t2.d * cp1y + t2.ty,
          t2.a * cp2x + t2.c * cp2y + t2.tx,
          t2.b * cp2x + t2.d * cp2y + t2.ty,
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty,
          smoothness
        );
        return this;
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        this._tick++;
        this._activePath?.closePath();
        return this;
      }
      /**
       * Draws an ellipse at the specified location and with the given x and y radii.
       * An optional transformation can be applied, allowing for rotation, scaling, and translation.
       * @param x - The x-coordinate of the center of the ellipse.
       * @param y - The y-coordinate of the center of the ellipse.
       * @param radiusX - The horizontal radius of the ellipse.
       * @param radiusY - The vertical radius of the ellipse.
       * @returns The instance of the current object for chaining.
       */
      ellipse(x2, y2, radiusX, radiusY) {
        this._tick++;
        this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
        return this;
      }
      /**
       * Draws a circle shape. This method adds a new circle path to the current drawing.
       * @param x - The x-coordinate of the center of the circle.
       * @param y - The y-coordinate of the center of the circle.
       * @param radius - The radius of the circle.
       * @returns The instance of the current object for chaining.
       */
      circle(x2, y2, radius) {
        this._tick++;
        this._activePath.circle(x2, y2, radius, this._transform.clone());
        return this;
      }
      /**
       * Adds another `GraphicsPath` to this path, optionally applying a transformation.
       * @param path - The `GraphicsPath` to add.
       * @returns The instance of the current object for chaining.
       */
      path(path2) {
        this._tick++;
        this._activePath.addPath(path2, this._transform.clone());
        return this;
      }
      /**
       * Connects the current point to a new point with a straight line. This method updates the current path.
       * @param x - The x-coordinate of the new point to connect to.
       * @param y - The y-coordinate of the new point to connect to.
       * @returns The instance of the current object for chaining.
       */
      lineTo(x2, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.lineTo(
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty
        );
        return this;
      }
      /**
       * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
       * @param x - The x-coordinate for the starting point.
       * @param y - The y-coordinate for the starting point.
       * @returns The instance of the current object for chaining.
       */
      moveTo(x2, y2) {
        this._tick++;
        const t2 = this._transform;
        const instructions = this._activePath.instructions;
        const transformedX = t2.a * x2 + t2.c * y2 + t2.tx;
        const transformedY = t2.b * x2 + t2.d * y2 + t2.ty;
        if (instructions.length === 1 && instructions[0].action === "moveTo") {
          instructions[0].data[0] = transformedX;
          instructions[0].data[1] = transformedY;
          return this;
        }
        this._activePath.moveTo(
          transformedX,
          transformedY
        );
        return this;
      }
      /**
       * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
       * The starting point is the last point in the current path.
       * @param cpx - The x-coordinate of the control point.
       * @param cpy - The y-coordinate of the control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.quadraticCurveTo(
          t2.a * cpx + t2.c * cpy + t2.tx,
          t2.b * cpx + t2.d * cpy + t2.ty,
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty,
          smoothness
        );
        return this;
      }
      /**
       * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @returns The instance of the current object for chaining.
       */
      rect(x2, y2, w2, h2) {
        this._tick++;
        this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
        return this;
      }
      /**
       * Draws a rectangle with rounded corners.
       * The corner radius can be specified to determine how rounded the corners should be.
       * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
       * @returns The instance of the current object for chaining.
       */
      roundRect(x2, y2, w2, h2, radius) {
        this._tick++;
        this._activePath.roundRect(x2, y2, w2, h2, radius, this._transform.clone());
        return this;
      }
      /**
       * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
       * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
       * rotated, or translated as needed.
       * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
       * representing the x and y coordinates, of the polygon's vertices, in sequence.
       * @param close - A boolean indicating whether to close the polygon path. True by default.
       */
      poly(points, close) {
        this._tick++;
        this._activePath.poly(points, close, this._transform.clone());
        return this;
      }
      /**
       * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
       * @returns The instance of the current object for chaining.
       */
      regularPoly(x2, y2, radius, sides, rotation = 0, transform) {
        this._tick++;
        this._activePath.regularPoly(x2, y2, radius, sides, rotation, transform);
        return this;
      }
      /**
       * Draws a polygon with rounded corners.
       * Similar to `regularPoly` but with the ability to round the corners of the polygon.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param corner - The radius of the rounding of the corners.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @returns The instance of the current object for chaining.
       */
      roundPoly(x2, y2, radius, sides, corner, rotation) {
        this._tick++;
        this._activePath.roundPoly(x2, y2, radius, sides, corner, rotation);
        return this;
      }
      /**
       * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
       * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
       * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
       * A minimum of 3 points is required.
       * @param radius - The default radius for the corners.
       * This radius is applied to all corners unless overridden in `points`.
       * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
       *  method instead of an arc method. Defaults to false.
       * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
       * Higher values make the curve smoother.
       * @returns The instance of the current object for chaining.
       */
      roundShape(points, radius, useQuadratic, smoothness) {
        this._tick++;
        this._activePath.roundShape(points, radius, useQuadratic, smoothness);
        return this;
      }
      /**
       * Draw Rectangle with fillet corners. This is much like rounded rectangle
       * however it support negative numbers as well for the corner radius.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param fillet - accept negative or positive values
       */
      filletRect(x2, y2, width, height, fillet) {
        this._tick++;
        this._activePath.filletRect(x2, y2, width, height, fillet);
        return this;
      }
      /**
       * Draw Rectangle with chamfer corners. These are angled corners.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param chamfer - non-zero real number, size of corner cutout
       * @param transform
       */
      chamferRect(x2, y2, width, height, chamfer, transform) {
        this._tick++;
        this._activePath.chamferRect(x2, y2, width, height, chamfer, transform);
        return this;
      }
      /**
       * Draws a star shape centered at a specified location. This method allows for the creation
       *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
       * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
       * An optional transformation can be applied to scale, rotate, or translate the star as needed.
       * @param x - The x-coordinate of the center of the star.
       * @param y - The y-coordinate of the center of the star.
       * @param points - The number of points of the star.
       * @param radius - The outer radius of the star (distance from the center to the outer points).
       * @param innerRadius - Optional. The inner radius of the star
       * (distance from the center to the inner points between the outer points).
       * If not provided, defaults to half of the `radius`.
       * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
       * Defaults to 0, meaning one point is directly upward.
       * @returns The instance of the current object for chaining further drawing commands.
       */
      star(x2, y2, points, radius, innerRadius = 0, rotation = 0) {
        this._tick++;
        this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
        return this;
      }
      /**
       * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
       * defined in SVG format to be drawn within the graphics context.
       * @param svg - The SVG string to be parsed and rendered.
       */
      svg(svg) {
        this._tick++;
        SVGParser(svg, this);
        return this;
      }
      /**
       * Restores the most recently saved graphics state by popping the top of the graphics state stack.
       * This includes transformations, fill styles, and stroke styles.
       */
      restore() {
        const state = this._stateStack.pop();
        if (state) {
          this._transform = state.transform;
          this._fillStyle = state.fillStyle;
          this._strokeStyle = state.strokeStyle;
        }
        return this;
      }
      /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
      save() {
        this._stateStack.push({
          transform: this._transform.clone(),
          fillStyle: { ...this._fillStyle },
          strokeStyle: { ...this._strokeStyle }
        });
        return this;
      }
      /**
       * Returns the current transformation matrix of the graphics context.
       * @returns The current transformation matrix.
       */
      getTransform() {
        return this._transform;
      }
      /**
       * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      resetTransform() {
        this._transform.identity();
        return this;
      }
      /**
       * Applies a rotation transformation to the graphics context around the current origin.
       * @param angle - The angle of rotation in radians.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      rotate(angle) {
        this._transform.rotate(angle);
        return this;
      }
      /**
       * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
       * @param x - The scale factor in the horizontal direction.
       * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      scale(x2, y2 = x2) {
        this._transform.scale(x2, y2);
        return this;
      }
      setTransform(a2, b2, c2, d2, dx, dy) {
        if (a2 instanceof Matrix) {
          this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
          return this;
        }
        this._transform.set(a2, b2, c2, d2, dx, dy);
        return this;
      }
      transform(a2, b2, c2, d2, dx, dy) {
        if (a2 instanceof Matrix) {
          this._transform.append(a2);
          return this;
        }
        tempMatrix4.set(a2, b2, c2, d2, dx, dy);
        this._transform.append(tempMatrix4);
        return this;
      }
      /**
       * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
       * @param x - The amount to translate in the horizontal direction.
       * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      translate(x2, y2 = x2) {
        this._transform.translate(x2, y2);
        return this;
      }
      /**
       * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
       * and optionally resetting transformations to the identity matrix.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      clear() {
        this._activePath.clear();
        this.instructions.length = 0;
        this.resetTransform();
        this.onUpdate();
        return this;
      }
      onUpdate() {
        this._boundsDirty = true;
        if (this.dirty)
          return;
        this.emit("update", this, 16);
        this.dirty = true;
      }
      /** The bounds of the graphic shape. */
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        this._boundsDirty = false;
        const bounds = this._bounds;
        bounds.clear();
        for (let i2 = 0; i2 < this.instructions.length; i2++) {
          const instruction = this.instructions[i2];
          const action = instruction.action;
          if (action === "fill") {
            const data = instruction.data;
            bounds.addBounds(data.path.bounds);
          } else if (action === "texture") {
            const data = instruction.data;
            bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
          }
          if (action === "stroke") {
            const data = instruction.data;
            const alignment = data.style.alignment;
            const outerPadding = data.style.width * (1 - alignment);
            const _bounds = data.path.bounds;
            bounds.addFrame(
              _bounds.minX - outerPadding,
              _bounds.minY - outerPadding,
              _bounds.maxX + outerPadding,
              _bounds.maxY + outerPadding
            );
          }
        }
        return bounds;
      }
      /**
       * Check to see if a point is contained within this geometry.
       * @param point - Point to check if it's contained.
       * @returns {boolean} `true` if the point is contained within geometry.
       */
      containsPoint(point) {
        if (!this.bounds.containsPoint(point.x, point.y))
          return false;
        const instructions = this.instructions;
        let hasHit = false;
        for (let k2 = 0; k2 < instructions.length; k2++) {
          const instruction = instructions[k2];
          const data = instruction.data;
          const path2 = data.path;
          if (!instruction.action || !path2)
            continue;
          const style = data.style;
          const shapes = path2.shapePath.shapePrimitives;
          for (let i2 = 0; i2 < shapes.length; i2++) {
            const shape = shapes[i2].shape;
            if (!style || !shape)
              continue;
            const transform = shapes[i2].transform;
            const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;
            if (instruction.action === "fill") {
              hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
            } else {
              const strokeStyle = style;
              hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);
            }
            const holes = data.hole;
            if (holes) {
              const holeShapes = holes.shapePath?.shapePrimitives;
              if (holeShapes) {
                for (let j2 = 0; j2 < holeShapes.length; j2++) {
                  if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                    hasHit = false;
                  }
                }
              }
            }
            if (hasHit) {
              return true;
            }
          }
        }
        return hasHit;
      }
      /**
       * Destroys the GraphicsData object.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @example
       * context.destroy();
       * context.destroy(true);
       * context.destroy({ texture: true, textureSource: true });
       */
      destroy(options = false) {
        this._stateStack.length = 0;
        this._transform = null;
        this.emit("destroy", this);
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fillStyle.texture) {
            this._fillStyle.fill && "uid" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(destroyTextureSource);
          }
          if (this._strokeStyle.texture) {
            this._strokeStyle.fill && "uid" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(destroyTextureSource);
          }
        }
        this._fillStyle = null;
        this._strokeStyle = null;
        this.instructions = null;
        this._activePath = null;
        this._bounds = null;
        this._stateStack = null;
        this.customShader = null;
        this._transform = null;
      }
    };
    _GraphicsContext.defaultFillStyle = {
      /** The color to use for the fill. */
      color: 16777215,
      /** The alpha value to use for the fill. */
      alpha: 1,
      /** The texture to use for the fill. */
      texture: Texture.WHITE,
      /** The matrix to apply. */
      matrix: null,
      /** The fill pattern to use. */
      fill: null,
      /** Whether coordinates are 'global' or 'local' */
      textureSpace: "local"
    };
    _GraphicsContext.defaultStrokeStyle = {
      /** The width of the stroke. */
      width: 1,
      /** The color to use for the stroke. */
      color: 16777215,
      /** The alpha value to use for the stroke. */
      alpha: 1,
      /** The alignment of the stroke. */
      alignment: 0.5,
      /** The miter limit to use. */
      miterLimit: 10,
      /** The line cap style to use. */
      cap: "butt",
      /** The line join style to use. */
      join: "miter",
      /** The texture to use for the fill. */
      texture: Texture.WHITE,
      /** The matrix to apply. */
      matrix: null,
      /** The fill pattern to use. */
      fill: null,
      /** Whether coordinates are 'global' or 'local' */
      textureSpace: "local",
      /** If the stroke is a pixel line. */
      pixelLine: false
    };
    GraphicsContext = _GraphicsContext;
  }
});

// node_modules/pixi.js/lib/scene/text/TextStyle.mjs
function convertV7Tov8Style(style) {
  const oldStyle = style;
  if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
    const defaults = TextStyle.defaultDropShadow;
    style.dropShadow = {
      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,
      angle: oldStyle.dropShadowAngle ?? defaults.angle,
      blur: oldStyle.dropShadowBlur ?? defaults.blur,
      color: oldStyle.dropShadowColor ?? defaults.color,
      distance: oldStyle.dropShadowDistance ?? defaults.distance
    };
  }
  if (oldStyle.strokeThickness !== void 0) {
    deprecation(v8_0_0, "strokeThickness is now a part of stroke");
    const color = oldStyle.stroke;
    let obj = {};
    if (Color.isColorLike(color)) {
      obj.color = color;
    } else if (color instanceof FillGradient || color instanceof FillPattern) {
      obj.fill = color;
    } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
      obj = color;
    } else {
      throw new Error("Invalid stroke value.");
    }
    style.stroke = {
      ...obj,
      width: oldStyle.strokeThickness
    };
  }
  if (Array.isArray(oldStyle.fillGradientStops)) {
    deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0) {
      throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
    }
    if (oldStyle.fill.length !== oldStyle.fillGradientStops.length) {
      warn("The number of fill colors must match the number of fill gradient stops.");
    }
    const gradientFill = new FillGradient({
      start: { x: 0, y: 0 },
      end: { x: 0, y: 1 },
      textureSpace: "local"
    });
    const fillGradientStops = oldStyle.fillGradientStops.slice();
    const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());
    fillGradientStops.forEach((stop, index) => {
      gradientFill.addColorStop(stop, fills[index]);
    });
    style.fill = {
      fill: gradientFill
    };
  }
}
var _TextStyle, TextStyle;
var init_TextStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/TextStyle.mjs"() {
    init_eventemitter3();
    init_Color();
    init_uid();
    init_deprecation();
    init_warn();
    init_FillGradient();
    init_FillPattern();
    init_GraphicsContext();
    init_convertFillInputToFillStyle();
    _TextStyle = class _TextStyle2 extends eventemitter3_default {
      constructor(style = {}) {
        super();
        this.uid = uid("textStyle");
        this._tick = 0;
        convertV7Tov8Style(style);
        const fullStyle = { ..._TextStyle2.defaultTextStyle, ...style };
        for (const key in fullStyle) {
          const thisKey = key;
          this[thisKey] = fullStyle[key];
        }
        this.update();
        this._tick = 0;
      }
      /**
       * Alignment for multiline text, does not affect single line text.
       * @type {'left'|'center'|'right'|'justify'}
       */
      get align() {
        return this._align;
      }
      set align(value) {
        if (this._align === value)
          return;
        this._align = value;
        this.update();
      }
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get breakWords() {
        return this._breakWords;
      }
      set breakWords(value) {
        if (this._breakWords === value)
          return;
        this._breakWords = value;
        this.update();
      }
      /** Set a drop shadow for the text. */
      get dropShadow() {
        return this._dropShadow;
      }
      set dropShadow(value) {
        if (this._dropShadow === value)
          return;
        if (value !== null && typeof value === "object") {
          this._dropShadow = this._createProxy({ ..._TextStyle2.defaultDropShadow, ...value });
        } else {
          this._dropShadow = value ? this._createProxy({ ..._TextStyle2.defaultDropShadow }) : null;
        }
        this.update();
      }
      /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
      get fontFamily() {
        return this._fontFamily;
      }
      set fontFamily(value) {
        if (this._fontFamily === value)
          return;
        this._fontFamily = value;
        this.update();
      }
      /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(value) {
        if (this._fontSize === value)
          return;
        if (typeof value === "string") {
          this._fontSize = parseInt(value, 10);
        } else {
          this._fontSize = value;
        }
        this.update();
      }
      /**
       * The font style.
       * @type {'normal'|'italic'|'oblique'}
       */
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(value) {
        if (this._fontStyle === value)
          return;
        this._fontStyle = value.toLowerCase();
        this.update();
      }
      /**
       * The font variant.
       * @type {'normal'|'small-caps'}
       */
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(value) {
        if (this._fontVariant === value)
          return;
        this._fontVariant = value;
        this.update();
      }
      /**
       * The font weight.
       * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
       */
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(value) {
        if (this._fontWeight === value)
          return;
        this._fontWeight = value;
        this.update();
      }
      /** The space between lines. */
      get leading() {
        return this._leading;
      }
      set leading(value) {
        if (this._leading === value)
          return;
        this._leading = value;
        this.update();
      }
      /** The amount of spacing between letters, default is 0. */
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(value) {
        if (this._letterSpacing === value)
          return;
        this._letterSpacing = value;
        this.update();
      }
      /** The line height, a number that represents the vertical space that a letter uses. */
      get lineHeight() {
        return this._lineHeight;
      }
      set lineHeight(value) {
        if (this._lineHeight === value)
          return;
        this._lineHeight = value;
        this.update();
      }
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       * > [!NOTE] This will NOT affect the positioning or bounds of the text.
       */
      get padding() {
        return this._padding;
      }
      set padding(value) {
        if (this._padding === value)
          return;
        this._padding = value;
        this.update();
      }
      /**
       * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.
       * These filters will be applied to the text as it is created, resulting in faster rendering for static text
       * compared to applying the filter directly to the text object (which would be applied at run time).
       * @default null
       */
      get filters() {
        return this._filters;
      }
      set filters(value) {
        if (this._filters === value)
          return;
        this._filters = Object.freeze(value);
        this.update();
      }
      /**
       * Trim transparent borders from the text texture.
       * > [!IMPORTANT] PERFORMANCE WARNING:
       * > This is a costly operation as it requires scanning pixel alpha values.
       * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.
       */
      get trim() {
        return this._trim;
      }
      set trim(value) {
        if (this._trim === value)
          return;
        this._trim = value;
        this.update();
      }
      /**
       * The baseline of the text that is rendered.
       * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
       */
      get textBaseline() {
        return this._textBaseline;
      }
      set textBaseline(value) {
        if (this._textBaseline === value)
          return;
        this._textBaseline = value;
        this.update();
      }
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       * @type {'normal'|'pre'|'pre-line'}
       */
      get whiteSpace() {
        return this._whiteSpace;
      }
      set whiteSpace(value) {
        if (this._whiteSpace === value)
          return;
        this._whiteSpace = value;
        this.update();
      }
      /** Indicates if word wrap should be used. */
      get wordWrap() {
        return this._wordWrap;
      }
      set wordWrap(value) {
        if (this._wordWrap === value)
          return;
        this._wordWrap = value;
        this.update();
      }
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get wordWrapWidth() {
        return this._wordWrapWidth;
      }
      set wordWrapWidth(value) {
        if (this._wordWrapWidth === value)
          return;
        this._wordWrapWidth = value;
        this.update();
      }
      /**
       * The fill style that will be used to color the text.
       * This can be:
       * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'
       * - A hex number like 0xff0000 for red
       * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }
       * - A FillGradient for gradient fills
       * - A FillPattern for pattern/texture fills
       *
       * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,
       * while gradients at any other angle are spread across the entire text body as a whole.
       * @example
       * // Vertical gradient applied per line
       * const verticalGradient = new FillGradient(0, 0, 0, 1)
       *     .addColorStop(0, 0xff0000)
       *     .addColorStop(1, 0x0000ff);
       *
       * const text = new Text({
       *     text: 'Line 1\nLine 2',
       *     style: { fill: verticalGradient }
       * });
       *
       * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.
       * @type {string|number|FillStyle|FillGradient|FillPattern}
       */
      get fill() {
        return this._originalFill;
      }
      set fill(value) {
        if (value === this._originalFill)
          return;
        this._originalFill = value;
        if (this._isFillStyle(value)) {
          this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () => {
            this._fill = toFillStyle(
              { ...this._originalFill },
              GraphicsContext.defaultFillStyle
            );
          });
        }
        this._fill = toFillStyle(
          value === 0 ? "black" : value,
          GraphicsContext.defaultFillStyle
        );
        this.update();
      }
      /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
      get stroke() {
        return this._originalStroke;
      }
      set stroke(value) {
        if (value === this._originalStroke)
          return;
        this._originalStroke = value;
        if (this._isFillStyle(value)) {
          this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () => {
            this._stroke = toStrokeStyle(
              { ...this._originalStroke },
              GraphicsContext.defaultStrokeStyle
            );
          });
        }
        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);
        this.update();
      }
      update() {
        this._tick++;
        this.emit("update", this);
      }
      /** Resets all properties to the default values */
      reset() {
        const defaultStyle = _TextStyle2.defaultTextStyle;
        for (const key in defaultStyle) {
          this[key] = defaultStyle[key];
        }
      }
      /**
       * Returns a unique key for this instance.
       * This key is used for caching.
       * @returns {string} Unique key for the instance
       */
      get styleKey() {
        return `${this.uid}-${this._tick}`;
      }
      /**
       * Creates a new TextStyle object with the same values as this one.
       * @returns New cloned TextStyle object
       */
      clone() {
        return new _TextStyle2({
          align: this.align,
          breakWords: this.breakWords,
          dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
          fill: this._fill,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          fontStyle: this.fontStyle,
          fontVariant: this.fontVariant,
          fontWeight: this.fontWeight,
          leading: this.leading,
          letterSpacing: this.letterSpacing,
          lineHeight: this.lineHeight,
          padding: this.padding,
          stroke: this._stroke,
          textBaseline: this.textBaseline,
          whiteSpace: this.whiteSpace,
          wordWrap: this.wordWrap,
          wordWrapWidth: this.wordWrapWidth,
          filters: this._filters ? [...this._filters] : void 0
        });
      }
      /**
       * Returns the final padding for the text style, taking into account any filters applied.
       * Used internally for correct measurements
       * @internal
       * @returns {number} The final padding for the text style.
       */
      _getFinalPadding() {
        let filterPadding = 0;
        if (this._filters) {
          for (let i2 = 0; i2 < this._filters.length; i2++) {
            filterPadding += this._filters[i2].padding;
          }
        }
        return Math.max(this._padding, filterPadding);
      }
      /**
       * Destroys this text style.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @example
       * // Destroy the text style and its textures
       * textStyle.destroy({ texture: true, textureSource: true });
       * textStyle.destroy(true);
       */
      destroy(options = false) {
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fill?.texture) {
            this._fill.texture.destroy(destroyTextureSource);
          }
          if (this._originalFill?.texture) {
            this._originalFill.texture.destroy(destroyTextureSource);
          }
          if (this._stroke?.texture) {
            this._stroke.texture.destroy(destroyTextureSource);
          }
          if (this._originalStroke?.texture) {
            this._originalStroke.texture.destroy(destroyTextureSource);
          }
        }
        this._fill = null;
        this._stroke = null;
        this.dropShadow = null;
        this._originalStroke = null;
        this._originalFill = null;
      }
      _createProxy(value, cb) {
        return new Proxy(value, {
          set: (target, property, newValue) => {
            if (target[property] === newValue)
              return true;
            target[property] = newValue;
            cb?.(property, newValue);
            this.update();
            return true;
          }
        });
      }
      _isFillStyle(value) {
        return (value ?? null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);
      }
    };
    _TextStyle.defaultDropShadow = {
      alpha: 1,
      angle: Math.PI / 6,
      blur: 0,
      color: "black",
      distance: 5
    };
    _TextStyle.defaultTextStyle = {
      align: "left",
      breakWords: false,
      dropShadow: null,
      fill: "black",
      fontFamily: "Arial",
      fontSize: 26,
      fontStyle: "normal",
      fontVariant: "normal",
      fontWeight: "normal",
      leading: 0,
      letterSpacing: 0,
      lineHeight: 0,
      padding: 0,
      stroke: null,
      textBaseline: "alphabetic",
      trim: false,
      whiteSpace: "pre",
      wordWrap: false,
      wordWrapWidth: 100
    };
    TextStyle = _TextStyle;
  }
});

// node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs
function getPo2TextureFromSource(image, width, height, resolution) {
  const bounds = tempBounds2;
  bounds.minX = 0;
  bounds.minY = 0;
  bounds.maxX = image.width / resolution | 0;
  bounds.maxY = image.height / resolution | 0;
  const texture = TexturePool.getOptimalTexture(
    bounds.width,
    bounds.height,
    resolution,
    false
  );
  texture.source.uploadMethodId = "image";
  texture.source.resource = image;
  texture.source.alphaMode = "premultiply-alpha-on-upload";
  texture.frame.width = width / resolution;
  texture.frame.height = height / resolution;
  texture.source.emit("update", texture.source);
  texture.updateUvs();
  return texture;
}
var tempBounds2;
var init_getPo2TextureFromSource = __esm({
  "node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"() {
    init_TexturePool();
    init_Bounds();
    tempBounds2 = new Bounds();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
var CanvasPoolClass, CanvasPool;
var init_CanvasPool = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
    init_adapter();
    init_pow2();
    init_GlobalResourceRegistry();
    CanvasPoolClass = class {
      constructor(canvasOptions) {
        this._canvasPool = /* @__PURE__ */ Object.create(null);
        this.canvasOptions = canvasOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       */
      _createCanvasAndContext(pixelWidth, pixelHeight) {
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = pixelWidth;
        canvas.height = pixelHeight;
        const context2 = canvas.getContext("2d");
        return { canvas, context: context2 };
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param minWidth - The minimum width of the render texture.
       * @param minHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @returns The new render texture.
       */
      getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
        minWidth = Math.ceil(minWidth * resolution - 1e-6);
        minHeight = Math.ceil(minHeight * resolution - 1e-6);
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        const key = (minWidth << 17) + (minHeight << 1);
        if (!this._canvasPool[key]) {
          this._canvasPool[key] = [];
        }
        let canvasAndContext = this._canvasPool[key].pop();
        if (!canvasAndContext) {
          canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
        }
        return canvasAndContext;
      }
      /**
       * Place a render texture back into the pool.
       * @param canvasAndContext
       */
      returnCanvasAndContext(canvasAndContext) {
        const canvas = canvasAndContext.canvas;
        const { width, height } = canvas;
        const key = (width << 17) + (height << 1);
        canvasAndContext.context.resetTransform();
        canvasAndContext.context.clearRect(0, 0, width, height);
        this._canvasPool[key].push(canvasAndContext);
      }
      clear() {
        this._canvasPool = {};
      }
    };
    CanvasPool = new CanvasPoolClass();
    GlobalResourceRegistry.register(CanvasPool);
  }
});

// node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs
function ensureInternalCanvas(width, height) {
  if (!_internalCanvas) {
    _internalCanvas = DOMAdapter.get().createCanvas(256, 128);
    _internalContext = _internalCanvas.getContext("2d", { willReadFrequently: true });
    _internalContext.globalCompositeOperation = "copy";
    _internalContext.globalAlpha = 1;
  }
  if (_internalCanvas.width < width || _internalCanvas.height < height) {
    _internalCanvas.width = nextPow2(width);
    _internalCanvas.height = nextPow2(height);
  }
}
function checkRow(data, width, y2) {
  for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x2, top, bottom) {
  const stride = 4 * width;
  for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(...args) {
  let options = args[0];
  if (!options.canvas) {
    options = { canvas: args[0], resolution: args[1] };
  }
  const { canvas } = options;
  const resolution = Math.min(options.resolution ?? 1, 1);
  const width = options.width ?? canvas.width;
  const height = options.height ?? canvas.height;
  let output = options.output;
  ensureInternalCanvas(width, height);
  if (!_internalContext) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  _internalContext.drawImage(
    canvas,
    0,
    0,
    width,
    height,
    0,
    0,
    width * resolution,
    height * resolution
  );
  const imageData = _internalContext.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return Rectangle.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  _internalContext.globalCompositeOperation = "source-over";
  _internalContext.strokeRect(left, top, right - left, bottom - top);
  _internalContext.globalCompositeOperation = "copy";
  output ?? (output = new Rectangle());
  output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
  return output;
}
var _internalCanvas, _internalContext;
var init_getCanvasBoundingBox = __esm({
  "node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs"() {
    init_adapter();
    init_pow2();
    init_Rectangle();
    _internalCanvas = null;
    _internalContext = null;
  }
});

// node_modules/tiny-lru/dist/tiny-lru.js
function lru(max = 1e3, ttl = 0, resetTtl = false) {
  if (isNaN(max) || max < 0) {
    throw new TypeError("Invalid max value");
  }
  if (isNaN(ttl) || ttl < 0) {
    throw new TypeError("Invalid ttl value");
  }
  if (typeof resetTtl !== "boolean") {
    throw new TypeError("Invalid resetTtl value");
  }
  return new LRU(max, ttl, resetTtl);
}
var LRU;
var init_tiny_lru = __esm({
  "node_modules/tiny-lru/dist/tiny-lru.js"() {
    LRU = class {
      /**
       * Creates a new LRU cache instance.
       * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.
       *
       * @constructor
       * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.
       * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.
       * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().
       * @example
       * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access
       * @see {@link lru} For parameter validation
       * @since 1.0.0
       */
      constructor(max = 0, ttl = 0, resetTtl = false) {
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.max = max;
        this.resetTtl = resetTtl;
        this.size = 0;
        this.ttl = ttl;
      }
      /**
       * Removes all items from the cache.
       *
       * @method clear
       * @memberof LRU
       * @returns {LRU} The LRU instance for method chaining.
       * @example
       * cache.clear();
       * console.log(cache.size); // 0
       * @since 1.0.0
       */
      clear() {
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.size = 0;
        return this;
      }
      /**
       * Removes an item from the cache by key.
       *
       * @method delete
       * @memberof LRU
       * @param {string} key - The key of the item to delete.
       * @returns {LRU} The LRU instance for method chaining.
       * @example
       * cache.set('key1', 'value1');
       * cache.delete('key1');
       * console.log(cache.has('key1')); // false
       * @see {@link LRU#has}
       * @see {@link LRU#clear}
       * @since 1.0.0
       */
      delete(key) {
        if (this.has(key)) {
          const item = this.items[key];
          delete this.items[key];
          this.size--;
          if (item.prev !== null) {
            item.prev.next = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          }
          if (this.first === item) {
            this.first = item.next;
          }
          if (this.last === item) {
            this.last = item.prev;
          }
        }
        return this;
      }
      /**
       * Returns an array of [key, value] pairs for the specified keys.
       * Order follows LRU order (least to most recently used).
       *
       * @method entries
       * @memberof LRU
       * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.
       * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.
       * @example
       * cache.set('a', 1).set('b', 2);
       * console.log(cache.entries()); // [['a', 1], ['b', 2]]
       * console.log(cache.entries(['a'])); // [['a', 1]]
       * @see {@link LRU#keys}
       * @see {@link LRU#values}
       * @since 11.1.0
       */
      entries(keys = this.keys()) {
        return keys.map((key) => [key, this.get(key)]);
      }
      /**
       * Removes the least recently used item from the cache.
       *
       * @method evict
       * @memberof LRU
       * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.
       * @returns {LRU} The LRU instance for method chaining.
       * @example
       * cache.set('old', 'value').set('new', 'value');
       * cache.evict(); // Removes 'old' item
       * @see {@link LRU#setWithEvicted}
       * @since 1.0.0
       */
      evict(bypass = false) {
        if (bypass || this.size > 0) {
          const item = this.first;
          delete this.items[item.key];
          if (--this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
        return this;
      }
      /**
       * Returns the expiration timestamp for a given key.
       *
       * @method expiresAt
       * @memberof LRU
       * @param {string} key - The key to check expiration for.
       * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.
       * @example
       * const cache = new LRU(100, 5000); // 5 second TTL
       * cache.set('key1', 'value1');
       * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now
       * @see {@link LRU#get}
       * @see {@link LRU#has}
       * @since 1.0.0
       */
      expiresAt(key) {
        let result;
        if (this.has(key)) {
          result = this.items[key].expiry;
        }
        return result;
      }
      /**
       * Retrieves a value from the cache by key. Updates the item's position to most recently used.
       *
       * @method get
       * @memberof LRU
       * @param {string} key - The key to retrieve.
       * @returns {*} The value associated with the key, or undefined if not found or expired.
       * @example
       * cache.set('key1', 'value1');
       * console.log(cache.get('key1')); // 'value1'
       * console.log(cache.get('nonexistent')); // undefined
       * @see {@link LRU#set}
       * @see {@link LRU#has}
       * @since 1.0.0
       */
      get(key) {
        const item = this.items[key];
        if (item !== void 0) {
          if (this.ttl > 0) {
            if (item.expiry <= Date.now()) {
              this.delete(key);
              return void 0;
            }
          }
          this.moveToEnd(item);
          return item.value;
        }
        return void 0;
      }
      /**
       * Checks if a key exists in the cache.
       *
       * @method has
       * @memberof LRU
       * @param {string} key - The key to check for.
       * @returns {boolean} True if the key exists, false otherwise.
       * @example
       * cache.set('key1', 'value1');
       * console.log(cache.has('key1')); // true
       * console.log(cache.has('nonexistent')); // false
       * @see {@link LRU#get}
       * @see {@link LRU#delete}
       * @since 9.0.0
       */
      has(key) {
        return key in this.items;
      }
      /**
       * Efficiently moves an item to the end of the LRU list (most recently used position).
       * This is an internal optimization method that avoids the overhead of the full set() operation
       * when only LRU position needs to be updated.
       *
       * @method moveToEnd
       * @memberof LRU
       * @param {Object} item - The cache item with prev/next pointers to reposition.
       * @private
       * @since 11.3.5
       */
      moveToEnd(item) {
        if (this.last === item) {
          return;
        }
        if (item.prev !== null) {
          item.prev.next = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        }
        if (this.first === item) {
          this.first = item.next;
        }
        item.prev = this.last;
        item.next = null;
        if (this.last !== null) {
          this.last.next = item;
        }
        this.last = item;
        if (this.first === null) {
          this.first = item;
        }
      }
      /**
       * Returns an array of all keys in the cache, ordered from least to most recently used.
       *
       * @method keys
       * @memberof LRU
       * @returns {string[]} Array of keys in LRU order.
       * @example
       * cache.set('a', 1).set('b', 2);
       * cache.get('a'); // Move 'a' to most recent
       * console.log(cache.keys()); // ['b', 'a']
       * @see {@link LRU#values}
       * @see {@link LRU#entries}
       * @since 9.0.0
       */
      keys() {
        const result = [];
        let x2 = this.first;
        while (x2 !== null) {
          result.push(x2.key);
          x2 = x2.next;
        }
        return result;
      }
      /**
       * Sets a value in the cache and returns any evicted item.
       *
       * @method setWithEvicted
       * @memberof LRU
       * @param {string} key - The key to set.
       * @param {*} value - The value to store.
       * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
       * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.
       * @example
       * const cache = new LRU(2);
       * cache.set('a', 1).set('b', 2);
       * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}
       * @see {@link LRU#set}
       * @see {@link LRU#evict}
       * @since 11.3.0
       */
      setWithEvicted(key, value, resetTtl = this.resetTtl) {
        let evicted = null;
        if (this.has(key)) {
          this.set(key, value, true, resetTtl);
        } else {
          if (this.max > 0 && this.size === this.max) {
            evicted = { ...this.first };
            this.evict(true);
          }
          let item = this.items[key] = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key,
            prev: this.last,
            next: null,
            value
          };
          if (++this.size === 1) {
            this.first = item;
          } else {
            this.last.next = item;
          }
          this.last = item;
        }
        return evicted;
      }
      /**
       * Sets a value in the cache. Updates the item's position to most recently used.
       *
       * @method set
       * @memberof LRU
       * @param {string} key - The key to set.
       * @param {*} value - The value to store.
       * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.
       * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
       * @returns {LRU} The LRU instance for method chaining.
       * @example
       * cache.set('key1', 'value1')
       *      .set('key2', 'value2')
       *      .set('key3', 'value3');
       * @see {@link LRU#get}
       * @see {@link LRU#setWithEvicted}
       * @since 1.0.0
       */
      set(key, value, bypass = false, resetTtl = this.resetTtl) {
        let item = this.items[key];
        if (bypass || item !== void 0) {
          item.value = value;
          if (bypass === false && resetTtl) {
            item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          }
          this.moveToEnd(item);
        } else {
          if (this.max > 0 && this.size === this.max) {
            this.evict(true);
          }
          item = this.items[key] = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key,
            prev: this.last,
            next: null,
            value
          };
          if (++this.size === 1) {
            this.first = item;
          } else {
            this.last.next = item;
          }
          this.last = item;
        }
        return this;
      }
      /**
       * Returns an array of all values in the cache for the specified keys.
       * Order follows LRU order (least to most recently used).
       *
       * @method values
       * @memberof LRU
       * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.
       * @returns {Array<*>} Array of values corresponding to the keys in LRU order.
       * @example
       * cache.set('a', 1).set('b', 2);
       * console.log(cache.values()); // [1, 2]
       * console.log(cache.values(['a'])); // [1]
       * @see {@link LRU#keys}
       * @see {@link LRU#entries}
       * @since 11.1.0
       */
      values(keys = this.keys()) {
        return keys.map((key) => this.get(key));
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
function fontStringFromTextStyle(style) {
  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
  let fontFamilies = style.fontFamily;
  if (!Array.isArray(style.fontFamily)) {
    fontFamilies = style.fontFamily.split(",");
  }
  for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
    let fontFamily = fontFamilies[i2].trim();
    if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
      fontFamily = `"${fontFamily}"`;
    }
    fontFamilies[i2] = fontFamily;
  }
  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}
var genericFontFamilies;
var init_fontStringFromTextStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
    "use strict";
    genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
var init_CanvasTextMetrics = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
    init_tiny_lru();
    init_adapter();
    init_fontStringFromTextStyle();
    contextSettings = {
      // TextMetrics requires getImageData readback for measuring fonts.
      willReadFrequently: true
    };
    _CanvasTextMetrics = class _CanvasTextMetrics2 {
      /**
       * Checking that we can use modern canvas 2D API.
       *
       * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
       * @see TextMetrics.experimentalLetterSpacing
       * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
       * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
       */
      static get experimentalLetterSpacingSupported() {
        let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
        if (result === void 0) {
          const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
          result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
        }
        return result;
      }
      /**
       * @param text - the text that was measured
       * @param style - the style that was measured
       * @param width - the measured width of the text
       * @param height - the measured height of the text
       * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
       * @param lineWidths - an array of the line widths for each line matched to `lines`
       * @param lineHeight - the measured line height for this style
       * @param maxLineWidth - the maximum line width for all measured lines
       * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
       */
      constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      /**
       * Measures the supplied string of text and returns a Rectangle.
       * @param text - The text to measure.
       * @param style - The text style to use for measuring
       * @param canvas - optional specification of the canvas to use for measuring.
       * @param wordWrap
       * @returns Measured width and height of the text.
       */
      static measureText(text = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
        const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;
        if (_CanvasTextMetrics2._measurementCache.has(textKey)) {
          return _CanvasTextMetrics2._measurementCache.get(textKey);
        }
        const font = fontStringFromTextStyle(style);
        const fontProperties = _CanvasTextMetrics2.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        const context2 = _CanvasTextMetrics2.__context;
        context2.font = font;
        const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text, style, canvas) : text;
        const lines = outputText.split(/(?:\r\n|\r|\n)/);
        const lineWidths = new Array(lines.length);
        let maxLineWidth = 0;
        for (let i2 = 0; i2 < lines.length; i2++) {
          const lineWidth = _CanvasTextMetrics2._measureText(lines[i2], style.letterSpacing, context2);
          lineWidths[i2] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        const strokeWidth = style._stroke?.width || 0;
        let width = maxLineWidth + strokeWidth;
        if (style.dropShadow) {
          width += style.dropShadow.distance;
        }
        const lineHeight = style.lineHeight || fontProperties.fontSize;
        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height += style.dropShadow.distance;
        }
        const measurements = new _CanvasTextMetrics2(
          text,
          style,
          width,
          height,
          lines,
          lineWidths,
          lineHeight + style.leading,
          maxLineWidth,
          fontProperties
        );
        _CanvasTextMetrics2._measurementCache.set(textKey, measurements);
        return measurements;
      }
      static _measureText(text, letterSpacing, context2) {
        let useExperimentalLetterSpacing = false;
        if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
          if (_CanvasTextMetrics2.experimentalLetterSpacing) {
            context2.letterSpacing = `${letterSpacing}px`;
            context2.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context2.letterSpacing = "0px";
            context2.textLetterSpacing = "0px";
          }
        }
        const metrics = context2.measureText(text);
        let metricWidth = metrics.width;
        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
        if (metricWidth > 0) {
          if (useExperimentalLetterSpacing) {
            metricWidth -= letterSpacing;
            boundsWidth -= letterSpacing;
          } else {
            const val = (_CanvasTextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing;
            metricWidth += val;
            boundsWidth += val;
          }
        }
        return Math.max(metricWidth, boundsWidth);
      }
      /**
       * Applies newlines to a string to have it optimally fit into the horizontal
       * bounds set by the Text object's wordWrapWidth property.
       * @param text - String to apply word wrapping to
       * @param style - the style to use when wrapping
       * @param canvas - optional specification of the canvas to use for measuring.
       * @returns New string with new lines applied where required
       */
      static _wordWrap(text, style, canvas = _CanvasTextMetrics2._canvas) {
        const context2 = canvas.getContext("2d", contextSettings);
        let width = 0;
        let line = "";
        let lines = "";
        const cache = /* @__PURE__ */ Object.create(null);
        const { letterSpacing, whiteSpace } = style;
        const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
        const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
        let canPrependSpaces = !collapseSpaces;
        const wordWrapWidth = style.wordWrapWidth + letterSpacing;
        const tokens = _CanvasTextMetrics2._tokenize(text);
        for (let i2 = 0; i2 < tokens.length; i2++) {
          let token = tokens[i2];
          if (_CanvasTextMetrics2._isNewline(token)) {
            if (!collapseNewlines) {
              lines += _CanvasTextMetrics2._addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
            const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context2);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += _CanvasTextMetrics2._addLine(line);
              line = "";
              width = 0;
            }
            if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
              const characters = _CanvasTextMetrics2.wordWrapSplit(token);
              for (let j2 = 0; j2 < characters.length; j2++) {
                let char = characters[j2];
                let lastChar = char;
                let k2 = 1;
                while (characters[j2 + k2]) {
                  const nextChar = characters[j2 + k2];
                  if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  lastChar = nextChar;
                  k2++;
                }
                j2 += k2 - 1;
                const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context2);
                if (characterWidth + width > wordWrapWidth) {
                  lines += _CanvasTextMetrics2._addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width = 0;
                }
                line += char;
                width += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              const isLastToken = i2 === tokens.length - 1;
              lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
          } else {
            if (tokenWidth + width > wordWrapWidth) {
              canPrependSpaces = false;
              lines += _CanvasTextMetrics2._addLine(line);
              line = "";
              width = 0;
            }
            if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
              line += token;
              width += tokenWidth;
            }
          }
        }
        lines += _CanvasTextMetrics2._addLine(line, false);
        return lines;
      }
      /**
       * Convenience function for logging each line added during the wordWrap method.
       * @param line    - The line of text to add
       * @param newLine - Add new line character to end
       * @returns A formatted line
       */
      static _addLine(line, newLine = true) {
        line = _CanvasTextMetrics2._trimRight(line);
        line = newLine ? `${line}
` : line;
        return line;
      }
      /**
       * Gets & sets the widths of calculated characters in a cache object
       * @param key            - The key
       * @param letterSpacing  - The letter spacing
       * @param cache          - The cache
       * @param context        - The canvas context
       * @returns The from cache.
       */
      static _getFromCache(key, letterSpacing, cache, context2) {
        let width = cache[key];
        if (typeof width !== "number") {
          width = _CanvasTextMetrics2._measureText(key, letterSpacing, context2) + letterSpacing;
          cache[key] = width;
        }
        return width;
      }
      /**
       * Determines whether we should collapse breaking spaces.
       * @param whiteSpace - The TextStyle property whiteSpace
       * @returns Should collapse
       */
      static _collapseSpaces(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      }
      /**
       * Determines whether we should collapse newLine chars.
       * @param whiteSpace - The white space
       * @returns should collapse
       */
      static _collapseNewlines(whiteSpace) {
        return whiteSpace === "normal";
      }
      /**
       * Trims breaking whitespaces from string.
       * @param text - The text
       * @returns Trimmed string
       */
      static _trimRight(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (let i2 = text.length - 1; i2 >= 0; i2--) {
          const char = text[i2];
          if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      }
      /**
       * Determines if char is a newline.
       * @param char - The character
       * @returns True if newline, False otherwise.
       */
      static _isNewline(char) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
      }
      /**
       * Determines if char is a breaking whitespace.
       *
       * It allows one to determine whether char should be a breaking whitespace
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param char - The character
       * @param [_nextChar] - The next character
       * @returns True if whitespace, False otherwise.
       */
      static isBreakingSpace(char, _nextChar) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
      }
      /**
       * Splits a string into words, breaking-spaces and newLine characters
       * @param text - The text
       * @returns A tokenized array
       */
      static _tokenize(text) {
        const tokens = [];
        let token = "";
        if (typeof text !== "string") {
          return tokens;
        }
        for (let i2 = 0; i2 < text.length; i2++) {
          const char = text[i2];
          const nextChar = text[i2 + 1];
          if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
            if (token !== "") {
              tokens.push(token);
              token = "";
            }
            if (char === "\r" && nextChar === "\n") {
              tokens.push("\r\n");
              i2++;
            } else {
              tokens.push(char);
            }
            continue;
          }
          token += char;
        }
        if (token !== "") {
          tokens.push(token);
        }
        return tokens;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to customise which words should break
       * Examples are if the token is CJK or numbers.
       * It must return a boolean.
       * @param _token - The token
       * @param breakWords - The style attr break words
       * @returns Whether to break word or not
       */
      static canBreakWords(_token, breakWords) {
        return breakWords;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to determine whether a pair of characters
       * should be broken by newlines
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param _char - The character
       * @param _nextChar - The next character
       * @param _token - The token/word the characters are from
       * @param _index - The index in the token of the char
       * @param _breakWords - The style attr break words
       * @returns whether to break word or not
       */
      static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It is called when a token (usually a word) has to be split into separate pieces
       * in order to determine the point to break a word.
       * It must return an array of characters.
       * @param token - The token to split
       * @returns The characters of the token
       * @see CanvasTextMetrics.graphemeSegmenter
       */
      static wordWrapSplit(token) {
        return _CanvasTextMetrics2.graphemeSegmenter(token);
      }
      /**
       * Calculates the ascent, descent and fontSize of a given font-style
       * @param font - String representing the style of the font
       * @returns Font properties object
       */
      static measureFont(font) {
        if (_CanvasTextMetrics2._fonts[font]) {
          return _CanvasTextMetrics2._fonts[font];
        }
        const context2 = _CanvasTextMetrics2._context;
        context2.font = font;
        const metrics = context2.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
        const properties = {
          ascent: metrics.actualBoundingBoxAscent,
          descent: metrics.actualBoundingBoxDescent,
          fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
        };
        _CanvasTextMetrics2._fonts[font] = properties;
        return properties;
      }
      /**
       * Clear font metrics in metrics cache.
       * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
       */
      static clearMetrics(font = "") {
        if (font) {
          delete _CanvasTextMetrics2._fonts[font];
        } else {
          _CanvasTextMetrics2._fonts = {};
        }
      }
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _canvas() {
        if (!_CanvasTextMetrics2.__canvas) {
          let canvas;
          try {
            const c2 = new OffscreenCanvas(0, 0);
            const context2 = c2.getContext("2d", contextSettings);
            if (context2?.measureText) {
              _CanvasTextMetrics2.__canvas = c2;
              return c2;
            }
            canvas = DOMAdapter.get().createCanvas();
          } catch (_cx) {
            canvas = DOMAdapter.get().createCanvas();
          }
          canvas.width = canvas.height = 10;
          _CanvasTextMetrics2.__canvas = canvas;
        }
        return _CanvasTextMetrics2.__canvas;
      }
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _context() {
        if (!_CanvasTextMetrics2.__context) {
          _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
        }
        return _CanvasTextMetrics2.__context;
      }
    };
    _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
    _CanvasTextMetrics.BASELINE_SYMBOL = "M";
    _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
    _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
    _CanvasTextMetrics.graphemeSegmenter = (() => {
      if (typeof Intl?.Segmenter === "function") {
        const segmenter = new Intl.Segmenter();
        return (s2) => {
          const segments = segmenter.segment(s2);
          const result = [];
          let i2 = 0;
          for (const segment of segments) {
            result[i2++] = segment.segment;
          }
          return result;
        };
      }
      return (s2) => [...s2];
    })();
    _CanvasTextMetrics.experimentalLetterSpacing = false;
    _CanvasTextMetrics._fonts = {};
    _CanvasTextMetrics._newlines = [
      10,
      // line feed
      13
      // carriage return
    ];
    _CanvasTextMetrics._breakingSpaces = [
      9,
      // character tabulation
      32,
      // space
      8192,
      // en quad
      8193,
      // em quad
      8194,
      // en space
      8195,
      // em space
      8196,
      // three-per-em space
      8197,
      // four-per-em space
      8198,
      // six-per-em space
      8200,
      // punctuation space
      8201,
      // thin space
      8202,
      // hair space
      8287,
      // medium mathematical space
      12288
      // ideographic space
    ];
    _CanvasTextMetrics._measurementCache = lru(1e3);
    CanvasTextMetrics = _CanvasTextMetrics;
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
function getCanvasFillStyle(fillStyle, context2, textMetrics, padding = 0) {
  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
    return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
  } else if (!fillStyle.fill) {
    const pattern = context2.createPattern(fillStyle.texture.source.resource, "repeat");
    const tempMatrix7 = fillStyle.matrix.copyTo(Matrix.shared);
    tempMatrix7.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
    pattern.setTransform(tempMatrix7);
    return pattern;
  } else if (fillStyle.fill instanceof FillPattern) {
    const fillPattern = fillStyle.fill;
    const pattern = context2.createPattern(fillPattern.texture.source.resource, "repeat");
    const tempMatrix7 = fillPattern.transform.copyTo(Matrix.shared);
    tempMatrix7.scale(
      fillPattern.texture.frame.width,
      fillPattern.texture.frame.height
    );
    pattern.setTransform(tempMatrix7);
    return pattern;
  } else if (fillStyle.fill instanceof FillGradient) {
    const fillGradient = fillStyle.fill;
    const isLinear = fillGradient.type === "linear";
    const isLocal = fillGradient.textureSpace === "local";
    let width = 1;
    let height = 1;
    if (isLocal && textMetrics) {
      width = textMetrics.width + padding;
      height = textMetrics.height + padding;
    }
    let gradient;
    let isNearlyVertical = false;
    if (isLinear) {
      const { start, end } = fillGradient;
      gradient = context2.createLinearGradient(
        start.x * width,
        start.y * height,
        end.x * width,
        end.y * height
      );
      isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);
    } else {
      const { center, innerRadius, outerCenter, outerRadius } = fillGradient;
      gradient = context2.createRadialGradient(
        center.x * width,
        center.y * height,
        innerRadius * width,
        outerCenter.x * width,
        outerCenter.y * height,
        outerRadius * width
      );
    }
    if (isNearlyVertical && isLocal && textMetrics) {
      const ratio = textMetrics.lineHeight / height;
      for (let i2 = 0; i2 < textMetrics.lines.length; i2++) {
        const start = (i2 * textMetrics.lineHeight + padding / 2) / height;
        fillGradient.colorStops.forEach((stop) => {
          const globalStop = start + stop.offset * ratio;
          gradient.addColorStop(
            // fix to 5 decimal places to avoid floating point precision issues
            Math.floor(globalStop * PRECISION) / PRECISION,
            Color.shared.setValue(stop.color).toHex()
          );
        });
      }
    } else {
      fillGradient.colorStops.forEach((stop) => {
        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
      });
    }
    return gradient;
  }
  warn("FillStyle not recognised", fillStyle);
  return "red";
}
var PRECISION;
var init_getCanvasFillStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
    init_Color();
    init_Matrix();
    init_Texture();
    init_warn();
    init_FillGradient();
    init_FillPattern();
    PRECISION = 1e5;
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs
var tempRect4, CanvasTextGeneratorClass, CanvasTextGenerator;
var init_CanvasTextGenerator = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs"() {
    init_Color();
    init_Rectangle();
    init_CanvasPool();
    init_getCanvasBoundingBox();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    tempRect4 = new Rectangle();
    CanvasTextGeneratorClass = class {
      /**
       * Creates a canvas with the specified text rendered to it.
       *
       * Generates a canvas of appropriate size, renders the text with the provided style,
       * and returns both the canvas/context and a Rectangle representing the text bounds.
       *
       * When trim is enabled in the style, the frame will represent the bounds of the
       * non-transparent pixels, which can be smaller than the full canvas.
       * @param options - The options for generating the text canvas
       * @param options.text - The text to render
       * @param options.style - The style to apply to the text
       * @param options.resolution - The resolution of the canvas (defaults to 1)
       * @param options.padding
       * @returns An object containing the canvas/context and the frame (bounds) of the text
       */
      getCanvasAndContext(options) {
        const { text, style, resolution = 1 } = options;
        const padding = style._getFinalPadding();
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + padding * 2) * resolution);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
        this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);
        const frame = style.trim ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect4 }) : tempRect4.set(0, 0, width, height);
        return {
          canvasAndContext,
          frame
        };
      }
      /**
       * Returns a canvas and context to the pool.
       *
       * This should be called when you're done with the canvas to allow reuse
       * and prevent memory leaks.
       * @param canvasAndContext - The canvas and context to return to the pool
       */
      returnCanvasAndContext(canvasAndContext) {
        CanvasPool.returnCanvasAndContext(canvasAndContext);
      }
      /**
       * Renders text to its canvas, and updates its texture.
       * @param text - The text to render
       * @param style - The style of the text
       * @param padding - The padding of the text
       * @param resolution - The resolution of the text
       * @param canvasAndContext - The canvas and context to render the text to
       */
      _renderTextToCanvas(text, style, padding, resolution, canvasAndContext) {
        const { canvas, context: context2 } = canvasAndContext;
        const font = fontStringFromTextStyle(style);
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const lines = measured.lines;
        const lineHeight = measured.lineHeight;
        const lineWidths = measured.lineWidths;
        const maxLineWidth = measured.maxLineWidth;
        const fontProperties = measured.fontProperties;
        const height = canvas.height;
        context2.resetTransform();
        context2.scale(resolution, resolution);
        context2.textBaseline = style.textBaseline;
        if (style._stroke?.width) {
          const strokeStyle = style._stroke;
          context2.lineWidth = strokeStyle.width;
          context2.miterLimit = strokeStyle.miterLimit;
          context2.lineJoin = strokeStyle.join;
          context2.lineCap = strokeStyle.cap;
        }
        context2.font = font;
        let linePositionX;
        let linePositionY;
        const passesCount = style.dropShadow ? 2 : 1;
        for (let i2 = 0; i2 < passesCount; ++i2) {
          const isShadowPass = style.dropShadow && i2 === 0;
          const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + padding * 2) : 0;
          const dsOffsetShadow = dsOffsetText * resolution;
          if (isShadowPass) {
            context2.fillStyle = "black";
            context2.strokeStyle = "black";
            const shadowOptions = style.dropShadow;
            const dropShadowColor = shadowOptions.color;
            const dropShadowAlpha = shadowOptions.alpha;
            context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context2.shadowBlur = dropShadowBlur;
            context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
          } else {
            context2.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context2, measured, padding * 2) : null;
            if (style._stroke?.width) {
              const strokePadding = style._stroke.width * 0.5 + padding * 2;
              context2.strokeStyle = getCanvasFillStyle(style._stroke, context2, measured, strokePadding);
            }
            context2.shadowColor = "black";
          }
          let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
          if (lineHeight - fontProperties.fontSize < 0) {
            linePositionYShift = 0;
          }
          const strokeWidth = style._stroke?.width ?? 0;
          for (let i22 = 0; i22 < lines.length; i22++) {
            linePositionX = strokeWidth / 2;
            linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i22];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
            }
            if (style._stroke?.width) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + padding,
                linePositionY + padding - dsOffsetText,
                true
              );
            }
            if (style._fill !== void 0) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + padding,
                linePositionY + padding - dsOffsetText
              );
            }
          }
        }
      }
      /**
       * Render the text with letter-spacing.
       *
       * This method handles rendering text with the correct letter spacing, using either:
       * 1. Native letter spacing if supported by the browser
       * 2. Manual letter spacing calculation if not natively supported
       *
       * For manual letter spacing, it calculates the position of each character
       * based on its width and the desired spacing.
       * @param text - The text to draw
       * @param style - The text style to apply
       * @param canvasAndContext - The canvas and context to draw to
       * @param x - Horizontal position to draw the text
       * @param y - Vertical position to draw the text
       * @param isStroke - Whether to render the stroke (true) or fill (false)
       * @private
       */
      _drawLetterSpacing(text, style, canvasAndContext, x2, y2, isStroke = false) {
        const { context: context2 } = canvasAndContext;
        const letterSpacing = style.letterSpacing;
        let useExperimentalLetterSpacing = false;
        if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
          if (CanvasTextMetrics.experimentalLetterSpacing) {
            context2.letterSpacing = `${letterSpacing}px`;
            context2.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context2.letterSpacing = "0px";
            context2.textLetterSpacing = "0px";
          }
        }
        if (letterSpacing === 0 || useExperimentalLetterSpacing) {
          if (isStroke) {
            context2.strokeText(text, x2, y2);
          } else {
            context2.fillText(text, x2, y2);
          }
          return;
        }
        let currentPosition = x2;
        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
        let previousWidth = context2.measureText(text).width;
        let currentWidth = 0;
        for (let i2 = 0; i2 < stringArray.length; ++i2) {
          const currentChar = stringArray[i2];
          if (isStroke) {
            context2.strokeText(currentChar, currentPosition, y2);
          } else {
            context2.fillText(currentChar, currentPosition, y2);
          }
          let textStr = "";
          for (let j2 = i2 + 1; j2 < stringArray.length; ++j2) {
            textStr += stringArray[j2];
          }
          currentWidth = context2.measureText(textStr).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      }
    };
    CanvasTextGenerator = new CanvasTextGeneratorClass();
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
var CanvasTextSystem;
var init_CanvasTextSystem = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
    init_Extensions();
    init_TexturePool();
    init_TextureStyle();
    init_deprecation();
    init_TextStyle();
    init_getPo2TextureFromSource();
    init_CanvasTextGenerator();
    CanvasTextSystem = class {
      constructor(_renderer) {
        this._activeTextures = {};
        this._renderer = _renderer;
      }
      getTexture(options, _resolution, _style, _textKey) {
        if (typeof options === "string") {
          deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
          options = {
            text: options,
            style: _style,
            resolution: _resolution
          };
        }
        if (!(options.style instanceof TextStyle)) {
          options.style = new TextStyle(options.style);
        }
        if (!(options.textureStyle instanceof TextureStyle)) {
          options.textureStyle = new TextureStyle(options.textureStyle);
        }
        if (typeof options.text !== "string") {
          options.text = options.text.toString();
        }
        const { text, style, textureStyle } = options;
        const resolution = options.resolution ?? this._renderer.resolution;
        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({
          text,
          style,
          resolution
        });
        const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);
        if (textureStyle)
          texture.source.style = textureStyle;
        if (style.trim) {
          frame.pad(style.padding);
          texture.frame.copyFrom(frame);
          texture.frame.scale(1 / resolution);
          texture.updateUvs();
        }
        if (style.filters) {
          const filteredTexture = this._applyFilters(texture, style.filters);
          this.returnTexture(texture);
          CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
          return filteredTexture;
        }
        this._renderer.texture.initSource(texture._source);
        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
        return texture;
      }
      /**
       * Returns a texture that was created wit the above `getTexture` function.
       * Handy if you are done with a texture and want to return it to the pool.
       * @param texture - The texture to be returned.
       */
      returnTexture(texture) {
        const source3 = texture.source;
        source3.resource = null;
        source3.uploadMethodId = "unknown";
        source3.alphaMode = "no-premultiply-alpha";
        TexturePool.returnTexture(texture, true);
      }
      /**
       * Renders text to its canvas, and updates its texture.
       * @deprecated since 8.10.0
       */
      renderTextToCanvas() {
        deprecation(
          "8.10.0",
          "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead"
        );
      }
      /**
       * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.
       * @param text - The Text object that needs a texture
       * @returns A Texture instance that represents the rendered text
       * @remarks
       * This method performs the following:
       * 1. Sets the appropriate resolution based on auto-resolution settings
       * 2. Checks if a texture already exists for the text's style
       * 3. Creates a new texture if needed or returns an existing one
       * 4. Manages reference counting for texture reuse
       */
      getManagedTexture(text) {
        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
        const textKey = text.styleKey;
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].texture;
        }
        const texture = this.getTexture({
          text: text.text,
          style: text.style,
          resolution: text._resolution,
          textureStyle: text.textureStyle
        });
        this._activeTextures[textKey] = {
          texture,
          usageCount: 1
        };
        return texture;
      }
      /**
       * Decreases the reference count for a texture associated with a text key.
       * When the reference count reaches zero, the texture is returned to the pool.
       * @param textKey - The unique key identifying the text style configuration
       * @remarks
       * This method is crucial for memory management, ensuring textures are properly
       * cleaned up when they are no longer needed by any Text instances.
       */
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          this.returnTexture(activeTexture.texture);
          this._activeTextures[textKey] = null;
        }
      }
      /**
       * Gets the current reference count for a texture associated with a text key.
       * @param textKey - The unique key identifying the text style configuration
       * @returns The number of Text instances currently using this texture
       */
      getReferenceCount(textKey) {
        return this._activeTextures[textKey]?.usageCount ?? 0;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      /**
       * Applies the specified filters to the given texture.
       *
       * This method takes a texture and a list of filters, applies the filters to the texture,
       * and returns the resulting texture. It also ensures that the alpha mode of the resulting
       * texture is set to 'premultiplied-alpha'.
       * @param {Texture} texture - The texture to which the filters will be applied.
       * @param {Filter[]} filters - The filters to apply to the texture.
       * @returns {Texture} The resulting texture after all filters have been applied.
       */
      _applyFilters(texture, filters) {
        const currentRenderTarget = this._renderer.renderTarget.renderTarget;
        const resultTexture = this._renderer.filter.generateFilteredTexture({
          texture,
          filters
        });
        this._renderer.renderTarget.bind(currentRenderTarget, false);
        return resultTexture;
      }
      destroy() {
        this._renderer = null;
        for (const key in this._activeTextures) {
          if (this._activeTextures[key])
            this.returnTexture(this._activeTextures[key].texture);
        }
        this._activeTextures = null;
      }
    };
    CanvasTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "canvasText"
    };
  }
});

// node_modules/pixi.js/lib/scene/text/init.mjs
var init_init10 = __esm({
  "node_modules/pixi.js/lib/scene/text/init.mjs"() {
    init_Extensions();
    init_CanvasTextPipe();
    init_CanvasTextSystem();
    extensions.add(CanvasTextSystem);
    extensions.add(CanvasTextPipe);
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
var Graphics;
var init_Graphics = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"() {
    init_deprecation();
    init_ViewContainer();
    init_GraphicsContext();
    Graphics = class _Graphics extends ViewContainer {
      /**
       * Creates a new Graphics object.
       * @param options - Options for the Graphics.
       */
      constructor(options) {
        if (options instanceof GraphicsContext) {
          options = { context: options };
        }
        const { context: context2, roundPixels, ...rest } = options || {};
        super({
          label: "Graphics",
          ...rest
        });
        this.renderPipeId = "graphics";
        if (!context2) {
          this._context = this._ownedContext = new GraphicsContext();
        } else {
          this._context = context2;
        }
        this._context.on("update", this.onViewUpdate, this);
        this.didViewUpdate = true;
        this.allowChildren = false;
        this.roundPixels = roundPixels ?? false;
      }
      set context(context2) {
        if (context2 === this._context)
          return;
        this._context.off("update", this.onViewUpdate, this);
        this._context = context2;
        this._context.on("update", this.onViewUpdate, this);
        this.onViewUpdate();
      }
      /**
       * The underlying graphics context used for drawing operations.
       * Controls how shapes and paths are rendered.
       * @example
       * ```ts
       * // Create a shared context
       * const sharedContext = new GraphicsContext();
       *
       * // Create graphics objects sharing the same context
       * const graphics1 = new Graphics();
       * const graphics2 = new Graphics();
       *
       * // Assign shared context
       * graphics1.context = sharedContext;
       * graphics2.context = sharedContext;
       *
       * // Both graphics will show the same shapes
       * sharedContext
       *     .rect(0, 0, 100, 100)
       *     .fill({ color: 0xff0000 });
       * ```
       * @see {@link GraphicsContext} For drawing operations
       * @see {@link GraphicsOptions} For context configuration
       */
      get context() {
        return this._context;
      }
      /**
       * The local bounds of the graphics object.
       * Returns the boundaries after all graphical operations but before any transforms.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Draw a shape
       * graphics
       *     .rect(0, 0, 100, 100)
       *     .fill({ color: 0xff0000 });
       *
       * // Get bounds information
       * const bounds = graphics.bounds;
       * console.log(bounds.width);  // 100
       * console.log(bounds.height); // 100
       * ```
       * @readonly
       * @see {@link Bounds} For bounds operations
       * @see {@link Container#getBounds} For transformed bounds
       */
      get bounds() {
        return this._context.bounds;
      }
      /**
       * Graphics objects do not need to update their bounds as the context handles this.
       * @private
       */
      updateBounds() {
      }
      /**
       * Checks if the object contains the given point.
       * Returns true if the point lies within the Graphics object's rendered area.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Draw a shape
       * graphics
       *     .rect(0, 0, 100, 100)
       *     .fill({ color: 0xff0000 });
       *
       * // Check point intersection
       * if (graphics.containsPoint({ x: 50, y: 50 })) {
       *     console.log('Point is inside rectangle!');
       * }
       * ```
       * @param point - The point to check in local coordinates
       * @returns True if the point is inside the Graphics object
       * @see {@link Graphics#bounds} For bounding box checks
       * @see {@link PointData} For point data structure
       */
      containsPoint(point) {
        return this._context.containsPoint(point);
      }
      /**
       * Destroys this graphics renderable and optionally its context.
       * @param options - Options parameter. A boolean will act as if all options
       *
       * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
       * then the context will still be destroyed.
       *
       * If you want to explicitly not destroy this context that this graphics created,
       * then you should pass destroy({ context: false })
       *
       * If the context was passed in as an argument to the constructor then it will not be destroyed
       * @example
       * ```ts
       * // Destroy the graphics and its context
       * graphics.destroy();
       * graphics.destroy(true);
       * graphics.destroy({ context: true, texture: true, textureSource: true });
       * ```
       */
      destroy(options) {
        if (this._ownedContext && !options) {
          this._ownedContext.destroy(options);
        } else if (options === true || options?.context === true) {
          this._context.destroy(options);
        }
        this._ownedContext = null;
        this._context = null;
        super.destroy(options);
      }
      _callContextMethod(method, args) {
        this.context[method](...args);
        return this;
      }
      // --------------------------------------- GraphicsContext methods ---------------------------------------
      /**
       * Sets the current fill style of the graphics context.
       * The fill style can be a color, gradient, pattern, or a complex style object.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Basic color fill
       * graphics
       *     .setFillStyle({ color: 0xff0000 }) // Red fill
       *     .rect(0, 0, 100, 100)
       *     .fill();
       *
       * // Gradient fill
       * const gradient = new FillGradient({
       *    end: { x: 1, y: 0 },
       *    colorStops: [
       *         { offset: 0, color: 0xff0000 }, // Red at start
       *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
       *         { offset: 1, color: 0x0000ff }, // Blue at end
       *    ],
       * });
       *
       * graphics
       *     .setFillStyle(gradient)
       *     .circle(100, 100, 50)
       *     .fill();
       *
       * // Pattern fill
       * const pattern = new FillPattern(texture);
       * graphics
       *     .setFillStyle({
       *         fill: pattern,
       *         alpha: 0.5
       *     })
       *     .rect(0, 0, 200, 200)
       *     .fill();
       * ```
       * @param {FillInput} args - The fill style to apply
       * @returns The Graphics instance for chaining
       * @see {@link FillStyle} For fill style options
       * @see {@link FillGradient} For gradient fills
       * @see {@link FillPattern} For pattern fills
       */
      setFillStyle(...args) {
        return this._callContextMethod("setFillStyle", args);
      }
      /**
       * Sets the current stroke style of the graphics context.
       * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Basic color stroke
       * graphics
       *     .setStrokeStyle({
       *         width: 2,
       *         color: 0x000000
       *     })
       *     .rect(0, 0, 100, 100)
       *     .stroke();
       *
       * // Complex stroke style
       * graphics
       *     .setStrokeStyle({
       *         width: 4,
       *         color: 0xff0000,
       *         alpha: 0.5,
       *         join: 'round',
       *         cap: 'round',
       *         alignment: 0.5
       *     })
       *     .circle(100, 100, 50)
       *     .stroke();
       *
       * // Gradient stroke
       * const gradient = new FillGradient({
       *    end: { x: 1, y: 0 },
       *    colorStops: [
       *         { offset: 0, color: 0xff0000 }, // Red at start
       *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
       *         { offset: 1, color: 0x0000ff }, // Blue at end
       *    ],
       * });
       *
       * graphics
       *     .setStrokeStyle({
       *         width: 10,
       *         fill: gradient
       *     })
       *     .poly([0,0, 100,50, 0,100])
       *     .stroke();
       * ```
       * @param {StrokeInput} args - The stroke style to apply
       * @returns The Graphics instance for chaining
       * @see {@link StrokeStyle} For stroke style options
       * @see {@link FillGradient} For gradient strokes
       * @see {@link FillPattern} For pattern strokes
       */
      setStrokeStyle(...args) {
        return this._callContextMethod("setStrokeStyle", args);
      }
      fill(...args) {
        return this._callContextMethod("fill", args);
      }
      /**
       * Strokes the current path with the current stroke style or specified style.
       * Outlines the shape using the stroke settings.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Stroke with direct color
       * graphics
       *     .circle(50, 50, 25)
       *     .stroke({
       *         width: 2,
       *         color: 0xff0000
       *     }); // 2px red stroke
       *
       * // Fill with texture
       * graphics
       *    .rect(0, 0, 100, 100)
       *    .stroke(myTexture); // Fill with texture
       *
       * // Stroke with gradient
       * const gradient = new FillGradient({
       *     end: { x: 1, y: 0 },
       *     colorStops: [
       *         { offset: 0, color: 0xff0000 },
       *         { offset: 0.5, color: 0x00ff00 },
       *         { offset: 1, color: 0x0000ff },
       *     ],
       * });
       *
       * graphics
       *     .rect(0, 0, 100, 100)
       *     .stroke({
       *         width: 4,
       *         fill: gradient,
       *         alignment: 0.5,
       *         join: 'round'
       *     });
       * ```
       * @param {StrokeStyle} args - Optional stroke style to apply. Can be:
       * - A stroke style object with width, color, etc.
       * - A gradient
       * - A pattern
       * If omitted, uses current stroke style.
       * @returns The Graphics instance for chaining
       * @see {@link StrokeStyle} For stroke style options
       * @see {@link FillGradient} For gradient strokes
       * @see {@link setStrokeStyle} For setting default stroke style
       */
      stroke(...args) {
        return this._callContextMethod("stroke", args);
      }
      texture(...args) {
        return this._callContextMethod("texture", args);
      }
      /**
       * Resets the current path. Any previous path and its commands are discarded and a new path is
       * started. This is typically called before beginning a new shape or series of drawing commands.
       * @example
       * ```ts
       * const graphics = new Graphics();
       * graphics
       *     .circle(150, 150, 50)
       *     .fill({ color: 0x00ff00 })
       *     .beginPath() // Starts a new path
       *     .circle(250, 150, 50)
       *     .fill({ color: 0x0000ff });
       * ```
       * @returns The Graphics instance for chaining
       * @see {@link Graphics#moveTo} For starting a new subpath
       * @see {@link Graphics#closePath} For closing the current path
       */
      beginPath() {
        return this._callContextMethod("beginPath", []);
      }
      /**
       * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
       * subtracting a path from the previously drawn path.
       *
       * If a hole is not completely in a shape, it will fail to cut correctly.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Draw outer circle
       * graphics
       *     .circle(100, 100, 50)
       *     .fill({ color: 0xff0000 });
       *     .circle(100, 100, 25) // Inner circle
       *     .cut() // Cuts out the inner circle from the outer circle
       * ```
       */
      cut() {
        return this._callContextMethod("cut", []);
      }
      arc(...args) {
        return this._callContextMethod("arc", args);
      }
      arcTo(...args) {
        return this._callContextMethod("arcTo", args);
      }
      arcToSvg(...args) {
        return this._callContextMethod("arcToSvg", args);
      }
      bezierCurveTo(...args) {
        return this._callContextMethod("bezierCurveTo", args);
      }
      /**
       * Closes the current path by drawing a straight line back to the start point.
       *
       * This is useful for completing shapes and ensuring they are properly closed for fills.
       * @example
       * ```ts
       * // Create a triangle with closed path
       * const graphics = new Graphics();
       * graphics
       *     .moveTo(50, 50)
       *     .lineTo(100, 100)
       *     .lineTo(0, 100)
       *     .closePath()
       * ```
       * @returns The Graphics instance for method chaining
       * @see {@link Graphics#beginPath} For starting a new path
       * @see {@link Graphics#fill} For filling closed paths
       * @see {@link Graphics#stroke} For stroking paths
       */
      closePath() {
        return this._callContextMethod("closePath", []);
      }
      ellipse(...args) {
        return this._callContextMethod("ellipse", args);
      }
      circle(...args) {
        return this._callContextMethod("circle", args);
      }
      path(...args) {
        return this._callContextMethod("path", args);
      }
      lineTo(...args) {
        return this._callContextMethod("lineTo", args);
      }
      moveTo(...args) {
        return this._callContextMethod("moveTo", args);
      }
      quadraticCurveTo(...args) {
        return this._callContextMethod("quadraticCurveTo", args);
      }
      rect(...args) {
        return this._callContextMethod("rect", args);
      }
      roundRect(...args) {
        return this._callContextMethod("roundRect", args);
      }
      poly(...args) {
        return this._callContextMethod("poly", args);
      }
      regularPoly(...args) {
        return this._callContextMethod("regularPoly", args);
      }
      roundPoly(...args) {
        return this._callContextMethod("roundPoly", args);
      }
      roundShape(...args) {
        return this._callContextMethod("roundShape", args);
      }
      filletRect(...args) {
        return this._callContextMethod("filletRect", args);
      }
      chamferRect(...args) {
        return this._callContextMethod("chamferRect", args);
      }
      star(...args) {
        return this._callContextMethod("star", args);
      }
      svg(...args) {
        return this._callContextMethod("svg", args);
      }
      restore(...args) {
        return this._callContextMethod("restore", args);
      }
      /**
       * Saves the current graphics state onto a stack. The state includes:
       * - Current transformation matrix
       * - Current fill style
       * - Current stroke style
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Save state before complex operations
       * graphics.save();
       *
       * // Create transformed and styled shape
       * graphics
       *     .translateTransform(100, 100)
       *     .rotateTransform(Math.PI / 4)
       *     .setFillStyle({
       *         color: 0xff0000,
       *         alpha: 0.5
       *     })
       *     .rect(-25, -25, 50, 50)
       *     .fill();
       *
       * // Restore to original state
       * graphics.restore();
       *
       * // Continue drawing with previous state
       * graphics
       *     .circle(50, 50, 25)
       *     .fill();
       * ```
       * @returns The Graphics instance for method chaining
       * @see {@link Graphics#restore} For restoring the saved state
       * @see {@link Graphics#setTransform} For setting transformations
       */
      save() {
        return this._callContextMethod("save", []);
      }
      /**
       * Returns the current transformation matrix of the graphics context.
       * This matrix represents all accumulated transformations including translate, scale, and rotate.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Apply some transformations
       * graphics
       *     .translateTransform(100, 100)
       *     .rotateTransform(Math.PI / 4);
       *
       * // Get the current transform matrix
       * const matrix = graphics.getTransform();
       * console.log(matrix.tx, matrix.ty); // 100, 100
       *
       * // Use the matrix for other operations
       * graphics
       *     .setTransform(matrix)
       *     .circle(0, 0, 50)
       *     .fill({ color: 0xff0000 });
       * ```
       * @returns The current transformation matrix.
       * @see {@link Graphics#setTransform} For setting the transform matrix
       * @see {@link Matrix} For matrix operations
       */
      getTransform() {
        return this.context.getTransform();
      }
      /**
       * Resets the current transformation matrix to the identity matrix, effectively removing
       * any transformations (rotation, scaling, translation) previously applied.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Apply transformations
       * graphics
       *     .translateTransform(100, 100)
       *     .scaleTransform(2, 2)
       *     .circle(0, 0, 25)
       *     .fill({ color: 0xff0000 });
       * // Reset transform to default state
       * graphics
       *     .resetTransform()
       *     .circle(50, 50, 25) // Will draw at actual coordinates
       *     .fill({ color: 0x00ff00 });
       * ```
       * @returns The Graphics instance for method chaining
       * @see {@link Graphics#getTransform} For getting the current transform
       * @see {@link Graphics#setTransform} For setting a specific transform
       * @see {@link Graphics#save} For saving the current transform state
       * @see {@link Graphics#restore} For restoring a previous transform state
       */
      resetTransform() {
        return this._callContextMethod("resetTransform", []);
      }
      rotateTransform(...args) {
        return this._callContextMethod("rotate", args);
      }
      scaleTransform(...args) {
        return this._callContextMethod("scale", args);
      }
      setTransform(...args) {
        return this._callContextMethod("setTransform", args);
      }
      transform(...args) {
        return this._callContextMethod("transform", args);
      }
      translateTransform(...args) {
        return this._callContextMethod("translate", args);
      }
      /**
       * Clears all drawing commands from the graphics context, effectively resetting it.
       * This includes clearing the current path, fill style, stroke style, and transformations.
       *
       * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.
       * > Instead, they are intended to be used for static or semi-static graphics that
       * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Draw some shapes
       * graphics
       *     .circle(100, 100, 50)
       *     .fill({ color: 0xff0000 })
       *     .rect(200, 100, 100, 50)
       *     .fill({ color: 0x00ff00 });
       *
       * // Clear all graphics
       * graphics.clear();
       *
       * // Start fresh with new shapes
       * graphics
       *     .circle(150, 150, 30)
       *     .fill({ color: 0x0000ff });
       * ```
       * @returns The Graphics instance for method chaining
       * @see {@link Graphics#beginPath} For starting a new path without clearing styles
       * @see {@link Graphics#save} For saving the current state
       * @see {@link Graphics#restore} For restoring a previous state
       */
      clear() {
        return this._callContextMethod("clear", []);
      }
      /**
       * Gets or sets the current fill style for the graphics context. The fill style determines
       * how shapes are filled when using the fill() method.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Basic color fill
       * graphics.fillStyle = {
       *     color: 0xff0000,  // Red
       *     alpha: 1
       * };
       *
       * // Using gradients
       * const gradient = new FillGradient({
       *     end: { x: 0, y: 1 }, // Vertical gradient
       *     stops: [
       *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color
       *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color
       *     ]
       * });
       *
       * graphics.fillStyle = {
       *     fill: gradient,
       *     alpha: 0.8
       * };
       *
       * // Using patterns
       * graphics.fillStyle = {
       *     texture: myTexture,
       *     alpha: 1,
       *     matrix: new Matrix()
       *         .scale(0.5, 0.5)
       *         .rotate(Math.PI / 4)
       * };
       * ```
       * @type {ConvertedFillStyle}
       * @see {@link FillStyle} For all available fill style options
       * @see {@link FillGradient} For creating gradient fills
       * @see {@link Graphics#fill} For applying the fill to paths
       */
      get fillStyle() {
        return this._context.fillStyle;
      }
      set fillStyle(value) {
        this._context.fillStyle = value;
      }
      /**
       * Gets or sets the current stroke style for the graphics context. The stroke style determines
       * how paths are outlined when using the stroke() method.
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Basic stroke style
       * graphics.strokeStyle = {
       *     width: 2,
       *     color: 0xff0000,
       *     alpha: 1
       * };
       *
       * // Using with gradients
       * const gradient = new FillGradient({
       *   end: { x: 0, y: 1 },
       *   stops: [
       *       { offset: 0, color: 0xff0000, alpha: 1 },
       *       { offset: 1, color: 0x0000ff, alpha: 1 }
       *   ]
       * });
       *
       * graphics.strokeStyle = {
       *     width: 4,
       *     fill: gradient,
       *     alignment: 0.5,
       *     join: 'round',
       *     cap: 'round'
       * };
       *
       * // Complex stroke settings
       * graphics.strokeStyle = {
       *     width: 6,
       *     color: 0x00ff00,
       *     alpha: 0.5,
       *     join: 'miter',
       *     miterLimit: 10,
       * };
       * ```
       * @see {@link StrokeStyle} For all available stroke style options
       * @see {@link Graphics#stroke} For applying the stroke to paths
       */
      get strokeStyle() {
        return this._context.strokeStyle;
      }
      set strokeStyle(value) {
        this._context.strokeStyle = value;
      }
      /**
       * Creates a new Graphics object that copies the current graphics content.
       * The clone can either share the same context (shallow clone) or have its own independent
       * context (deep clone).
       * @example
       * ```ts
       * const graphics = new Graphics();
       *
       * // Create original graphics content
       * graphics
       *     .circle(100, 100, 50)
       *     .fill({ color: 0xff0000 });
       *
       * // Create a shallow clone (shared context)
       * const shallowClone = graphics.clone();
       *
       * // Changes to original affect the clone
       * graphics
       *     .circle(200, 100, 30)
       *     .fill({ color: 0x00ff00 });
       *
       * // Create a deep clone (independent context)
       * const deepClone = graphics.clone(true);
       *
       * // Modify deep clone independently
       * deepClone
       *     .translateTransform(100, 100)
       *     .circle(0, 0, 40)
       *     .fill({ color: 0x0000ff });
       * ```
       * @param deep - Whether to create a deep clone of the graphics object.
       *              If false (default), the context will be shared between objects.
       *              If true, creates an independent copy of the context.
       * @returns A new Graphics instance with either shared or copied context
       * @see {@link Graphics#context} For accessing the underlying graphics context
       * @see {@link GraphicsContext} For understanding the shared context behavior
       */
      clone(deep = false) {
        if (deep) {
          return new _Graphics(this._context.clone());
        }
        this._ownedContext = null;
        const clone = new _Graphics(this._context);
        return clone;
      }
      // -------- v7 deprecations ---------
      /**
       * @param width
       * @param color
       * @param alpha
       * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
       */
      lineStyle(width, color, alpha) {
        deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
        const strokeStyle = {};
        width && (strokeStyle.width = width);
        color && (strokeStyle.color = color);
        alpha && (strokeStyle.alpha = alpha);
        this.context.strokeStyle = strokeStyle;
        return this;
      }
      /**
       * @param color
       * @param alpha
       * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
       */
      beginFill(color, alpha) {
        deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        const fillStyle = {};
        if (color !== void 0)
          fillStyle.color = color;
        if (alpha !== void 0)
          fillStyle.alpha = alpha;
        this.context.fillStyle = fillStyle;
        return this;
      }
      /**
       * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
       */
      endFill() {
        deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        this.context.fill();
        const strokeStyle = this.context.strokeStyle;
        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
          this.context.stroke();
        }
        return this;
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
       */
      drawCircle(...args) {
        deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
        return this._callContextMethod("circle", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
       */
      drawEllipse(...args) {
        deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
        return this._callContextMethod("ellipse", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
       */
      drawPolygon(...args) {
        deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
        return this._callContextMethod("poly", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
       */
      drawRect(...args) {
        deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
        return this._callContextMethod("rect", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
       */
      drawRoundedRect(...args) {
        deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
        return this._callContextMethod("roundRect", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#star} instead
       */
      drawStar(...args) {
        deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
        return this._callContextMethod("star", args);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
var localUniformMSDFBit, localUniformMSDFBitGl;
var init_localUniformMSDFBit = __esm({
  "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
    "use strict";
    localUniformMSDFBit = {
      name: "local-uniform-msdf-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
        ),
        main: (
          /* wgsl */
          `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
        )
      }
    };
    localUniformMSDFBitGl = {
      name: "local-uniform-msdf-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `
        ),
        end: (
          /* glsl */
          `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
            uniform float uDistance;
         `
        ),
        main: (
          /* glsl */
          `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
var mSDFBit, mSDFBitGl;
var init_mSDFBit = __esm({
  "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
    "use strict";
    mSDFBit = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* wgsl */
          `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `
        )
      }
    };
    mSDFBitGl = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* glsl */
          `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
var gpuProgram, glProgram, SdfShader;
var init_SdfShader = __esm({
  "node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs"() {
    init_Matrix();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_getBatchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    init_localUniformMSDFBit();
    init_mSDFBit();
    SdfShader = class extends Shader {
      constructor(maxTextures) {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uDistance: { value: 4, type: "f32" },
          uRound: { value: 0, type: "f32" }
        });
        gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({
          name: "sdf-shader",
          bits: [
            colorBit,
            generateTextureBatchBit(maxTextures),
            localUniformMSDFBit,
            mSDFBit,
            roundPixelsBit
          ]
        }));
        glProgram ?? (glProgram = compileHighShaderGlProgram({
          name: "sdf-shader",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(maxTextures),
            localUniformMSDFBitGl,
            mSDFBitGl,
            roundPixelsBitGl
          ]
        }));
        super({
          glProgram,
          gpuProgram,
          resources: {
            localUniforms: uniforms,
            batchSamplers: getBatchSamplersUniformGroup(maxTextures)
          }
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs
var AbstractBitmapFont;
var init_AbstractBitmapFont = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs"() {
    init_eventemitter3();
    init_deprecation();
    AbstractBitmapFont = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.chars = /* @__PURE__ */ Object.create(null);
        this.lineHeight = 0;
        this.fontFamily = "";
        this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
        this.baseLineOffset = 0;
        this.distanceField = { type: "none", range: 0 };
        this.pages = [];
        this.applyFillAsTint = true;
        this.baseMeasurementFontSize = 100;
        this.baseRenderedFontSize = 100;
      }
      /**
       * The name of the font face.
       * @deprecated since 8.0.0 Use `fontFamily` instead.
       */
      get font() {
        deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
        return this.fontFamily;
      }
      /**
       * The map of base page textures (i.e., sheets of glyphs).
       * @deprecated since 8.0.0 Use `pages` instead.
       */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      /**
       * The size of the font face in pixels.
       * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
       */
      get size() {
        deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
        return this.fontMetrics.fontSize;
      }
      /**
       * The kind of distance field for this font or "none".
       * @deprecated since 8.0.0 Use `distanceField.type` instead.
       */
      get distanceFieldRange() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
        return this.distanceField.range;
      }
      /**
       * The range of the distance field in pixels.
       * @deprecated since 8.0.0 Use `distanceField.range` instead.
       */
      get distanceFieldType() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
        return this.distanceField.type;
      }
      destroy(destroyTextures = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        for (const i2 in this.chars) {
          this.chars[i2].texture?.destroy();
        }
        this.chars = null;
        if (destroyTextures) {
          this.pages.forEach((page) => page.texture.destroy(true));
          this.pages = null;
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs
var _DynamicBitmapFont, DynamicBitmapFont;
var init_DynamicBitmapFont = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs"() {
    init_Color();
    init_Rectangle();
    init_CanvasPool();
    init_ImageSource();
    init_Texture();
    init_TextureStyle();
    init_deprecation();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    init_TextStyle();
    init_AbstractBitmapFont();
    _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
      /**
       * @param options - The options for the dynamic bitmap font.
       */
      constructor(options) {
        super();
        this.resolution = 1;
        this.pages = [];
        this._padding = 0;
        this._measureCache = /* @__PURE__ */ Object.create(null);
        this._currentChars = [];
        this._currentX = 0;
        this._currentY = 0;
        this._currentMaxCharHeight = 0;
        this._currentPageIndex = -1;
        this._skipKerning = false;
        const dynamicOptions = { ..._DynamicBitmapFont2.defaultOptions, ...options };
        this._textureSize = dynamicOptions.textureSize;
        this._mipmap = dynamicOptions.mipmap;
        const style = dynamicOptions.style.clone();
        if (dynamicOptions.overrideFill) {
          style._fill.color = 16777215;
          style._fill.alpha = 1;
          style._fill.texture = Texture.WHITE;
          style._fill.fill = null;
        }
        this.applyFillAsTint = dynamicOptions.overrideFill;
        const requestedFontSize = style.fontSize;
        style.fontSize = this.baseMeasurementFontSize;
        const font = fontStringFromTextStyle(style);
        if (dynamicOptions.overrideSize) {
          if (style._stroke) {
            style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
          }
        } else {
          style.fontSize = this.baseRenderedFontSize = requestedFontSize;
        }
        this._style = style;
        this._skipKerning = dynamicOptions.skipKerning ?? false;
        this.resolution = dynamicOptions.resolution ?? 1;
        this._padding = dynamicOptions.padding ?? 4;
        if (dynamicOptions.textureStyle) {
          this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle ? dynamicOptions.textureStyle : new TextureStyle(dynamicOptions.textureStyle);
        }
        this.fontMetrics = CanvasTextMetrics.measureFont(font);
        this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
      }
      ensureCharacters(chars) {
        const charList = CanvasTextMetrics.graphemeSegmenter(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
        if (!charList.length)
          return;
        this._currentChars = [...this._currentChars, ...charList];
        let pageData;
        if (this._currentPageIndex === -1) {
          pageData = this._nextPage();
        } else {
          pageData = this.pages[this._currentPageIndex];
        }
        let { canvas, context: context2 } = pageData.canvasAndContext;
        let textureSource = pageData.texture.source;
        const style = this._style;
        let currentX = this._currentX;
        let currentY = this._currentY;
        let currentMaxCharHeight = this._currentMaxCharHeight;
        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
        const padding = this._padding * fontScale;
        let skipTexture = false;
        const maxTextureWidth = canvas.width / this.resolution;
        const maxTextureHeight = canvas.height / this.resolution;
        for (let i2 = 0; i2 < charList.length; i2++) {
          const char = charList[i2];
          const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
          metrics.lineHeight = metrics.height;
          const width = metrics.width * fontScale;
          const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
          const height = metrics.height * fontScale;
          const paddedWidth = textureGlyphWidth + padding * 2;
          const paddedHeight = height + padding * 2;
          skipTexture = false;
          if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
            skipTexture = true;
            currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));
          }
          if (currentX + paddedWidth > maxTextureWidth) {
            currentY += currentMaxCharHeight;
            currentMaxCharHeight = paddedHeight;
            currentX = 0;
            if (currentY + currentMaxCharHeight > maxTextureHeight) {
              textureSource.update();
              const pageData2 = this._nextPage();
              canvas = pageData2.canvasAndContext.canvas;
              context2 = pageData2.canvasAndContext.context;
              textureSource = pageData2.texture.source;
              currentX = 0;
              currentY = 0;
              currentMaxCharHeight = 0;
            }
          }
          const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
          this.chars[char] = {
            id: char.codePointAt(0),
            xOffset: -this._padding,
            yOffset: -this._padding,
            xAdvance,
            kerning: {}
          };
          if (skipTexture) {
            this._drawGlyph(
              context2,
              metrics,
              currentX + padding,
              currentY + padding,
              fontScale,
              style
            );
            const px = textureSource.width * fontScale;
            const py = textureSource.height * fontScale;
            const frame = new Rectangle(
              currentX / px * textureSource.width,
              currentY / py * textureSource.height,
              paddedWidth / px * textureSource.width,
              paddedHeight / py * textureSource.height
            );
            this.chars[char].texture = new Texture({
              source: textureSource,
              frame
            });
            currentX += Math.ceil(paddedWidth);
          }
        }
        textureSource.update();
        this._currentX = currentX;
        this._currentY = currentY;
        this._currentMaxCharHeight = currentMaxCharHeight;
        this._skipKerning && this._applyKerning(charList, context2);
      }
      /**
       * @deprecated since 8.0.0
       * The map of base page textures (i.e., sheets of glyphs).
       */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      _applyKerning(newChars, context2) {
        const measureCache = this._measureCache;
        for (let i2 = 0; i2 < newChars.length; i2++) {
          const first = newChars[i2];
          for (let j2 = 0; j2 < this._currentChars.length; j2++) {
            const second = this._currentChars[j2];
            let c1 = measureCache[first];
            if (!c1)
              c1 = measureCache[first] = context2.measureText(first).width;
            let c2 = measureCache[second];
            if (!c2)
              c2 = measureCache[second] = context2.measureText(second).width;
            let total = context2.measureText(first + second).width;
            let amount = total - (c1 + c2);
            if (amount) {
              this.chars[first].kerning[second] = amount;
            }
            total = context2.measureText(first + second).width;
            amount = total - (c1 + c2);
            if (amount) {
              this.chars[second].kerning[first] = amount;
            }
          }
        }
      }
      _nextPage() {
        this._currentPageIndex++;
        const textureResolution = this.resolution;
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
          this._textureSize,
          this._textureSize,
          textureResolution
        );
        this._setupContext(canvasAndContext.context, this._style, textureResolution);
        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
        const texture = new Texture({
          source: new ImageSource({
            resource: canvasAndContext.canvas,
            resolution,
            alphaMode: "premultiply-alpha-on-upload",
            autoGenerateMipmaps: this._mipmap
          })
        });
        if (this._textureStyle) {
          texture.source.style = this._textureStyle;
        }
        const pageData = {
          canvasAndContext,
          texture
        };
        this.pages[this._currentPageIndex] = pageData;
        return pageData;
      }
      // canvas style!
      _setupContext(context2, style, resolution) {
        style.fontSize = this.baseRenderedFontSize;
        context2.scale(resolution, resolution);
        context2.font = fontStringFromTextStyle(style);
        style.fontSize = this.baseMeasurementFontSize;
        context2.textBaseline = style.textBaseline;
        const stroke = style._stroke;
        const strokeThickness = stroke?.width ?? 0;
        if (stroke) {
          context2.lineWidth = strokeThickness;
          context2.lineJoin = stroke.join;
          context2.miterLimit = stroke.miterLimit;
          context2.strokeStyle = getCanvasFillStyle(stroke, context2);
        }
        if (style._fill) {
          context2.fillStyle = getCanvasFillStyle(style._fill, context2);
        }
        if (style.dropShadow) {
          const shadowOptions = style.dropShadow;
          const rgb = Color.shared.setValue(shadowOptions.color).toArray();
          const dropShadowBlur = shadowOptions.blur * resolution;
          const dropShadowDistance = shadowOptions.distance * resolution;
          context2.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
          context2.shadowBlur = dropShadowBlur;
          context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
          context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
        } else {
          context2.shadowColor = "black";
          context2.shadowBlur = 0;
          context2.shadowOffsetX = 0;
          context2.shadowOffsetY = 0;
        }
      }
      _drawGlyph(context2, metrics, x2, y2, fontScale, style) {
        const char = metrics.text;
        const fontProperties = metrics.fontProperties;
        const stroke = style._stroke;
        const strokeThickness = (stroke?.width ?? 0) * fontScale;
        const tx = x2 + strokeThickness / 2;
        const ty = y2 - strokeThickness / 2;
        const descent = fontProperties.descent * fontScale;
        const lineHeight = metrics.lineHeight * fontScale;
        let removeShadow = false;
        if (style.stroke && strokeThickness) {
          removeShadow = true;
          context2.strokeText(char, tx, ty + lineHeight - descent);
        }
        const { shadowBlur, shadowOffsetX, shadowOffsetY } = context2;
        if (style._fill) {
          if (removeShadow) {
            context2.shadowBlur = 0;
            context2.shadowOffsetX = 0;
            context2.shadowOffsetY = 0;
          }
          context2.fillText(char, tx, ty + lineHeight - descent);
        }
        if (removeShadow) {
          context2.shadowBlur = shadowBlur;
          context2.shadowOffsetX = shadowOffsetX;
          context2.shadowOffsetY = shadowOffsetY;
        }
      }
      destroy() {
        super.destroy();
        for (let i2 = 0; i2 < this.pages.length; i2++) {
          const { canvasAndContext, texture } = this.pages[i2];
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
    _DynamicBitmapFont.defaultOptions = {
      textureSize: 512,
      style: new TextStyle(),
      mipmap: true
    };
    DynamicBitmapFont = _DynamicBitmapFont;
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
function getBitmapTextLayout(chars, style, font, trimEnd) {
  const layoutData = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: style.fontSize / font.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  layoutData.offsetY = font.baseLineOffset;
  let currentLine = layoutData.lines[0];
  let previousChar = null;
  let firstWord = true;
  const currentWord = {
    spaceWord: false,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  };
  const scale = font.baseMeasurementFontSize / style.fontSize;
  const adjustedLetterSpacing = style.letterSpacing * scale;
  const adjustedWordWrapWidth = style.wordWrapWidth * scale;
  const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;
  const breakWords = style.wordWrap && style.breakWords;
  const nextWord = (word) => {
    const start = currentLine.width;
    for (let j2 = 0; j2 < currentWord.index; j2++) {
      const position = word.positions[j2];
      currentLine.chars.push(word.chars[j2]);
      currentLine.charPositions.push(position + start);
    }
    currentLine.width += word.width;
    firstWord = false;
    currentWord.width = 0;
    currentWord.index = 0;
    currentWord.chars.length = 0;
  };
  const nextLine = () => {
    let index = currentLine.chars.length - 1;
    if (trimEnd) {
      let lastChar = currentLine.chars[index];
      while (lastChar === " ") {
        currentLine.width -= font.chars[lastChar].xAdvance;
        lastChar = currentLine.chars[--index];
      }
    }
    layoutData.width = Math.max(layoutData.width, currentLine.width);
    currentLine = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    };
    firstWord = true;
    layoutData.lines.push(currentLine);
    layoutData.height += adjustedLineHeight;
  };
  const checkIsOverflow = (lineWidth) => lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;
  for (let i2 = 0; i2 < chars.length + 1; i2++) {
    let char;
    const isEnd = i2 === chars.length;
    if (!isEnd) {
      char = chars[i2];
    }
    const charData = font.chars[char] || font.chars[" "];
    const isSpace = /(?:\s)/.test(char);
    const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
    if (isWordBreak) {
      const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);
      if (addWordToNextLine) {
        nextLine();
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      } else {
        currentWord.start = currentLine.width;
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      }
      if (char === "\r" || char === "\n") {
        nextLine();
      } else if (!isEnd) {
        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
        currentLine.width += spaceWidth;
        currentLine.spaceWidth = spaceWidth;
        currentLine.spacesIndex.push(currentLine.charPositions.length);
        currentLine.chars.push(char);
      }
    } else {
      const kerning = charData.kerning[previousChar] || 0;
      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
      const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);
      if (addWordToNextLine) {
        nextWord(currentWord);
        nextLine();
      }
      currentWord.positions[currentWord.index++] = currentWord.width + kerning;
      currentWord.chars.push(char);
      currentWord.width += nextCharWidth;
    }
    previousChar = char;
  }
  nextLine();
  if (style.align === "center") {
    alignCenter(layoutData);
  } else if (style.align === "right") {
    alignRight(layoutData);
  } else if (style.align === "justify") {
    alignJustify(layoutData);
  }
  return layoutData;
}
function alignCenter(measurementData) {
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width / 2 - line.width / 2;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignRight(measurementData) {
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width - line.width;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignJustify(measurementData) {
  const width = measurementData.width;
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    let indy = 0;
    let spaceIndex = line.spacesIndex[indy++];
    let offset = 0;
    const totalSpaces = line.spacesIndex.length;
    const newSpaceWidth = (width - line.width) / totalSpaces;
    const spaceWidth = newSpaceWidth;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      if (j2 === spaceIndex) {
        spaceIndex = line.spacesIndex[indy++];
        offset += spaceWidth;
      }
      line.charPositions[j2] += offset;
    }
  }
}
var init_getBitmapTextLayout = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs
function resolveCharacters(chars) {
  if (chars === "") {
    return [];
  }
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
    const item = chars[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      if (item[0].length === 0 || item[1].length === 0) {
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...Array.from(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
var init_resolveCharacters = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs
var fontCount, BitmapFontManagerClass, BitmapFontManager;
var init_BitmapFontManager = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs"() {
    init_tiny_lru();
    init_Cache();
    init_deprecation();
    init_warn();
    init_CanvasTextMetrics();
    init_TextStyle();
    init_DynamicBitmapFont();
    init_getBitmapTextLayout();
    init_resolveCharacters();
    fontCount = 0;
    BitmapFontManagerClass = class {
      constructor() {
        this.ALPHA = [["a", "z"], ["A", "Z"], " "];
        this.NUMERIC = [["0", "9"]];
        this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
        this.ASCII = [[" ", "~"]];
        this.defaultOptions = {
          chars: this.ALPHANUMERIC,
          resolution: 1,
          padding: 4,
          skipKerning: false,
          textureStyle: null
        };
        this.measureCache = lru(1e3);
      }
      /**
       * Get a font for the specified text and style.
       * @param text - The text to get the font for
       * @param style - The style to use
       */
      getFont(text, style) {
        let fontFamilyKey = `${style.fontFamily}-bitmap`;
        let overrideFill = true;
        if (style._fill.fill && !style._stroke) {
          fontFamilyKey += style._fill.fill.styleKey;
          overrideFill = false;
        } else if (style._stroke || style.dropShadow) {
          fontFamilyKey = `${style.styleKey}-bitmap`;
          overrideFill = false;
        }
        if (!Cache.has(fontFamilyKey)) {
          const styleCopy = Object.create(style);
          styleCopy.lineHeight = 0;
          const fnt = new DynamicBitmapFont({
            style: styleCopy,
            overrideFill,
            overrideSize: true,
            ...this.defaultOptions
          });
          fontCount++;
          if (fontCount > 50) {
            warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
          }
          fnt.once("destroy", () => {
            fontCount--;
            Cache.remove(fontFamilyKey);
          });
          Cache.set(
            fontFamilyKey,
            fnt
          );
        }
        const dynamicFont = Cache.get(fontFamilyKey);
        dynamicFont.ensureCharacters?.(text);
        return dynamicFont;
      }
      /**
       * Get the layout of a text for the specified style.
       * @param text - The text to get the layout for
       * @param style - The style to use
       * @param trimEnd - Whether to ignore whitespaces at the end of each line
       */
      getLayout(text, style, trimEnd = true) {
        const bitmapFont = this.getFont(text, style);
        const id = `${text}-${style.styleKey}-${trimEnd}`;
        if (this.measureCache.has(id)) {
          return this.measureCache.get(id);
        }
        const segments = CanvasTextMetrics.graphemeSegmenter(text);
        const layoutData = getBitmapTextLayout(segments, style, bitmapFont, trimEnd);
        this.measureCache.set(id, layoutData);
        return layoutData;
      }
      /**
       * Measure the text using the specified style.
       * @param text - The text to measure
       * @param style - The style to use
       * @param trimEnd - Whether to ignore whitespaces at the end of each line
       */
      measureText(text, style, trimEnd = true) {
        return this.getLayout(text, style, trimEnd);
      }
      // eslint-disable-next-line max-len
      install(...args) {
        let options = args[0];
        if (typeof options === "string") {
          options = {
            name: options,
            style: args[1],
            chars: args[2]?.chars,
            resolution: args[2]?.resolution,
            padding: args[2]?.padding,
            skipKerning: args[2]?.skipKerning
          };
          deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
        }
        const name = options?.name;
        if (!name) {
          throw new Error("[BitmapFontManager] Property `name` is required.");
        }
        options = { ...this.defaultOptions, ...options };
        const textStyle = options.style;
        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
        const overrideFill = options.dynamicFill ?? this._canUseTintForStyle(style);
        const font = new DynamicBitmapFont({
          style,
          overrideFill,
          skipKerning: options.skipKerning,
          padding: options.padding,
          resolution: options.resolution,
          overrideSize: false,
          textureStyle: options.textureStyle
        });
        const flatChars = resolveCharacters(options.chars);
        font.ensureCharacters(flatChars.join(""));
        Cache.set(`${name}-bitmap`, font);
        font.once("destroy", () => Cache.remove(`${name}-bitmap`));
        return font;
      }
      /**
       * Uninstalls a bitmap font from the cache.
       * @param {string} name - The name of the bitmap font to uninstall.
       */
      uninstall(name) {
        const cacheKey = `${name}-bitmap`;
        const font = Cache.get(cacheKey);
        if (font) {
          font.destroy();
        }
      }
      /**
       * Determines if a style can use tinting instead of baking colors into the bitmap.
       * Tinting is more efficient as it allows reusing the same bitmap with different colors.
       * @param style - The text style to evaluate
       * @returns true if the style can use tinting, false if colors must be baked in
       * @private
       */
      _canUseTintForStyle(style) {
        return !style._stroke && (!style.dropShadow || style.dropShadow.color === 0) && !style._fill.fill && style._fill.color === 16777215;
      }
    };
    BitmapFontManager = new BitmapFontManagerClass();
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs
function syncWithProxy(container, proxy) {
  proxy.groupTransform = container.groupTransform;
  proxy.groupColorAlpha = container.groupColorAlpha;
  proxy.groupColor = container.groupColor;
  proxy.groupBlendMode = container.groupBlendMode;
  proxy.globalDisplayStatus = container.globalDisplayStatus;
  proxy.groupTransform = container.groupTransform;
  proxy.localDisplayStatus = container.localDisplayStatus;
  proxy.groupAlpha = container.groupAlpha;
  proxy._roundPixels = container._roundPixels;
}
var BitmapTextGraphics, BitmapTextPipe;
var init_BitmapTextPipe = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs"() {
    init_Cache();
    init_Extensions();
    init_Graphics();
    init_CanvasTextMetrics();
    init_SdfShader();
    init_BitmapFontManager();
    init_getBitmapTextLayout();
    BitmapTextGraphics = class extends Graphics {
      destroy() {
        if (this.context.customShader) {
          this.context.customShader.destroy();
        }
        super.destroy();
      }
    };
    BitmapTextPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      validateRenderable(bitmapText) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
      }
      addRenderable(bitmapText, instructionSet) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        syncWithProxy(bitmapText, graphicsRenderable);
        if (bitmapText._didTextUpdate) {
          bitmapText._didTextUpdate = false;
          this._updateContext(bitmapText, graphicsRenderable);
        }
        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
        if (graphicsRenderable.context.customShader) {
          this._updateDistanceField(bitmapText);
        }
      }
      updateRenderable(bitmapText) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        syncWithProxy(bitmapText, graphicsRenderable);
        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
        if (graphicsRenderable.context.customShader) {
          this._updateDistanceField(bitmapText);
        }
      }
      _updateContext(bitmapText, proxyGraphics) {
        const { context: context2 } = proxyGraphics;
        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
        context2.clear();
        if (bitmapFont.distanceField.type !== "none") {
          if (!context2.customShader) {
            context2.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);
          }
        }
        const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);
        const style = bitmapText._style;
        let currentY = bitmapFont.baseLineOffset;
        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);
        const padding = style.padding;
        const scale = bitmapTextLayout.scale;
        let tx = bitmapTextLayout.width;
        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
        if (style._stroke) {
          tx += style._stroke.width / scale;
          ty += style._stroke.width / scale;
        }
        context2.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
        let fontSize = bitmapFont.fontMetrics.fontSize;
        let lineHeight = bitmapFont.lineHeight;
        if (style.lineHeight) {
          fontSize = style.fontSize / scale;
          lineHeight = style.lineHeight / scale;
        }
        let linePositionYShift = (lineHeight - fontSize) / 2;
        if (linePositionYShift - bitmapFont.baseLineOffset < 0) {
          linePositionYShift = 0;
        }
        for (let i2 = 0; i2 < bitmapTextLayout.lines.length; i2++) {
          const line = bitmapTextLayout.lines[i2];
          for (let j2 = 0; j2 < line.charPositions.length; j2++) {
            const char = line.chars[j2];
            const charData = bitmapFont.chars[char];
            if (charData?.texture) {
              const texture = charData.texture;
              context2.texture(
                texture,
                tint ? tint : "black",
                Math.round(line.charPositions[j2] + charData.xOffset),
                Math.round(currentY + charData.yOffset + linePositionYShift),
                texture.orig.width,
                texture.orig.height
              );
            }
          }
          currentY += lineHeight;
        }
      }
      _getGpuBitmapText(bitmapText) {
        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);
      }
      initGpuText(bitmapText) {
        const proxyRenderable = new BitmapTextGraphics();
        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;
        this._updateContext(bitmapText, proxyRenderable);
        return proxyRenderable;
      }
      _updateDistanceField(bitmapText) {
        const context2 = this._getGpuBitmapText(bitmapText).context;
        const fontFamily = bitmapText._style.fontFamily;
        const dynamicFont = Cache.get(`${fontFamily}-bitmap`);
        const { a: a2, b: b2, c: c2, d: d2 } = bitmapText.groupTransform;
        const dx = Math.sqrt(a2 * a2 + b2 * b2);
        const dy = Math.sqrt(c2 * c2 + d2 * d2);
        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
        context2.customShader.resources.localUniforms.uniforms.uDistance = distance;
      }
      destroy() {
        this._renderer = null;
      }
    };
    BitmapTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "bitmapText"
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/init.mjs
var init_init11 = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/init.mjs"() {
    init_Extensions();
    init_BitmapTextPipe();
    extensions.add(BitmapTextPipe);
  }
});

// node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs
var BatchableHTMLText;
var init_BatchableHTMLText = __esm({
  "node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs"() {
    init_BatchableSprite();
    BatchableHTMLText = class extends BatchableSprite {
      /**
       * Creates an instance of BatchableHTMLText.
       * @param renderer - The renderer instance to be used.
       */
      constructor(renderer) {
        super();
        this.generatingTexture = false;
        this.currentKey = "--";
        this._renderer = renderer;
        renderer.runners.resolutionChange.add(this);
      }
      /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */
      resolutionChange() {
        const text = this.renderable;
        if (text._autoResolution) {
          text.onViewUpdate();
        }
      }
      /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */
      destroy() {
        const { htmlText } = this._renderer;
        htmlText.getReferenceCount(this.currentKey) === null ? htmlText.returnTexturePromise(this.texturePromise) : htmlText.decreaseReferenceCount(this.currentKey);
        this._renderer.runners.resolutionChange.remove(this);
        this.texturePromise = null;
        this._renderer = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs
var HTMLTextPipe;
var init_HTMLTextPipe = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs"() {
    init_Extensions();
    init_Texture();
    init_updateTextBounds();
    init_BatchableHTMLText();
    HTMLTextPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      validateRenderable(htmlText) {
        const gpuText = this._getGpuText(htmlText);
        const newKey = htmlText.styleKey;
        if (gpuText.currentKey !== newKey) {
          return true;
        }
        return false;
      }
      addRenderable(htmlText, instructionSet) {
        const batchableHTMLText = this._getGpuText(htmlText);
        if (htmlText._didTextUpdate) {
          const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
          if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution) {
            this._updateGpuText(htmlText).catch((e2) => {
              console.error(e2);
            });
          }
          htmlText._didTextUpdate = false;
          updateTextBounds(batchableHTMLText, htmlText);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);
      }
      updateRenderable(htmlText) {
        const batchableHTMLText = this._getGpuText(htmlText);
        batchableHTMLText._batcher.updateElement(batchableHTMLText);
      }
      async _updateGpuText(htmlText) {
        htmlText._didTextUpdate = false;
        const batchableHTMLText = this._getGpuText(htmlText);
        if (batchableHTMLText.generatingTexture)
          return;
        const oldTexturePromise = batchableHTMLText.texturePromise;
        batchableHTMLText.texturePromise = null;
        batchableHTMLText.generatingTexture = true;
        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
        let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);
        if (oldTexturePromise) {
          texturePromise = texturePromise.finally(() => {
            this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);
            this._renderer.htmlText.returnTexturePromise(oldTexturePromise);
          });
        }
        batchableHTMLText.texturePromise = texturePromise;
        batchableHTMLText.currentKey = htmlText.styleKey;
        batchableHTMLText.texture = await texturePromise;
        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
        batchableHTMLText.generatingTexture = false;
        updateTextBounds(batchableHTMLText, htmlText);
      }
      _getGpuText(htmlText) {
        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);
      }
      initGpuText(htmlText) {
        const batchableHTMLText = new BatchableHTMLText(this._renderer);
        batchableHTMLText.renderable = htmlText;
        batchableHTMLText.transform = htmlText.groupTransform;
        batchableHTMLText.texture = Texture.EMPTY;
        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
        batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;
        return batchableHTMLText;
      }
      destroy() {
        this._renderer = null;
      }
    };
    HTMLTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "htmlText"
    };
  }
});

// node_modules/pixi.js/lib/utils/browser/isSafari.mjs
function isSafari() {
  const { userAgent } = DOMAdapter.get().getNavigator();
  return /^((?!chrome|android).)*safari/i.test(userAgent);
}
var init_isSafari = __esm({
  "node_modules/pixi.js/lib/utils/browser/isSafari.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs
var nssvg, nsxhtml, HTMLTextRenderData;
var init_HTMLTextRenderData = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs"() {
    init_adapter();
    nssvg = "http://www.w3.org/2000/svg";
    nsxhtml = "http://www.w3.org/1999/xhtml";
    HTMLTextRenderData = class {
      constructor() {
        this.svgRoot = document.createElementNS(nssvg, "svg");
        this.foreignObject = document.createElementNS(nssvg, "foreignObject");
        this.domElement = document.createElementNS(nsxhtml, "div");
        this.styleElement = document.createElementNS(nsxhtml, "style");
        const { foreignObject, svgRoot, styleElement, domElement } = this;
        foreignObject.setAttribute("width", "10000");
        foreignObject.setAttribute("height", "10000");
        foreignObject.style.overflow = "hidden";
        svgRoot.appendChild(foreignObject);
        foreignObject.appendChild(styleElement);
        foreignObject.appendChild(domElement);
        this.image = DOMAdapter.get().createImage();
      }
      destroy() {
        this.svgRoot.remove();
        this.foreignObject.remove();
        this.styleElement.remove();
        this.domElement.remove();
        this.image.src = "";
        this.image.remove();
        this.svgRoot = null;
        this.foreignObject = null;
        this.styleElement = null;
        this.domElement = null;
        this.image = null;
        this.canvasAndContext = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs
function extractFontFamilies(text, style) {
  const fontFamily = style.fontFamily;
  const fontFamilies = [];
  const dedupe = {};
  const regex = /font-family:([^;"\s]+)/g;
  const matches = text.match(regex);
  function addFontFamily(fontFamily2) {
    if (!dedupe[fontFamily2]) {
      fontFamilies.push(fontFamily2);
      dedupe[fontFamily2] = true;
    }
  }
  if (Array.isArray(fontFamily)) {
    for (let i2 = 0; i2 < fontFamily.length; i2++) {
      addFontFamily(fontFamily[i2]);
    }
  } else {
    addFontFamily(fontFamily);
  }
  if (matches) {
    matches.forEach((match) => {
      const fontFamily2 = match.split(":")[1].trim();
      addFontFamily(fontFamily2);
    });
  }
  for (const i2 in style.tagStyles) {
    const fontFamily2 = style.tagStyles[i2].fontFamily;
    addFontFamily(fontFamily2);
  }
  return fontFamilies;
}
var init_extractFontFamilies = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs
async function loadFontAsBase64(url) {
  const response = await DOMAdapter.get().fetch(url);
  const blob = await response.blob();
  const reader = new FileReader();
  const dataSrc = await new Promise((resolve, reject) => {
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
  return dataSrc;
}
var init_loadFontAsBase64 = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs
async function loadFontCSS(style, url) {
  const dataSrc = await loadFontAsBase64(url);
  return `@font-face {
        font-family: "${style.fontFamily}";
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
        src: url('${dataSrc}');
    }`;
}
var init_loadFontCSS = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs"() {
    init_loadFontAsBase64();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs
async function getFontCss(fontFamilies) {
  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily) => {
    if (!FontStylePromiseCache.has(fontFamily)) {
      const { entries } = Cache.get(`${fontFamily}-and-url`);
      const promises = [];
      entries.forEach((entry) => {
        const url = entry.url;
        const faces = entry.faces;
        const out2 = faces.map((face) => ({ weight: face.weight, style: face.style }));
        promises.push(
          ...out2.map(
            (style) => loadFontCSS(
              {
                fontWeight: style.weight,
                fontStyle: style.style,
                fontFamily
              },
              url
            )
          )
        );
      });
      FontStylePromiseCache.set(
        fontFamily,
        Promise.all(promises).then((css) => css.join("\n"))
      );
    }
    return FontStylePromiseCache.get(fontFamily);
  });
  return (await Promise.all(fontPromises)).join("\n");
}
var FontStylePromiseCache;
var init_getFontCss = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs"() {
    init_Cache();
    init_loadFontCSS();
    FontStylePromiseCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs
function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
  const { domElement, styleElement, svgRoot } = htmlTextData;
  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
  styleElement.textContent = fontCSS;
  const { width, height } = htmlTextData.image;
  svgRoot.setAttribute("width", width.toString());
  svgRoot.setAttribute("height", height.toString());
  return new XMLSerializer().serializeToString(svgRoot);
}
var init_getSVGUrl = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
function getTemporaryCanvasFromImage(image, resolution) {
  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
    image.width,
    image.height,
    resolution
  );
  const { context: context2 } = canvasAndContext;
  context2.clearRect(0, 0, image.width, image.height);
  context2.drawImage(image, 0, 0);
  return canvasAndContext;
}
var init_getTemporaryCanvasFromImage = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs"() {
    init_CanvasPool();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs
function loadSVGImage(image, url, delay) {
  return new Promise(async (resolve) => {
    if (delay) {
      await new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    image.onload = () => {
      resolve();
    };
    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
    image.crossOrigin = "anonymous";
  });
}
var init_loadSVGImage = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs
function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData()));
  const { domElement, styleElement, svgRoot } = htmlTextRenderData;
  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
  if (fontStyleCSS) {
    styleElement.textContent = fontStyleCSS;
  }
  document.body.appendChild(svgRoot);
  const contentBounds = domElement.getBoundingClientRect();
  svgRoot.remove();
  const doublePadding = style.padding * 2;
  return {
    width: contentBounds.width - doublePadding,
    height: contentBounds.height - doublePadding
  };
}
var tempHTMLTextRenderData;
var init_measureHtmlText = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs"() {
    init_HTMLTextRenderData();
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs
var HTMLTextSystem;
var init_HTMLTextSystem = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs"() {
    init_Extensions();
    init_CanvasPool();
    init_TexturePool();
    init_types2();
    init_isSafari();
    init_warn();
    init_PoolGroup();
    init_getPo2TextureFromSource();
    init_HTMLTextRenderData();
    init_extractFontFamilies();
    init_getFontCss();
    init_getSVGUrl();
    init_getTemporaryCanvasFromImage();
    init_loadSVGImage();
    init_measureHtmlText();
    HTMLTextSystem = class {
      constructor(renderer) {
        this._activeTextures = {};
        this._renderer = renderer;
        this._createCanvas = renderer.type === RendererType.WEBGPU;
      }
      /**
       * @param options
       * @deprecated Use getTexturePromise instead
       */
      getTexture(options) {
        return this.getTexturePromise(options);
      }
      /**
       * Increases the reference count for a texture.
       * @param text - The HTMLText instance associated with the texture.
       */
      getManagedTexture(text) {
        const textKey = text.styleKey;
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].promise;
        }
        const promise2 = this._buildTexturePromise(text).then((texture) => {
          this._activeTextures[textKey].texture = texture;
          return texture;
        });
        this._activeTextures[textKey] = {
          texture: null,
          promise: promise2,
          usageCount: 1
        };
        return promise2;
      }
      /**
       * Gets the current reference count for a texture associated with a text key.
       * @param textKey - The unique key identifying the text style configuration
       * @returns The number of Text instances currently using this texture
       */
      getReferenceCount(textKey) {
        return this._activeTextures[textKey]?.usageCount ?? null;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      /**
       * Decreases the reference count for a texture.
       * If the count reaches zero, the texture is cleaned up.
       * @param textKey - The key associated with the HTMLText instance.
       */
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        if (!activeTexture)
          return;
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          if (activeTexture.texture) {
            this._cleanUp(activeTexture.texture);
          } else {
            activeTexture.promise.then((texture) => {
              activeTexture.texture = texture;
              this._cleanUp(activeTexture.texture);
            }).catch(() => {
              warn("HTMLTextSystem: Failed to clean texture");
            });
          }
          this._activeTextures[textKey] = null;
        }
      }
      /**
       * Returns a promise that resolves to a texture for the given HTMLText options.
       * @param options - The options for the HTMLText.
       * @returns A promise that resolves to a Texture.
       */
      getTexturePromise(options) {
        return this._buildTexturePromise(options);
      }
      async _buildTexturePromise(options) {
        const { text, style, resolution, textureStyle } = options;
        const htmlTextData = BigPool.get(HTMLTextRenderData);
        const fontFamilies = extractFontFamilies(text, style);
        const fontCSS = await getFontCss(fontFamilies);
        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const image = htmlTextData.image;
        const uvSafeOffset = 2;
        image.width = (width | 0) + uvSafeOffset;
        image.height = (height | 0) + uvSafeOffset;
        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
        const resource = image;
        let canvasAndContext;
        if (this._createCanvas) {
          canvasAndContext = getTemporaryCanvasFromImage(image, resolution);
        }
        const texture = getPo2TextureFromSource(
          canvasAndContext ? canvasAndContext.canvas : resource,
          image.width - uvSafeOffset,
          image.height - uvSafeOffset,
          resolution
        );
        if (textureStyle)
          texture.source.style = textureStyle;
        if (this._createCanvas) {
          this._renderer.texture.initSource(texture.source);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
        }
        BigPool.return(htmlTextData);
        return texture;
      }
      returnTexturePromise(texturePromise) {
        texturePromise.then((texture) => {
          this._cleanUp(texture);
        }).catch(() => {
          warn("HTMLTextSystem: Failed to clean texture");
        });
      }
      _cleanUp(texture) {
        TexturePool.returnTexture(texture, true);
        texture.source.resource = null;
        texture.source.uploadMethodId = "unknown";
      }
      destroy() {
        this._renderer = null;
        for (const key in this._activeTextures) {
          if (this._activeTextures[key])
            this.returnTexturePromise(this._activeTextures[key].promise);
        }
        this._activeTextures = null;
      }
    };
    HTMLTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "htmlText"
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/init.mjs
var init_init12 = __esm({
  "node_modules/pixi.js/lib/scene/text-html/init.mjs"() {
    init_Extensions();
    init_HTMLTextPipe();
    init_HTMLTextSystem();
    extensions.add(HTMLTextSystem);
    extensions.add(HTMLTextPipe);
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
var _MeshGeometry, MeshGeometry;
var init_MeshGeometry = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"() {
    init_Buffer();
    init_const4();
    init_Geometry();
    init_deprecation();
    _MeshGeometry = class _MeshGeometry2 extends Geometry {
      constructor(...args) {
        let options = args[0] ?? {};
        if (options instanceof Float32Array) {
          deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
          options = {
            positions: options,
            uvs: args[1],
            indices: args[2]
          };
        }
        options = { ..._MeshGeometry2.defaultOptions, ...options };
        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        let uvs = options.uvs;
        if (!uvs) {
          if (options.positions) {
            uvs = new Float32Array(positions.length);
          } else {
            uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          }
        }
        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
        const shrinkToFit = options.shrinkBuffersToFit;
        const positionBuffer = new Buffer2({
          data: positions,
          label: "attribute-mesh-positions",
          shrinkToFit,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const uvBuffer = new Buffer2({
          data: uvs,
          label: "attribute-mesh-uvs",
          shrinkToFit,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const indexBuffer = new Buffer2({
          data: indices,
          label: "index-mesh-buffer",
          shrinkToFit,
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST
        });
        super({
          attributes: {
            aPosition: {
              buffer: positionBuffer,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            },
            aUV: {
              buffer: uvBuffer,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            }
          },
          indexBuffer,
          topology: options.topology
        });
        this.batchMode = "auto";
      }
      /** The positions of the mesh. */
      get positions() {
        return this.attributes.aPosition.buffer.data;
      }
      /**
       * Set the positions of the mesh.
       * When setting the positions, its important that the uvs array is at least as long as the positions array.
       * otherwise the geometry will not be valid.
       * @param {Float32Array} value - The positions of the mesh.
       */
      set positions(value) {
        this.attributes.aPosition.buffer.data = value;
      }
      /** The UVs of the mesh. */
      get uvs() {
        return this.attributes.aUV.buffer.data;
      }
      /**
       * Set the UVs of the mesh.
       * Its important that the uvs array you set is at least as long as the positions array.
       * otherwise the geometry will not be valid.
       * @param {Float32Array} value - The UVs of the mesh.
       */
      set uvs(value) {
        this.attributes.aUV.buffer.data = value;
      }
      /** The indices of the mesh. */
      get indices() {
        return this.indexBuffer.data;
      }
      set indices(value) {
        this.indexBuffer.data = value;
      }
    };
    _MeshGeometry.defaultOptions = {
      topology: "triangle-list",
      shrinkBuffersToFit: false
    };
    MeshGeometry = _MeshGeometry;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
var localUniformBit, localUniformBitGroup2, localUniformBitGl;
var init_localUniformBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
    "use strict";
    localUniformBit = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* wgsl */
          `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      }
    };
    localUniformBitGroup2 = {
      ...localUniformBit,
      vertex: {
        ...localUniformBit.vertex,
        // replace the group!
        header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
      }
    };
    localUniformBitGl = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* glsl */
          `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
        ),
        end: (
          /* glsl */
          `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
var tilingBit, tilingBitGl;
var init_tilingBit = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
    "use strict";
    tilingBit = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        )
      }
    };
    tilingBitGl = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `
        ),
        main: (
          /* glsl */
          `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
        ),
        main: (
          /* glsl */
          `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
var gpuProgram2, glProgram2, TilingSpriteShader;
var init_TilingSpriteShader = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    init_Texture();
    init_tilingBit();
    TilingSpriteShader = class extends Shader {
      constructor() {
        gpuProgram2 ?? (gpuProgram2 = compileHighShaderGpuProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBit,
            tilingBit,
            roundPixelsBit
          ]
        }));
        glProgram2 ?? (glProgram2 = compileHighShaderGlProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBitGl,
            tilingBitGl,
            roundPixelsBitGl
          ]
        }));
        const tilingUniforms = new UniformGroup({
          uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
          uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
          uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
          uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
          uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
        });
        super({
          glProgram: glProgram2,
          gpuProgram: gpuProgram2,
          resources: {
            localUniforms: new UniformGroup({
              uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
              uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
              uRound: { value: 0, type: "f32" }
            }),
            tilingUniforms,
            uTexture: Texture.EMPTY.source,
            uSampler: Texture.EMPTY.source.style
          }
        });
      }
      updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
        const tilingUniforms = this.resources.tilingUniforms;
        const textureWidth = texture.width;
        const textureHeight = texture.height;
        const textureMatrix = texture.textureMatrix;
        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
        uTextureTransform.set(
          matrix.a * textureWidth / width,
          matrix.b * textureWidth / height,
          matrix.c * textureHeight / width,
          matrix.d * textureHeight / height,
          matrix.tx / width,
          matrix.ty / height
        );
        uTextureTransform.invert();
        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
        tilingUniforms.uniforms.uSizeAnchor[0] = width;
        tilingUniforms.uniforms.uSizeAnchor[1] = height;
        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
        if (texture) {
          this.resources.uTexture = texture.source;
          this.resources.uSampler = texture.source.style;
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
var QuadGeometry;
var init_QuadGeometry = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs"() {
    init_MeshGeometry();
    QuadGeometry = class extends MeshGeometry {
      constructor() {
        super({
          positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          indices: new Uint32Array([0, 1, 2, 0, 2, 3])
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs
function setPositions(tilingSprite, positions) {
  const anchorX = tilingSprite.anchor.x;
  const anchorY = tilingSprite.anchor.y;
  positions[0] = -anchorX * tilingSprite.width;
  positions[1] = -anchorY * tilingSprite.height;
  positions[2] = (1 - anchorX) * tilingSprite.width;
  positions[3] = -anchorY * tilingSprite.height;
  positions[4] = (1 - anchorX) * tilingSprite.width;
  positions[5] = (1 - anchorY) * tilingSprite.height;
  positions[6] = -anchorX * tilingSprite.width;
  positions[7] = (1 - anchorY) * tilingSprite.height;
}
var init_setPositions = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs
function applyMatrix(array, stride, offset, matrix) {
  let index = 0;
  const size = array.length / (stride || 2);
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  offset *= stride;
  while (index < size) {
    const x2 = array[offset];
    const y2 = array[offset + 1];
    array[offset] = a2 * x2 + c2 * y2 + tx;
    array[offset + 1] = b2 * x2 + d2 * y2 + ty;
    offset += stride;
    index++;
  }
}
var init_applyMatrix = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs
function setUvs(tilingSprite, uvs) {
  const texture = tilingSprite.texture;
  const width = texture.frame.width;
  const height = texture.frame.height;
  let anchorX = 0;
  let anchorY = 0;
  if (tilingSprite.applyAnchorToTexture) {
    anchorX = tilingSprite.anchor.x;
    anchorY = tilingSprite.anchor.y;
  }
  uvs[0] = uvs[6] = -anchorX;
  uvs[2] = uvs[4] = 1 - anchorX;
  uvs[1] = uvs[3] = -anchorY;
  uvs[5] = uvs[7] = 1 - anchorY;
  const textureMatrix = Matrix.shared;
  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
  textureMatrix.tx /= tilingSprite.width;
  textureMatrix.ty /= tilingSprite.height;
  textureMatrix.invert();
  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
  applyMatrix(uvs, 2, 0, textureMatrix);
}
var init_setUvs = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs"() {
    init_Matrix();
    init_applyMatrix();
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
var sharedQuad, TilingSpriteGpuData, TilingSpritePipe;
var init_TilingSpritePipe = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
    init_Extensions();
    init_getAdjustedBlendModeBlend();
    init_State();
    init_types2();
    init_colorToUniform();
    init_BatchableMesh();
    init_MeshGeometry();
    init_TilingSpriteShader();
    init_QuadGeometry();
    init_setPositions();
    init_setUvs();
    sharedQuad = new QuadGeometry();
    TilingSpriteGpuData = class {
      constructor() {
        this.canBatch = true;
        this.geometry = new MeshGeometry({
          indices: sharedQuad.indices.slice(),
          positions: sharedQuad.positions.slice(),
          uvs: sharedQuad.uvs.slice()
        });
      }
      destroy() {
        this.geometry.destroy();
        this.shader?.destroy();
      }
    };
    TilingSpritePipe = class {
      constructor(renderer) {
        this._state = State.default2d;
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const tilingSpriteData = this._getTilingSpriteData(renderable);
        const couldBatch = tilingSpriteData.canBatch;
        this._updateCanBatch(renderable);
        const canBatch = tilingSpriteData.canBatch;
        if (canBatch && canBatch === couldBatch) {
          const { batchableMesh } = tilingSpriteData;
          return !batchableMesh._batcher.checkAndUpdateTexture(
            batchableMesh,
            renderable.texture
          );
        }
        return couldBatch !== canBatch;
      }
      addRenderable(tilingSprite, instructionSet) {
        const batcher = this._renderer.renderPipes.batch;
        this._updateCanBatch(tilingSprite);
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        const { geometry, canBatch } = tilingSpriteData;
        if (canBatch) {
          tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
          const batchableMesh = tilingSpriteData.batchableMesh;
          if (tilingSprite.didViewUpdate) {
            this._updateBatchableMesh(tilingSprite);
            batchableMesh.geometry = geometry;
            batchableMesh.renderable = tilingSprite;
            batchableMesh.transform = tilingSprite.groupTransform;
            batchableMesh.setTexture(tilingSprite._texture);
          }
          batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
          batcher.addToBatch(batchableMesh, instructionSet);
        } else {
          batcher.break(instructionSet);
          tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
          this.updateRenderable(tilingSprite);
          instructionSet.add(tilingSprite);
        }
      }
      execute(tilingSprite) {
        const { shader } = this._getTilingSpriteData(tilingSprite);
        shader.groups[0] = this._renderer.globalUniforms.bindGroup;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = tilingSprite.groupTransform;
        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
        color32BitToUniform(
          tilingSprite.groupColorAlpha,
          localUniforms.uColor,
          0
        );
        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
        this._renderer.encoder.draw({
          geometry: sharedQuad,
          shader,
          state: this._state
        });
      }
      updateRenderable(tilingSprite) {
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        const { canBatch } = tilingSpriteData;
        if (canBatch) {
          const { batchableMesh } = tilingSpriteData;
          if (tilingSprite.didViewUpdate)
            this._updateBatchableMesh(tilingSprite);
          batchableMesh._batcher.updateElement(batchableMesh);
        } else if (tilingSprite.didViewUpdate) {
          const { shader } = tilingSpriteData;
          shader.updateUniforms(
            tilingSprite.width,
            tilingSprite.height,
            tilingSprite._tileTransform.matrix,
            tilingSprite.anchor.x,
            tilingSprite.anchor.y,
            tilingSprite.texture
          );
        }
      }
      _getTilingSpriteData(renderable) {
        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);
      }
      _initTilingSpriteData(tilingSprite) {
        const gpuData = new TilingSpriteGpuData();
        gpuData.renderable = tilingSprite;
        tilingSprite._gpuData[this._renderer.uid] = gpuData;
        return gpuData;
      }
      _updateBatchableMesh(tilingSprite) {
        const renderableData = this._getTilingSpriteData(tilingSprite);
        const { geometry } = renderableData;
        const style = tilingSprite.texture.source.style;
        if (style.addressMode !== "repeat") {
          style.addressMode = "repeat";
          style.update();
        }
        setUvs(tilingSprite, geometry.uvs);
        setPositions(tilingSprite, geometry.positions);
      }
      destroy() {
        this._renderer = null;
      }
      _updateCanBatch(tilingSprite) {
        const renderableData = this._getTilingSpriteData(tilingSprite);
        const texture = tilingSprite.texture;
        let _nonPowOf2wrapping = true;
        if (this._renderer.type === RendererType.WEBGL) {
          _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
        }
        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
        return renderableData.canBatch;
      }
    };
    TilingSpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "tilingSprite"
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs
var init_init13 = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs"() {
    init_Extensions();
    init_TilingSpritePipe();
    extensions.add(TilingSpritePipe);
  }
});

// node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs
var _PlaneGeometry, PlaneGeometry;
var init_PlaneGeometry = __esm({
  "node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs"() {
    init_deprecation();
    init_MeshGeometry();
    _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry {
      constructor(...args) {
        super({});
        let options = args[0] ?? {};
        if (typeof options === "number") {
          deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
          options = {
            width: options,
            height: args[1],
            verticesX: args[2],
            verticesY: args[3]
          };
        }
        this.build(options);
      }
      /**
       * Refreshes plane coordinates
       * @param options - Options to be applied to plane geometry
       */
      build(options) {
        options = { ..._PlaneGeometry2.defaultOptions, ...options };
        this.verticesX = this.verticesX ?? options.verticesX;
        this.verticesY = this.verticesY ?? options.verticesY;
        this.width = this.width ?? options.width;
        this.height = this.height ?? options.height;
        const total = this.verticesX * this.verticesY;
        const verts = [];
        const uvs = [];
        const indices = [];
        const verticesX = this.verticesX - 1;
        const verticesY = this.verticesY - 1;
        const sizeX = this.width / verticesX;
        const sizeY = this.height / verticesY;
        for (let i2 = 0; i2 < total; i2++) {
          const x2 = i2 % this.verticesX;
          const y2 = i2 / this.verticesX | 0;
          verts.push(x2 * sizeX, y2 * sizeY);
          uvs.push(x2 / verticesX, y2 / verticesY);
        }
        const totalSub = verticesX * verticesY;
        for (let i2 = 0; i2 < totalSub; i2++) {
          const xpos = i2 % verticesX;
          const ypos = i2 / verticesX | 0;
          const value = ypos * this.verticesX + xpos;
          const value2 = ypos * this.verticesX + xpos + 1;
          const value3 = (ypos + 1) * this.verticesX + xpos;
          const value4 = (ypos + 1) * this.verticesX + xpos + 1;
          indices.push(
            value,
            value2,
            value3,
            value2,
            value4,
            value3
          );
        }
        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint32Array(indices);
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
      }
    };
    _PlaneGeometry.defaultOptions = {
      width: 100,
      height: 100,
      verticesX: 10,
      verticesY: 10
    };
    PlaneGeometry = _PlaneGeometry;
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
var _NineSliceGeometry, NineSliceGeometry;
var init_NineSliceGeometry = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs"() {
    init_PlaneGeometry();
    _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry {
      constructor(options = {}) {
        options = { ..._NineSliceGeometry2.defaultOptions, ...options };
        super({
          width: options.width,
          height: options.height,
          verticesX: 4,
          verticesY: 4
        });
        this.update(options);
      }
      /**
       * Updates the NineSliceGeometry with the options.
       * @param options - The options of the NineSliceGeometry.
       */
      update(options) {
        this.width = options.width ?? this.width;
        this.height = options.height ?? this.height;
        this._originalWidth = options.originalWidth ?? this._originalWidth;
        this._originalHeight = options.originalHeight ?? this._originalHeight;
        this._leftWidth = options.leftWidth ?? this._leftWidth;
        this._rightWidth = options.rightWidth ?? this._rightWidth;
        this._topHeight = options.topHeight ?? this._topHeight;
        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
        this._anchorX = options.anchor?.x;
        this._anchorY = options.anchor?.y;
        this.updateUvs();
        this.updatePositions();
      }
      /** Updates the positions of the vertices. */
      updatePositions() {
        const p2 = this.positions;
        const {
          width,
          height,
          _leftWidth,
          _rightWidth,
          _topHeight,
          _bottomHeight,
          _anchorX,
          _anchorY
        } = this;
        const w2 = _leftWidth + _rightWidth;
        const scaleW = width > w2 ? 1 : width / w2;
        const h2 = _topHeight + _bottomHeight;
        const scaleH = height > h2 ? 1 : height / h2;
        const scale = Math.min(scaleW, scaleH);
        const anchorOffsetX = _anchorX * width;
        const anchorOffsetY = _anchorY * height;
        p2[0] = p2[8] = p2[16] = p2[24] = -anchorOffsetX;
        p2[2] = p2[10] = p2[18] = p2[26] = _leftWidth * scale - anchorOffsetX;
        p2[4] = p2[12] = p2[20] = p2[28] = width - _rightWidth * scale - anchorOffsetX;
        p2[6] = p2[14] = p2[22] = p2[30] = width - anchorOffsetX;
        p2[1] = p2[3] = p2[5] = p2[7] = -anchorOffsetY;
        p2[9] = p2[11] = p2[13] = p2[15] = _topHeight * scale - anchorOffsetY;
        p2[17] = p2[19] = p2[21] = p2[23] = height - _bottomHeight * scale - anchorOffsetY;
        p2[25] = p2[27] = p2[29] = p2[31] = height - anchorOffsetY;
        this.getBuffer("aPosition").update();
      }
      /** Updates the UVs of the vertices. */
      updateUvs() {
        const uvs = this.uvs;
        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
        const _uvw = 1 / this._originalWidth;
        const _uvh = 1 / this._originalHeight;
        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
        this.getBuffer("aUV").update();
      }
    };
    _NineSliceGeometry.defaultOptions = {
      /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
      width: 100,
      /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
      height: 100,
      /** The width of the left column. */
      leftWidth: 10,
      /** The height of the top row. */
      topHeight: 10,
      /** The width of the right column. */
      rightWidth: 10,
      /** The height of the bottom row. */
      bottomHeight: 10,
      /** The original width of the texture */
      originalWidth: 100,
      /** The original height of the texture */
      originalHeight: 100
    };
    NineSliceGeometry = _NineSliceGeometry;
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
var NineSliceSpriteGpuData, NineSliceSpritePipe;
var init_NineSliceSpritePipe = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs"() {
    init_Extensions();
    init_BatchableMesh();
    init_NineSliceGeometry();
    NineSliceSpriteGpuData = class extends BatchableMesh {
      constructor() {
        super();
        this.geometry = new NineSliceGeometry();
      }
      destroy() {
        this.geometry.destroy();
      }
    };
    NineSliceSpritePipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      addRenderable(sprite, instructionSet) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
      }
      updateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        gpuSprite._batcher.updateElement(gpuSprite);
      }
      validateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        return !gpuSprite._batcher.checkAndUpdateTexture(
          gpuSprite,
          sprite._texture
        );
      }
      _updateBatchableSprite(sprite, batchableSprite) {
        batchableSprite.geometry.update(sprite);
        batchableSprite.setTexture(sprite._texture);
      }
      _getGpuSprite(sprite) {
        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
      }
      _initGPUSprite(sprite) {
        const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();
        const batchableMesh = gpuData;
        batchableMesh.renderable = sprite;
        batchableMesh.transform = sprite.groupTransform;
        batchableMesh.texture = sprite._texture;
        batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
        if (!sprite.didViewUpdate) {
          this._updateBatchableSprite(sprite, batchableMesh);
        }
        return gpuData;
      }
      destroy() {
        this._renderer = null;
      }
    };
    NineSliceSpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "nineSliceSprite"
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs
var init_init14 = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs"() {
    init_Extensions();
    init_NineSliceSpritePipe();
    extensions.add(NineSliceSpritePipe);
  }
});

// node_modules/pixi.js/lib/filters/FilterPipe.mjs
var FilterPipe;
var init_FilterPipe = __esm({
  "node_modules/pixi.js/lib/filters/FilterPipe.mjs"() {
    init_Extensions();
    FilterPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      push(filterEffect, container, instructionSet) {
        const renderPipes3 = this._renderer.renderPipes;
        renderPipes3.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "filter",
          canBundle: false,
          action: "pushFilter",
          container,
          filterEffect
        });
      }
      pop(_filterEffect, _container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      execute(instruction) {
        if (instruction.action === "pushFilter") {
          this._renderer.filter.push(instruction);
        } else if (instruction.action === "popFilter") {
          this._renderer.filter.pop();
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    FilterPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "filter"
    };
  }
});

// node_modules/pixi.js/lib/filters/Filter.mjs
var _Filter, Filter;
var init_Filter = __esm({
  "node_modules/pixi.js/lib/filters/Filter.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_Shader();
    init_State();
    _Filter = class _Filter2 extends Shader {
      /**
       * @param options - The optional parameters of this filter.
       */
      constructor(options) {
        options = { ..._Filter2.defaultOptions, ...options };
        super(options);
        this.enabled = true;
        this._state = State.for2d();
        this.blendMode = options.blendMode;
        this.padding = options.padding;
        if (typeof options.antialias === "boolean") {
          this.antialias = options.antialias ? "on" : "off";
        } else {
          this.antialias = options.antialias;
        }
        this.resolution = options.resolution;
        this.blendRequired = options.blendRequired;
        this.clipToViewport = options.clipToViewport;
        this.addResource("uTexture", 0, 1);
      }
      /**
       * Applies the filter
       * @param filterManager - The renderer to retrieve the filter from
       * @param input - The input render target.
       * @param output - The target to output to.
       * @param clearMode - Should the output be cleared before rendering to it
       */
      apply(filterManager, input, output, clearMode) {
        filterManager.applyFilter(this, input, output, clearMode);
      }
      /**
       * Get the blend mode of the filter.
       * @default "normal"
       */
      get blendMode() {
        return this._state.blendMode;
      }
      /** Sets the blend mode of the filter. */
      set blendMode(value) {
        this._state.blendMode = value;
      }
      /**
       * A short hand function to create a filter based of a vertex and fragment shader src.
       * @param options
       * @returns A shiny new PixiJS filter!
       */
      static from(options) {
        const { gpu, gl, ...rest } = options;
        let gpuProgram3;
        let glProgram3;
        if (gpu) {
          gpuProgram3 = GpuProgram.from(gpu);
        }
        if (gl) {
          glProgram3 = GlProgram.from(gl);
        }
        return new _Filter2({
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          ...rest
        });
      }
    };
    _Filter.defaultOptions = {
      blendMode: "normal",
      resolution: 1,
      padding: 0,
      antialias: "off",
      blendRequired: false,
      clipToViewport: true
    };
    Filter = _Filter;
  }
});

// node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs
var vertex2;
var init_defaultFilter_vert = __esm({
  "node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs"() {
    vertex2 = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs
var fragment2;
var init_passthrough_frag = __esm({
  "node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs"() {
    fragment2 = "in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs
var source;
var init_passthrough_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs"() {
    source = "struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs
var PassthroughFilter;
var init_PassthroughFilter = __esm({
  "node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_Filter();
    init_defaultFilter_vert();
    init_passthrough_frag();
    init_passthrough_wgsl();
    PassthroughFilter = class extends Filter {
      constructor() {
        const gpuProgram3 = GpuProgram.from({
          vertex: { source, entryPoint: "mainVertex" },
          fragment: { source, entryPoint: "mainFragment" },
          name: "passthrough-filter"
        });
        const glProgram3 = GlProgram.from({
          vertex: vertex2,
          fragment: fragment2,
          name: "passthrough-filter"
        });
        super({
          gpuProgram: gpuProgram3,
          glProgram: glProgram3
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
function getGlobalRenderableBounds(renderables, bounds) {
  bounds.clear();
  const actualMatrix = bounds.matrix;
  for (let i2 = 0; i2 < renderables.length; i2++) {
    const renderable = renderables[i2];
    if (renderable.globalDisplayStatus < 7) {
      continue;
    }
    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
    if (renderGroup?.isCachedAsTexture) {
      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);
    } else if (renderGroup?._parentCacheAsTextureRenderGroup) {
      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);
    } else {
      bounds.matrix = renderable.worldTransform;
    }
    bounds.addBounds(renderable.bounds);
  }
  bounds.matrix = actualMatrix;
  return bounds;
}
var tempProjectionMatrix;
var init_getRenderableBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs"() {
    init_Matrix();
    tempProjectionMatrix = new Matrix();
  }
});

// node_modules/pixi.js/lib/filters/FilterSystem.mjs
var quadGeometry, FilterData, FilterSystem;
var init_FilterSystem = __esm({
  "node_modules/pixi.js/lib/filters/FilterSystem.mjs"() {
    init_Extensions();
    init_PassthroughFilter();
    init_Matrix();
    init_BindGroup();
    init_Geometry();
    init_UniformGroup();
    init_Texture();
    init_TexturePool();
    init_types2();
    init_Bounds();
    init_getRenderableBounds();
    init_warn();
    quadGeometry = new Geometry({
      attributes: {
        aPosition: {
          buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        }
      },
      indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
    });
    FilterData = class {
      constructor() {
        this.skip = false;
        this.inputTexture = null;
        this.backTexture = null;
        this.filters = null;
        this.bounds = new Bounds();
        this.container = null;
        this.blendRequired = false;
        this.outputRenderSurface = null;
        this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };
        this.firstEnabledIndex = -1;
        this.lastEnabledIndex = -1;
      }
    };
    FilterSystem = class {
      constructor(renderer) {
        this._filterStackIndex = 0;
        this._filterStack = [];
        this._filterGlobalUniforms = new UniformGroup({
          uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
          uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
          uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
          uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
        });
        this._globalFilterBindGroup = new BindGroup({});
        this.renderer = renderer;
      }
      /**
       * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
       * @readonly
       */
      get activeBackTexture() {
        return this._activeFilterData?.backTexture;
      }
      /**
       * Pushes a filter instruction onto the filter stack.
       * @param instruction - The instruction containing the filter effect and container.
       * @internal
       */
      push(instruction) {
        const renderer = this.renderer;
        const filters = instruction.filterEffect.filters;
        const filterData = this._pushFilterData();
        filterData.skip = false;
        filterData.filters = filters;
        filterData.container = instruction.container;
        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;
        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
        const rootResolution = colorTextureSource.resolution;
        const rootAntialias = colorTextureSource.antialias;
        if (filters.every((filter) => !filter.enabled)) {
          filterData.skip = true;
          return;
        }
        const bounds = filterData.bounds;
        this._calculateFilterArea(instruction, bounds);
        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);
        if (filterData.skip) {
          return;
        }
        const previousFilterData = this._getPreviousFilterData();
        const globalResolution = this._findFilterResolution(rootResolution);
        let offsetX = 0;
        let offsetY = 0;
        if (previousFilterData) {
          offsetX = previousFilterData.bounds.minX;
          offsetY = previousFilterData.bounds.minY;
        }
        this._calculateGlobalFrame(
          filterData,
          offsetX,
          offsetY,
          globalResolution,
          colorTextureSource.width,
          colorTextureSource.height
        );
        this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);
      }
      /**
       * Applies filters to a texture.
       *
       * This method takes a texture and a list of filters, applies the filters to the texture,
       * and returns the resulting texture.
       * @param {object} params - The parameters for applying filters.
       * @param {Texture} params.texture - The texture to apply filters to.
       * @param {Filter[]} params.filters - The filters to apply.
       * @returns {Texture} The resulting texture after all filters have been applied.
       * @example
       *
       * ```ts
       * // Create a texture and a list of filters
       * const texture = new Texture(...);
       * const filters = [new BlurFilter(), new ColorMatrixFilter()];
       *
       * // Apply the filters to the texture
       * const resultTexture = filterSystem.applyToTexture({ texture, filters });
       *
       * // Use the resulting texture
       * sprite.texture = resultTexture;
       * ```
       *
       * Key Points:
       * 1. padding is not currently supported here - so clipping may occur with filters that use padding.
       * 2. If all filters are disabled or skipped, the original texture is returned.
       */
      generateFilteredTexture({ texture, filters }) {
        const filterData = this._pushFilterData();
        this._activeFilterData = filterData;
        filterData.skip = false;
        filterData.filters = filters;
        const colorTextureSource = texture.source;
        const rootResolution = colorTextureSource.resolution;
        const rootAntialias = colorTextureSource.antialias;
        if (filters.every((filter) => !filter.enabled)) {
          filterData.skip = true;
          return texture;
        }
        const bounds = filterData.bounds;
        bounds.addRect(texture.frame);
        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);
        if (filterData.skip) {
          return texture;
        }
        const globalResolution = rootResolution;
        const offsetX = 0;
        const offsetY = 0;
        this._calculateGlobalFrame(
          filterData,
          offsetX,
          offsetY,
          globalResolution,
          colorTextureSource.width,
          colorTextureSource.height
        );
        filterData.outputRenderSurface = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          filterData.resolution,
          filterData.antialias
        );
        filterData.backTexture = Texture.EMPTY;
        filterData.inputTexture = texture;
        const renderer = this.renderer;
        renderer.renderTarget.finishRenderPass();
        this._applyFiltersToTexture(filterData, true);
        const outputTexture = filterData.outputRenderSurface;
        outputTexture.source.alphaMode = "premultiplied-alpha";
        return outputTexture;
      }
      /** @internal */
      pop() {
        const renderer = this.renderer;
        const filterData = this._popFilterData();
        if (filterData.skip) {
          return;
        }
        renderer.globalUniforms.pop();
        renderer.renderTarget.finishRenderPass();
        this._activeFilterData = filterData;
        this._applyFiltersToTexture(filterData, false);
        if (filterData.blendRequired) {
          TexturePool.returnTexture(filterData.backTexture);
        }
        TexturePool.returnTexture(filterData.inputTexture);
      }
      /**
       * Copies the last render surface to a texture.
       * @param lastRenderSurface - The last render surface to copy from.
       * @param bounds - The bounds of the area to copy.
       * @param previousBounds - The previous bounds to use for offsetting the copy.
       */
      getBackTexture(lastRenderSurface, bounds, previousBounds) {
        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
        const backTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          backgroundResolution,
          false
        );
        let x2 = bounds.minX;
        let y2 = bounds.minY;
        if (previousBounds) {
          x2 -= previousBounds.minX;
          y2 -= previousBounds.minY;
        }
        x2 = Math.floor(x2 * backgroundResolution);
        y2 = Math.floor(y2 * backgroundResolution);
        const width = Math.ceil(bounds.width * backgroundResolution);
        const height = Math.ceil(bounds.height * backgroundResolution);
        this.renderer.renderTarget.copyToTexture(
          lastRenderSurface,
          backTexture,
          { x: x2, y: y2 },
          { width, height },
          { x: 0, y: 0 }
        );
        return backTexture;
      }
      /**
       * Applies a filter to a texture.
       * @param filter - The filter to apply.
       * @param input - The input texture.
       * @param output - The output render surface.
       * @param clear - Whether to clear the output surface before applying the filter.
       */
      applyFilter(filter, input, output, clear) {
        const renderer = this.renderer;
        const filterData = this._activeFilterData;
        const outputRenderSurface = filterData.outputRenderSurface;
        const isFinalTarget = outputRenderSurface === output;
        const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        const resolution = this._findFilterResolution(rootResolution);
        let offsetX = 0;
        let offsetY = 0;
        if (isFinalTarget) {
          const offset = this._findPreviousFilterOffset();
          offsetX = offset.x;
          offsetY = offset.y;
        }
        this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);
        const filterToApply = filter.enabled ? filter : this._getPassthroughFilter();
        this._setupBindGroupsAndRender(filterToApply, input, renderer);
      }
      /**
       * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
       *
       * Use `outputMatrix * vTextureCoord` in the shader.
       * @param outputMatrix - The matrix to output to.
       * @param {Sprite} sprite - The sprite to map to.
       * @returns The mapped matrix.
       */
      calculateSpriteMatrix(outputMatrix, sprite) {
        const data = this._activeFilterData;
        const mappedMatrix = outputMatrix.set(
          data.inputTexture._source.width,
          0,
          0,
          data.inputTexture._source.height,
          data.bounds.minX,
          data.bounds.minY
        );
        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;
        if (renderGroup && renderGroup.cacheToLocalTransform) {
          worldTransform.prepend(renderGroup.cacheToLocalTransform);
        }
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(
          1 / sprite.texture.orig.width,
          1 / sprite.texture.orig.height
        );
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      }
      destroy() {
        this._passthroughFilter?.destroy(true);
        this._passthroughFilter = null;
      }
      _getPassthroughFilter() {
        this._passthroughFilter ?? (this._passthroughFilter = new PassthroughFilter());
        return this._passthroughFilter;
      }
      /**
       * Sets up the bind groups and renders the filter.
       * @param filter - The filter to apply
       * @param input - The input texture
       * @param renderer - The renderer instance
       */
      _setupBindGroupsAndRender(filter, input, renderer) {
        if (renderer.renderPipes.uniformBatch) {
          const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
          this._globalFilterBindGroup.setResource(batchUniforms, 0);
        } else {
          this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
        }
        this._globalFilterBindGroup.setResource(input.source, 1);
        this._globalFilterBindGroup.setResource(input.source.style, 2);
        filter.groups[0] = this._globalFilterBindGroup;
        renderer.encoder.draw({
          geometry: quadGeometry,
          shader: filter,
          state: filter._state,
          topology: "triangle-list"
        });
        if (renderer.type === RendererType.WEBGL) {
          renderer.renderTarget.finishRenderPass();
        }
      }
      /**
       * Sets up the filter textures including input texture and back texture if needed.
       * @param filterData - The filter data to update
       * @param bounds - The bounds for the texture
       * @param renderer - The renderer instance
       * @param previousFilterData - The previous filter data for back texture calculation
       */
      _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {
        filterData.backTexture = Texture.EMPTY;
        filterData.inputTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          filterData.resolution,
          filterData.antialias
        );
        if (filterData.blendRequired) {
          renderer.renderTarget.finishRenderPass();
          const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);
          filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);
        }
        renderer.renderTarget.bind(filterData.inputTexture, true);
        renderer.globalUniforms.push({
          offset: bounds
        });
      }
      /**
       * Calculates and sets the global frame for the filter.
       * @param filterData - The filter data to update
       * @param offsetX - The X offset
       * @param offsetY - The Y offset
       * @param globalResolution - The global resolution
       * @param sourceWidth - The source texture width
       * @param sourceHeight - The source texture height
       */
      _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {
        const globalFrame = filterData.globalFrame;
        globalFrame.x = offsetX * globalResolution;
        globalFrame.y = offsetY * globalResolution;
        globalFrame.width = sourceWidth * globalResolution;
        globalFrame.height = sourceHeight * globalResolution;
      }
      /**
       * Updates the filter uniforms with the current filter state.
       * @param input - The input texture
       * @param output - The output render surface
       * @param filterData - The current filter data
       * @param offsetX - The X offset for positioning
       * @param offsetY - The Y offset for positioning
       * @param resolution - The current resolution
       * @param isFinalTarget - Whether this is the final render target
       * @param clear - Whether to clear the output surface
       */
      _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {
        const uniforms = this._filterGlobalUniforms.uniforms;
        const outputFrame = uniforms.uOutputFrame;
        const inputSize = uniforms.uInputSize;
        const inputPixel = uniforms.uInputPixel;
        const inputClamp = uniforms.uInputClamp;
        const globalFrame = uniforms.uGlobalFrame;
        const outputTexture = uniforms.uOutputTexture;
        if (isFinalTarget) {
          outputFrame[0] = filterData.bounds.minX - offsetX;
          outputFrame[1] = filterData.bounds.minY - offsetY;
        } else {
          outputFrame[0] = 0;
          outputFrame[1] = 0;
        }
        outputFrame[2] = input.frame.width;
        outputFrame[3] = input.frame.height;
        inputSize[0] = input.source.width;
        inputSize[1] = input.source.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = input.source.pixelWidth;
        inputPixel[1] = input.source.pixelHeight;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        globalFrame[0] = offsetX * resolution;
        globalFrame[1] = offsetY * resolution;
        globalFrame[2] = rootTexture.source.width * resolution;
        globalFrame[3] = rootTexture.source.height * resolution;
        if (output instanceof Texture)
          output.source.resource = null;
        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
        this.renderer.renderTarget.bind(output, !!clear);
        if (output instanceof Texture) {
          outputTexture[0] = output.frame.width;
          outputTexture[1] = output.frame.height;
        } else {
          outputTexture[0] = renderTarget.width;
          outputTexture[1] = renderTarget.height;
        }
        outputTexture[2] = renderTarget.isRoot ? -1 : 1;
        this._filterGlobalUniforms.update();
      }
      /**
       * Finds the correct resolution by looking back through the filter stack.
       * @param rootResolution - The fallback root resolution to use
       * @returns The resolution from the previous filter or root resolution
       */
      _findFilterResolution(rootResolution) {
        let currentIndex = this._filterStackIndex - 1;
        while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
          --currentIndex;
        }
        return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;
      }
      /**
       * Finds the offset from the previous non-skipped filter in the stack.
       * @returns The offset coordinates from the previous filter
       */
      _findPreviousFilterOffset() {
        let offsetX = 0;
        let offsetY = 0;
        let lastIndex = this._filterStackIndex;
        while (lastIndex > 0) {
          lastIndex--;
          const prevFilterData = this._filterStack[lastIndex];
          if (!prevFilterData.skip) {
            offsetX = prevFilterData.bounds.minX;
            offsetY = prevFilterData.bounds.minY;
            break;
          }
        }
        return { x: offsetX, y: offsetY };
      }
      /**
       * Calculates the filter area bounds based on the instruction type.
       * @param instruction - The filter instruction
       * @param bounds - The bounds object to populate
       */
      _calculateFilterArea(instruction, bounds) {
        if (instruction.renderables) {
          getGlobalRenderableBounds(instruction.renderables, bounds);
        } else if (instruction.filterEffect.filterArea) {
          bounds.clear();
          bounds.addRect(instruction.filterEffect.filterArea);
          bounds.applyMatrix(instruction.container.worldTransform);
        } else {
          instruction.container.getFastGlobalBounds(true, bounds);
        }
        if (instruction.container) {
          const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;
          const filterFrameTransform = renderGroup.cacheToLocalTransform;
          if (filterFrameTransform) {
            bounds.applyMatrix(filterFrameTransform);
          }
        }
      }
      _applyFiltersToTexture(filterData, clear) {
        const inputTexture = filterData.inputTexture;
        const bounds = filterData.bounds;
        const filters = filterData.filters;
        const firstEnabled = filterData.firstEnabledIndex;
        const lastEnabled = filterData.lastEnabledIndex;
        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);
        if (firstEnabled === lastEnabled) {
          filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);
        } else {
          let flip = filterData.inputTexture;
          const tempTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            flip.source._resolution,
            false
          );
          let flop = tempTexture;
          for (let i2 = firstEnabled; i2 < lastEnabled; i2++) {
            const filter = filters[i2];
            if (!filter.enabled)
              continue;
            filter.apply(this, flip, flop, true);
            const t2 = flip;
            flip = flop;
            flop = t2;
          }
          filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);
          TexturePool.returnTexture(tempTexture);
        }
      }
      _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {
        const renderer = this.renderer;
        const bounds = filterData.bounds;
        const filters = filterData.filters;
        let resolution = Infinity;
        let padding = 0;
        let antialias = true;
        let blendRequired = false;
        let enabled = false;
        let clipToViewport = true;
        let firstEnabledIndex = -1;
        let lastEnabledIndex = -1;
        for (let i2 = 0; i2 < filters.length; i2++) {
          const filter = filters[i2];
          if (!filter.enabled)
            continue;
          if (firstEnabledIndex === -1)
            firstEnabledIndex = i2;
          lastEnabledIndex = i2;
          resolution = Math.min(resolution, filter.resolution === "inherit" ? rootResolution : filter.resolution);
          padding += filter.padding;
          if (filter.antialias === "off") {
            antialias = false;
          } else if (filter.antialias === "inherit") {
            antialias && (antialias = rootAntialias);
          }
          if (!filter.clipToViewport) {
            clipToViewport = false;
          }
          const isCompatible = !!(filter.compatibleRenderers & renderer.type);
          if (!isCompatible) {
            enabled = false;
            break;
          }
          if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
            warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
            enabled = false;
            break;
          }
          enabled = true;
          blendRequired || (blendRequired = filter.blendRequired);
        }
        if (!enabled) {
          filterData.skip = true;
          return;
        }
        if (clipToViewport) {
          bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);
        }
        bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);
        if (!bounds.isPositive) {
          filterData.skip = true;
          return;
        }
        filterData.antialias = antialias;
        filterData.resolution = resolution;
        filterData.blendRequired = blendRequired;
        filterData.firstEnabledIndex = firstEnabledIndex;
        filterData.lastEnabledIndex = lastEnabledIndex;
      }
      _popFilterData() {
        this._filterStackIndex--;
        return this._filterStack[this._filterStackIndex];
      }
      _getPreviousFilterData() {
        let previousFilterData;
        let index = this._filterStackIndex - 1;
        while (index > 0) {
          index--;
          previousFilterData = this._filterStack[index];
          if (!previousFilterData.skip) {
            break;
          }
        }
        return previousFilterData;
      }
      _pushFilterData() {
        let filterData = this._filterStack[this._filterStackIndex];
        if (!filterData) {
          filterData = this._filterStack[this._filterStackIndex] = new FilterData();
        }
        this._filterStackIndex++;
        return filterData;
      }
    };
    FilterSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "filter"
    };
  }
});

// node_modules/pixi.js/lib/filters/init.mjs
var init_init15 = __esm({
  "node_modules/pixi.js/lib/filters/init.mjs"() {
    init_Extensions();
    init_FilterPipe();
    init_FilterSystem();
    extensions.add(FilterSystem);
    extensions.add(FilterPipe);
  }
});

// node_modules/pixi.js/lib/environment-browser/browserAll.mjs
var browserAll_exports = {};
var init_browserAll = __esm({
  "node_modules/pixi.js/lib/environment-browser/browserAll.mjs"() {
    init_init();
    init_init2();
    init_init3();
    init_init4();
    init_init5();
    init_init6();
    init_init7();
    init_init8();
    init_init9();
    init_init10();
    init_init11();
    init_init12();
    init_init13();
    init_init14();
    init_init15();
  }
});

// node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs
var webworkerAll_exports = {};
var init_webworkerAll = __esm({
  "node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs"() {
    init_init2();
    init_init5();
    init_init6();
    init_init7();
    init_init8();
    init_init9();
    init_init10();
    init_init11();
    init_init12();
    init_init13();
    init_init14();
    init_init15();
  }
});

// node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs
async function loadEnvironmentExtensions(skip) {
  if (skip)
    return;
  for (let i2 = 0; i2 < environments.length; i2++) {
    const env = environments[i2];
    if (env.value.test()) {
      await env.value.load();
      return;
    }
  }
}
var environments;
var init_autoDetectEnvironment = __esm({
  "node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs"() {
    init_Extensions();
    environments = [];
    extensions.handleByNamedList(ExtensionType.Environment, environments);
  }
});

// node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (_e) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var unsafeEval;
var init_unsafeEvalSupported = __esm({
  "node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
var CLEAR;
var init_const7 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"() {
    "use strict";
    CLEAR = /* @__PURE__ */ ((CLEAR2) => {
      CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
      CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
      CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
      CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
      CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
      CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
      CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
      CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
      return CLEAR2;
    })(CLEAR || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
var SystemRunner;
var init_SystemRunner = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
    "use strict";
    SystemRunner = class {
      /**
       * @param name - The function name that will be executed on the listeners added to this Runner.
       */
      constructor(name) {
        this.items = [];
        this._name = name;
      }
      /* jsdoc/check-param-names */
      /**
       * Dispatch/Broadcast Runner to all listeners added to the queue.
       * @param {...any} params - (optional) parameters to pass to each listener
       */
      /* jsdoc/check-param-names */
      emit(a0, a1, a2, a3, a4, a5, a6, a7) {
        const { name, items } = this;
        for (let i2 = 0, len = items.length; i2 < len; i2++) {
          items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        return this;
      }
      /**
       * Add a listener to the Runner
       *
       * Runners do not need to have scope or functions passed to them.
       * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
       * as the name provided to the Runner when it was created.
       *
       * Eg A listener passed to this Runner will require a 'complete' function.
       *
       * ```ts
       * import { Runner } from 'pixi.js';
       *
       * const complete = new Runner('complete');
       * ```
       *
       * The scope used will be the object itself.
       * @param {any} item - The object that will be listening.
       */
      add(item) {
        if (item[this._name]) {
          this.remove(item);
          this.items.push(item);
        }
        return this;
      }
      /**
       * Remove a single listener from the dispatch queue.
       * @param {any} item - The listener that you would like to remove.
       */
      remove(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
          this.items.splice(index, 1);
        }
        return this;
      }
      /**
       * Check to see if the listener is already in the Runner
       * @param {any} item - The listener that you would like to check.
       */
      contains(item) {
        return this.items.indexOf(item) !== -1;
      }
      /** Remove all listeners from the Runner */
      removeAll() {
        this.items.length = 0;
        return this;
      }
      /** Remove all references, don't use after this. */
      destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
      }
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get empty() {
        return this.items.length === 0;
      }
      /**
       * The name of the runner.
       * @readonly
       */
      get name() {
        return this._name;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
var defaultRunners, _AbstractRenderer, AbstractRenderer;
var init_AbstractRenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
    init_Color();
    init_autoDetectEnvironment();
    init_Container();
    init_unsafeEvalSupported();
    init_uid();
    init_deprecation();
    init_GlobalResourceRegistry();
    init_const7();
    init_SystemRunner();
    init_eventemitter3();
    defaultRunners = [
      "init",
      "destroy",
      "contextChange",
      "resolutionChange",
      "resetState",
      "renderEnd",
      "renderStart",
      "render",
      "update",
      "postrender",
      "prerender"
    ];
    _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
      /**
       * Set up a system with a collection of SystemClasses and runners.
       * Systems are attached dynamically to this class when added.
       * @param config - the config for the system manager
       */
      constructor(config) {
        super();
        this.uid = uid("renderer");
        this.runners = /* @__PURE__ */ Object.create(null);
        this.renderPipes = /* @__PURE__ */ Object.create(null);
        this._initOptions = {};
        this._systemsHash = /* @__PURE__ */ Object.create(null);
        this.type = config.type;
        this.name = config.name;
        this.config = config;
        const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
        this._addRunners(...combinedRunners);
        this._unsafeEvalCheck();
      }
      /**
       * Initialize the renderer.
       * @param options - The options to use to create the renderer.
       */
      async init(options = {}) {
        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
        await loadEnvironmentExtensions(skip);
        this._addSystems(this.config.systems);
        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
        for (const systemName in this._systemsHash) {
          const system = this._systemsHash[systemName];
          const defaultSystemOptions = system.constructor.defaultOptions;
          options = { ...defaultSystemOptions, ...options };
        }
        options = { ..._AbstractRenderer2.defaultOptions, ...options };
        this._roundPixels = options.roundPixels ? 1 : 0;
        for (let i2 = 0; i2 < this.runners.init.items.length; i2++) {
          await this.runners.init.items[i2].init(options);
        }
        this._initOptions = options;
      }
      render(args, deprecated) {
        let options = args;
        if (options instanceof Container) {
          options = { container: options };
          if (deprecated) {
            deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
            options.target = deprecated.renderTexture;
          }
        }
        options.target || (options.target = this.view.renderTarget);
        if (options.target === this.view.renderTarget) {
          this._lastObjectRendered = options.container;
          options.clearColor ?? (options.clearColor = this.background.colorRgba);
          options.clear ?? (options.clear = this.background.clearBeforeRender);
        }
        if (options.clearColor) {
          const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
          options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
        }
        if (!options.transform) {
          options.container.updateLocalTransform();
          options.transform = options.container.localTransform;
        }
        if (!options.container.visible) {
          return;
        }
        options.container.enableRenderGroup();
        this.runners.prerender.emit(options);
        this.runners.renderStart.emit(options);
        this.runners.render.emit(options);
        this.runners.renderEnd.emit(options);
        this.runners.postrender.emit(options);
      }
      /**
       * Resizes the WebGL view to the specified width and height.
       * @param desiredScreenWidth - The desired width of the screen.
       * @param desiredScreenHeight - The desired height of the screen.
       * @param resolution - The resolution / device pixel ratio of the renderer.
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        const previousResolution = this.view.resolution;
        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
        if (resolution !== void 0 && resolution !== previousResolution) {
          this.runners.resolutionChange.emit(resolution);
        }
      }
      /**
       * Clears the render target.
       * @param options - The options to use when clearing the render target.
       * @param options.target - The render target to clear.
       * @param options.clearColor - The color to clear with.
       * @param options.clear - The clear mode to use.
       * @advanced
       */
      clear(options = {}) {
        const renderer = this;
        options.target || (options.target = renderer.renderTarget.renderTarget);
        options.clearColor || (options.clearColor = this.background.colorRgba);
        options.clear ?? (options.clear = CLEAR.ALL);
        const { clear, clearColor, target } = options;
        Color.shared.setValue(clearColor ?? this.background.colorRgba);
        renderer.renderTarget.clear(target, clear, Color.shared.toArray());
      }
      /** The resolution / device pixel ratio of the renderer. */
      get resolution() {
        return this.view.resolution;
      }
      set resolution(value) {
        this.view.resolution = value;
        this.runners.resolutionChange.emit(value);
      }
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @type {number}
       * @readonly
       * @default 800
       */
      get width() {
        return this.view.texture.frame.width;
      }
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @default 600
       */
      get height() {
        return this.view.texture.frame.height;
      }
      // NOTE: this was `view` in v7
      /**
       * The canvas element that everything is drawn to.
       * @type {environment.ICanvas}
       */
      get canvas() {
        return this.view.canvas;
      }
      /**
       * the last object rendered by the renderer. Useful for other plugins like interaction managers
       * @readonly
       */
      get lastObjectRendered() {
        return this._lastObjectRendered;
      }
      /**
       * Flag if we are rendering to the screen vs renderTexture
       * @readonly
       * @default true
       */
      get renderingToScreen() {
        const renderer = this;
        return renderer.renderTarget.renderingToScreen;
      }
      /**
       * Measurements of the screen. (0, 0, screenWidth, screenHeight).
       *
       * Its safe to use as filterArea or hitArea for the whole stage.
       */
      get screen() {
        return this.view.screen;
      }
      /**
       * Create a bunch of runners based of a collection of ids
       * @param runnerIds - the runner ids to add
       */
      _addRunners(...runnerIds) {
        runnerIds.forEach((runnerId) => {
          this.runners[runnerId] = new SystemRunner(runnerId);
        });
      }
      _addSystems(systems3) {
        let i2;
        for (i2 in systems3) {
          const val = systems3[i2];
          this._addSystem(val.value, val.name);
        }
      }
      /**
       * Add a new system to the renderer.
       * @param ClassRef - Class reference
       * @param name - Property name for system, if not specified
       *        will use a static `name` property on the class itself. This
       *        name will be assigned as s property on the Renderer so make
       *        sure it doesn't collide with properties on Renderer.
       * @returns Return instance of renderer
       */
      _addSystem(ClassRef, name) {
        const system = new ClassRef(this);
        if (this[name]) {
          throw new Error(`Whoops! The name "${name}" is already in use`);
        }
        this[name] = system;
        this._systemsHash[name] = system;
        for (const i2 in this.runners) {
          this.runners[i2].add(system);
        }
        return this;
      }
      _addPipes(pipes, pipeAdaptors) {
        const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
          acc[adaptor.name] = adaptor.value;
          return acc;
        }, {});
        pipes.forEach((pipe) => {
          const PipeClass = pipe.value;
          const name = pipe.name;
          const Adaptor = adaptors[name];
          this.renderPipes[name] = new PipeClass(
            this,
            Adaptor ? new Adaptor() : null
          );
          this.runners.destroy.add(this.renderPipes[name]);
        });
      }
      destroy(options = false) {
        this.runners.destroy.items.reverse();
        this.runners.destroy.emit(options);
        Object.values(this.runners).forEach((runner) => {
          runner.destroy();
        });
        if (options === true || typeof options === "object" && options.releaseGlobalResources) {
          GlobalResourceRegistry.release();
        }
        this._systemsHash = null;
        this.renderPipes = null;
      }
      /**
       * Generate a texture from a container.
       * @param options - options or container target to use when generating the texture
       * @returns a texture
       */
      generateTexture(options) {
        return this.textureGenerator.generateTexture(options);
      }
      /**
       * Whether the renderer will round coordinates to whole pixels when rendering.
       * Can be overridden on a per scene item basis.
       */
      get roundPixels() {
        return !!this._roundPixels;
      }
      /**
       * Overridable function by `pixi.js/unsafe-eval` to silence
       * throwing an error if platform doesn't support unsafe-evals.
       * @private
       * @ignore
       */
      _unsafeEvalCheck() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
      }
      /**
       * Resets the rendering state of the renderer.
       * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state
       * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi
       * render will reset all internal caches and ensure it executes correctly.
       *
       * This is particularly useful when combining PixiJS with other rendering engines like Three.js:
       * ```js
       * // Reset Three.js state
       * threeRenderer.resetState();
       *
       * // Render a Three.js scene
       * threeRenderer.render(threeScene, threeCamera);
       *
       * // Reset PixiJS state since Three.js modified the WebGL context
       * pixiRenderer.resetState();
       *
       * // Now render Pixi content
       * pixiRenderer.render(pixiScene);
       * ```
       * @advanced
       */
      resetState() {
        this.runners.resetState.emit();
      }
    };
    _AbstractRenderer.defaultOptions = {
      /**
       * Default resolution / device pixel ratio of the renderer.
       * @default 1
       */
      resolution: 1,
      /**
       * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
       * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
       * performance issues when using WebGL.
       *
       * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
       * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
       * driver version blacklisted by the
       * browser.
       *
       * If your application requires high performance rendering, you may wish to set this to false.
       * We recommend one of two options if you decide to set this flag to false:
       *
       * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
       *    not supported.
       *
       * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
       *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
       *    device & browser combination does not support high performance WebGL.
       *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
       * @default false
       */
      failIfMajorPerformanceCaveat: false,
      /**
       * Should round pixels be forced when rendering?
       * @default false
       */
      roundPixels: false
    };
    AbstractRenderer = _AbstractRenderer;
  }
});

// node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
var GpuGraphicsAdaptor;
var init_GpuGraphicsAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_getTextureBatchBindGroup();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    GpuGraphicsAdaptor = class {
      constructor() {
        this._maxTextures = 0;
      }
      contextChange(renderer) {
        const localUniforms = new UniformGroup({
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        this._maxTextures = renderer.limits.maxBatchableTextures;
        const gpuProgram3 = compileHighShaderGpuProgram({
          name: "graphics",
          bits: [
            colorBit,
            generateTextureBatchBit(this._maxTextures),
            localUniformBitGroup2,
            roundPixelsBit
          ]
        });
        this.shader = new Shader({
          gpuProgram: gpuProgram3,
          resources: {
            // added on the fly!
            localUniforms
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context2 = renderable.context;
        const shader = context2.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          batcher,
          instructions
        } = contextSystem.getContextRenderData(context2);
        const encoder = renderer.encoder;
        encoder.setGeometry(batcher.geometry, shader.gpuProgram);
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
        const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
        const batches = instructions.instructions;
        let topology = null;
        for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
          const batch = batches[i2];
          if (batch.topology !== topology) {
            topology = batch.topology;
            encoder.setPipelineFromGeometryProgramAndState(
              batcher.geometry,
              shader.gpuProgram,
              graphicsPipe.state,
              batch.topology
            );
          }
          shader.groups[1] = batch.bindGroup;
          if (!batch.gpuBindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(
              textureBatch.textures,
              textureBatch.count,
              this._maxTextures
            );
            batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
              batch.bindGroup,
              shader.gpuProgram,
              1
            );
          }
          encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GpuGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
var textureBit, textureBitGl;
var init_textureBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
    "use strict";
    textureBit = {
      name: "texture-bit",
      vertex: {
        header: (
          /* wgsl */
          `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `
        ),
        main: (
          /* wgsl */
          `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        )
      }
    };
    textureBitGl = {
      name: "texture-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTextureMatrix;
        `
        ),
        main: (
          /* glsl */
          `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
        uniform sampler2D uTexture;


        `
        ),
        main: (
          /* glsl */
          `
            outColor = texture(uTexture, vUV);
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
var GpuMeshAdapter;
var init_GpuMeshAdapter = __esm({
  "node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
    init_Extensions();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    init_warn();
    GpuMeshAdapter = class {
      init() {
        const gpuProgram3 = compileHighShaderGpuProgram({
          name: "mesh",
          bits: [
            localUniformBit,
            textureBit,
            roundPixelsBit
          ]
        });
        this._shader = new Shader({
          gpuProgram: gpuProgram3,
          resources: {
            uTexture: Texture.EMPTY._source,
            uSampler: Texture.EMPTY._source.style,
            textureUniforms: {
              uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
            }
          }
        });
      }
      execute(meshPipe, mesh) {
        const renderer = meshPipe.renderer;
        let shader = mesh._shader;
        if (!shader) {
          shader = this._shader;
          shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
        } else if (!shader.gpuProgram) {
          warn("Mesh shader has no gpuProgram", mesh.shader);
          return;
        }
        const gpuProgram3 = shader.gpuProgram;
        if (gpuProgram3.autoAssignGlobalUniforms) {
          shader.groups[0] = renderer.globalUniforms.bindGroup;
        }
        if (gpuProgram3.autoAssignLocalUniforms) {
          const localUniforms = meshPipe.localUniforms;
          shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
        }
        renderer.encoder.draw({
          geometry: mesh._geometry,
          shader,
          state: mesh.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GpuMeshAdapter.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
var tempState, GpuBatchAdaptor;
var init_GpuBatchAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
    init_Extensions();
    init_State();
    init_getTextureBatchBindGroup();
    tempState = State.for2d();
    GpuBatchAdaptor = class {
      start(batchPipe, geometry, shader) {
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        const program = shader.gpuProgram;
        this._shader = shader;
        this._geometry = geometry;
        encoder.setGeometry(geometry, program);
        tempState.blendMode = "normal";
        renderer.pipeline.getPipeline(
          geometry,
          program,
          tempState
        );
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.resetBindGroup(1);
        encoder.setBindGroup(0, globalUniformsBindGroup, program);
      }
      execute(batchPipe, batch) {
        const program = this._shader.gpuProgram;
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        if (!batch.bindGroup) {
          const textureBatch = batch.textures;
          batch.bindGroup = getTextureBatchBindGroup(
            textureBatch.textures,
            textureBatch.count,
            renderer.limits.maxBatchableTextures
          );
        }
        tempState.blendMode = batch.blendMode;
        const gpuBindGroup = renderer.bindGroup.getBindGroup(
          batch.bindGroup,
          program,
          1
        );
        const pipeline = renderer.pipeline.getPipeline(
          this._geometry,
          program,
          tempState,
          batch.topology
        );
        batch.bindGroup._touch(renderer.textureGC.count);
        encoder.setPipeline(pipeline);
        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
      }
    };
    GpuBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs
var CustomRenderPipe;
var init_CustomRenderPipe = __esm({
  "node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs"() {
    init_Extensions();
    CustomRenderPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      updateRenderable() {
      }
      destroyRenderable() {
      }
      validateRenderable() {
        return false;
      }
      addRenderable(container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(container);
      }
      execute(container) {
        if (!container.isRenderable)
          return;
        container.render(this._renderer);
      }
      destroy() {
        this._renderer = null;
      }
    };
    CustomRenderPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "customRender"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
function executeInstructions(renderGroup, renderer) {
  const instructionSet = renderGroup.instructionSet;
  const instructions = instructionSet.instructions;
  for (let i2 = 0; i2 < instructionSet.instructionSize; i2++) {
    const instruction = instructions[i2];
    renderer[instruction.renderPipeId].execute(instruction);
  }
}
var init_executeInstructions = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs
var tempMatrix5, RenderGroupPipe;
var init_RenderGroupPipe = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs"() {
    init_Extensions();
    init_Matrix();
    init_PoolGroup();
    init_BatchableSprite();
    init_executeInstructions();
    tempMatrix5 = new Matrix();
    RenderGroupPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      addRenderGroup(renderGroup, instructionSet) {
        if (renderGroup.isCachedAsTexture) {
          this._addRenderableCacheAsTexture(renderGroup, instructionSet);
        } else {
          this._addRenderableDirect(renderGroup, instructionSet);
        }
      }
      execute(renderGroup) {
        if (!renderGroup.isRenderable)
          return;
        if (renderGroup.isCachedAsTexture) {
          this._executeCacheAsTexture(renderGroup);
        } else {
          this._executeDirect(renderGroup);
        }
      }
      destroy() {
        this._renderer = null;
      }
      _addRenderableDirect(renderGroup, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        if (renderGroup._batchableRenderGroup) {
          BigPool.return(renderGroup._batchableRenderGroup);
          renderGroup._batchableRenderGroup = null;
        }
        instructionSet.add(renderGroup);
      }
      _addRenderableCacheAsTexture(renderGroup, instructionSet) {
        const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));
        batchableRenderGroup.renderable = renderGroup.root;
        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;
        batchableRenderGroup.texture = renderGroup.texture;
        batchableRenderGroup.bounds = renderGroup._textureBounds;
        instructionSet.add(renderGroup);
        this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);
        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);
        this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);
      }
      _executeCacheAsTexture(renderGroup) {
        if (renderGroup.textureNeedsUpdate) {
          renderGroup.textureNeedsUpdate = false;
          const worldTransformMatrix = tempMatrix5.identity().translate(
            -renderGroup._textureBounds.x,
            -renderGroup._textureBounds.y
          );
          this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);
          this._renderer.globalUniforms.push({
            worldTransformMatrix,
            worldColor: 4294967295,
            offset: { x: 0, y: 0 }
          });
          executeInstructions(renderGroup, this._renderer.renderPipes);
          this._renderer.renderTarget.finishRenderPass();
          this._renderer.renderTarget.pop();
          this._renderer.globalUniforms.pop();
        }
        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);
        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();
      }
      _executeDirect(renderGroup) {
        this._renderer.globalUniforms.push({
          worldTransformMatrix: renderGroup.inverseParentTextureTransform,
          worldColor: renderGroup.worldColorAlpha
        });
        executeInstructions(renderGroup, this._renderer.renderPipes);
        this._renderer.globalUniforms.pop();
      }
    };
    RenderGroupPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "renderGroup"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/clearList.mjs
function clearList(list, index) {
  index || (index = 0);
  for (let j2 = index; j2 < list.length; j2++) {
    if (list[j2]) {
      list[j2] = null;
    } else {
      break;
    }
  }
}
var init_clearList = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/clearList.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs
function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
  updateRenderGroupTransform(renderGroup);
  const childrenToUpdate = renderGroup.childrenToUpdate;
  const updateTick = renderGroup.updateTick++;
  for (const j2 in childrenToUpdate) {
    const renderGroupDepth = Number(j2);
    const childrenAtDepth = childrenToUpdate[j2];
    const list = childrenAtDepth.list;
    const index = childrenAtDepth.index;
    for (let i2 = 0; i2 < index; i2++) {
      const child = list[i2];
      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
        updateTransformAndChildren(child, updateTick, 0);
      }
    }
    clearList(list, index);
    childrenAtDepth.index = 0;
  }
  if (updateChildRenderGroups) {
    for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i2], updateChildRenderGroups);
    }
  }
}
function updateRenderGroupTransform(renderGroup) {
  const root = renderGroup.root;
  let worldAlpha;
  if (renderGroup.renderGroupParent) {
    const renderGroupParent = renderGroup.renderGroupParent;
    renderGroup.worldTransform.appendFrom(
      root.relativeGroupTransform,
      renderGroupParent.worldTransform
    );
    renderGroup.worldColor = multiplyColors(
      root.groupColor,
      renderGroupParent.worldColor
    );
    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
  } else {
    renderGroup.worldTransform.copyFrom(root.localTransform);
    renderGroup.worldColor = root.localColor;
    worldAlpha = root.localAlpha;
  }
  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
  renderGroup.worldAlpha = worldAlpha;
  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
  if (updateTick === container.updateTick)
    return;
  container.updateTick = updateTick;
  container.didChange = false;
  const localTransform = container.localTransform;
  container.updateLocalTransform();
  const parent = container.parent;
  if (parent && !parent.renderGroup) {
    updateFlags |= container._updateFlags;
    container.relativeGroupTransform.appendFrom(
      localTransform,
      parent.relativeGroupTransform
    );
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, parent, updateFlags);
    }
  } else {
    updateFlags = container._updateFlags;
    container.relativeGroupTransform.copyFrom(localTransform);
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, tempContainer, updateFlags);
    }
  }
  if (!container.renderGroup) {
    const children = container.children;
    const length = children.length;
    for (let i2 = 0; i2 < length; i2++) {
      updateTransformAndChildren(children[i2], updateTick, updateFlags);
    }
    const renderGroup = container.parentRenderGroup;
    const renderable = container;
    if (renderable.renderPipeId && !renderGroup.structureDidChange) {
      renderGroup.updateRenderable(renderable);
    }
  }
}
function updateColorBlendVisibility(container, parent, updateFlags) {
  if (updateFlags & UPDATE_COLOR) {
    container.groupColor = multiplyColors(
      container.localColor,
      parent.groupColor
    );
    let groupAlpha = container.localAlpha * parent.groupAlpha;
    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
    container.groupAlpha = groupAlpha;
    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
  }
  if (updateFlags & UPDATE_BLEND) {
    container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
  }
  if (updateFlags & UPDATE_VISIBLE) {
    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
  }
  container._updateFlags = 0;
}
var tempContainer, UPDATE_BLEND_COLOR_VISIBLE;
var init_updateRenderGroupTransforms = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs"() {
    init_Container();
    init_clearList();
    init_multiplyColors();
    tempContainer = new Container();
    UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
  }
});

// node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
function validateRenderables(renderGroup, renderPipes3) {
  const { list } = renderGroup.childrenRenderablesToUpdate;
  let rebuildRequired = false;
  for (let i2 = 0; i2 < renderGroup.childrenRenderablesToUpdate.index; i2++) {
    const container = list[i2];
    const renderable = container;
    const pipe = renderPipes3[renderable.renderPipeId];
    rebuildRequired = pipe.validateRenderable(container);
    if (rebuildRequired) {
      break;
    }
  }
  renderGroup.structureDidChange = rebuildRequired;
  return rebuildRequired;
}
var init_validateRenderables = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs
var tempMatrix6, RenderGroupSystem;
var init_RenderGroupSystem = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_TexturePool();
    init_TextureStyle();
    init_Bounds();
    init_clearList();
    init_executeInstructions();
    init_updateRenderGroupTransforms();
    init_validateRenderables();
    tempMatrix6 = new Matrix();
    RenderGroupSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      render({ container, transform }) {
        const parent = container.parent;
        const renderGroupParent = container.renderGroup.renderGroupParent;
        container.parent = null;
        container.renderGroup.renderGroupParent = null;
        const renderer = this._renderer;
        const originalLocalTransform = tempMatrix6;
        if (transform) {
          originalLocalTransform.copyFrom(container.renderGroup.localTransform);
          container.renderGroup.localTransform.copyFrom(transform);
        }
        const renderPipes3 = renderer.renderPipes;
        this._updateCachedRenderGroups(container.renderGroup, null);
        this._updateRenderGroups(container.renderGroup);
        renderer.globalUniforms.start({
          worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
          worldColor: container.renderGroup.worldColorAlpha
        });
        executeInstructions(container.renderGroup, renderPipes3);
        if (renderPipes3.uniformBatch) {
          renderPipes3.uniformBatch.renderEnd();
        }
        if (transform) {
          container.renderGroup.localTransform.copyFrom(originalLocalTransform);
        }
        container.parent = parent;
        container.renderGroup.renderGroupParent = renderGroupParent;
      }
      destroy() {
        this._renderer = null;
      }
      _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {
        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;
        if (renderGroup.isCachedAsTexture) {
          if (!renderGroup.textureNeedsUpdate)
            return;
          closestCacheAsTexture = renderGroup;
        }
        for (let i2 = renderGroup.renderGroupChildren.length - 1; i2 >= 0; i2--) {
          this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i2], closestCacheAsTexture);
        }
        renderGroup.invalidateMatrices();
        if (renderGroup.isCachedAsTexture) {
          if (renderGroup.textureNeedsUpdate) {
            const bounds = renderGroup.root.getLocalBounds();
            bounds.ceil();
            const lastTexture = renderGroup.texture;
            if (renderGroup.texture) {
              TexturePool.returnTexture(renderGroup.texture, true);
            }
            const renderer = this._renderer;
            const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;
            const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;
            const scaleMode = renderGroup.textureOptions.scaleMode ?? "linear";
            const texture = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              resolution,
              antialias
            );
            texture._source.style = new TextureStyle({ scaleMode });
            renderGroup.texture = texture;
            renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());
            renderGroup._textureBounds.copyFrom(bounds);
            if (lastTexture !== renderGroup.texture) {
              if (renderGroup.renderGroupParent) {
                renderGroup.renderGroupParent.structureDidChange = true;
              }
            }
          }
        } else if (renderGroup.texture) {
          TexturePool.returnTexture(renderGroup.texture, true);
          renderGroup.texture = null;
        }
      }
      _updateRenderGroups(renderGroup) {
        const renderer = this._renderer;
        const renderPipes3 = renderer.renderPipes;
        renderGroup.runOnRender(renderer);
        renderGroup.instructionSet.renderPipes = renderPipes3;
        if (!renderGroup.structureDidChange) {
          validateRenderables(renderGroup, renderPipes3);
        } else {
          clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
        }
        updateRenderGroupTransforms(renderGroup);
        if (renderGroup.structureDidChange) {
          renderGroup.structureDidChange = false;
          this._buildInstructions(renderGroup, renderer);
        } else {
          this._updateRenderables(renderGroup);
        }
        renderGroup.childrenRenderablesToUpdate.index = 0;
        renderer.renderPipes.batch.upload(renderGroup.instructionSet);
        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)
          return;
        for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
          this._updateRenderGroups(renderGroup.renderGroupChildren[i2]);
        }
      }
      _updateRenderables(renderGroup) {
        const { list, index } = renderGroup.childrenRenderablesToUpdate;
        for (let i2 = 0; i2 < index; i2++) {
          const container = list[i2];
          if (container.didViewUpdate) {
            renderGroup.updateRenderable(container);
          }
        }
        clearList(list, index);
      }
      _buildInstructions(renderGroup, rendererOrPipes) {
        const root = renderGroup.root;
        const instructionSet = renderGroup.instructionSet;
        instructionSet.reset();
        const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
        const renderPipes3 = renderer.renderPipes;
        renderPipes3.batch.buildStart(instructionSet);
        renderPipes3.blendMode.buildStart();
        renderPipes3.colorMask.buildStart();
        if (root.sortableChildren) {
          root.sortChildren();
        }
        root.collectRenderablesWithEffects(instructionSet, renderer, null);
        renderPipes3.batch.buildEnd(instructionSet);
        renderPipes3.blendMode.buildEnd(instructionSet);
      }
    };
    RenderGroupSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "renderGroup"
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
var SpritePipe;
var init_SpritePipe = __esm({
  "node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs"() {
    init_Extensions();
    init_BatchableSprite();
    SpritePipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      addRenderable(sprite, instructionSet) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
      }
      updateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        gpuSprite._batcher.updateElement(gpuSprite);
      }
      validateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        return !gpuSprite._batcher.checkAndUpdateTexture(
          gpuSprite,
          sprite._texture
        );
      }
      _updateBatchableSprite(sprite, batchableSprite) {
        batchableSprite.bounds = sprite.visualBounds;
        batchableSprite.texture = sprite._texture;
      }
      _getGpuSprite(sprite) {
        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
      }
      _initGPUSprite(sprite) {
        const batchableSprite = new BatchableSprite();
        batchableSprite.renderable = sprite;
        batchableSprite.transform = sprite.groupTransform;
        batchableSprite.texture = sprite._texture;
        batchableSprite.bounds = sprite.visualBounds;
        batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
        sprite._gpuData[this._renderer.uid] = batchableSprite;
        return batchableSprite;
      }
      destroy() {
        this._renderer = null;
      }
    };
    SpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "sprite"
    };
  }
});

// node_modules/pixi.js/lib/utils/const.mjs
var VERSION;
var init_const8 = __esm({
  "node_modules/pixi.js/lib/utils/const.mjs"() {
    init_eventemitter3();
    VERSION = "8.14.0";
  }
});

// node_modules/pixi.js/lib/utils/global/globalHooks.mjs
var ApplicationInitHook, RendererInitHook;
var init_globalHooks = __esm({
  "node_modules/pixi.js/lib/utils/global/globalHooks.mjs"() {
    init_Extensions();
    init_const8();
    ApplicationInitHook = class {
      static init() {
        globalThis.__PIXI_APP_INIT__?.(this, VERSION);
      }
      static destroy() {
      }
    };
    ApplicationInitHook.extension = ExtensionType.Application;
    RendererInitHook = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      init() {
        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);
      }
      destroy() {
        this._renderer = null;
      }
    };
    RendererInitHook.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "initHook",
      priority: -10
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
var _BatcherPipe, BatcherPipe;
var init_BatcherPipe = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
    init_Extensions();
    init_State();
    init_DefaultBatcher();
    _BatcherPipe = class _BatcherPipe2 {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
        this._activeBatches = /* @__PURE__ */ Object.create(null);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init?.(this);
      }
      static getBatcher(name) {
        return new this._availableBatchers[name]();
      }
      buildStart(instructionSet) {
        let batchers = this._batchersByInstructionSet[instructionSet.uid];
        if (!batchers) {
          batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
          batchers.default || (batchers.default = new DefaultBatcher({
            maxTextures: this.renderer.limits.maxBatchableTextures
          }));
        }
        this._activeBatches = batchers;
        this._activeBatch = this._activeBatches.default;
        for (const i2 in this._activeBatches) {
          this._activeBatches[i2].begin();
        }
      }
      addToBatch(batchableObject, instructionSet) {
        if (this._activeBatch.name !== batchableObject.batcherName) {
          this._activeBatch.break(instructionSet);
          let batch = this._activeBatches[batchableObject.batcherName];
          if (!batch) {
            batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe2.getBatcher(batchableObject.batcherName);
            batch.begin();
          }
          this._activeBatch = batch;
        }
        this._activeBatch.add(batchableObject);
      }
      break(instructionSet) {
        this._activeBatch.break(instructionSet);
      }
      buildEnd(instructionSet) {
        this._activeBatch.break(instructionSet);
        const batches = this._activeBatches;
        for (const i2 in batches) {
          const batch = batches[i2];
          const geometry = batch.geometry;
          geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
          geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
        }
      }
      upload(instructionSet) {
        const batchers = this._batchersByInstructionSet[instructionSet.uid];
        for (const i2 in batchers) {
          const batcher = batchers[i2];
          const geometry = batcher.geometry;
          if (batcher.dirty) {
            batcher.dirty = false;
            geometry.buffers[0].update(batcher.attributeSize * 4);
          }
        }
      }
      execute(batch) {
        if (batch.action === "startBatch") {
          const batcher = batch.batcher;
          const geometry = batcher.geometry;
          const shader = batcher.shader;
          this._adaptor.start(this, geometry, shader);
        }
        this._adaptor.execute(this, batch);
      }
      destroy() {
        this.state = null;
        this.renderer = null;
        this._adaptor = null;
        for (const i2 in this._activeBatches) {
          this._activeBatches[i2].destroy();
        }
        this._activeBatches = null;
      }
    };
    _BatcherPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "batch"
    };
    _BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
    BatcherPipe = _BatcherPipe;
    extensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);
    extensions.add(DefaultBatcher);
  }
});

// node_modules/pixi.js/lib/filters/mask/mask.frag.mjs
var fragment3;
var init_mask_frag = __esm({
  "node_modules/pixi.js/lib/filters/mask/mask.frag.mjs"() {
    fragment3 = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/mask/mask.vert.mjs
var vertex3;
var init_mask_vert = __esm({
  "node_modules/pixi.js/lib/filters/mask/mask.vert.mjs"() {
    vertex3 = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs
var source2;
var init_mask_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs"() {
    source2 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
var MaskFilter;
var init_MaskFilter = __esm({
  "node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs"() {
    init_Matrix();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_TextureMatrix();
    init_Filter();
    init_mask_frag();
    init_mask_vert();
    init_mask_wgsl();
    MaskFilter = class extends Filter {
      constructor(options) {
        const { sprite, ...rest } = options;
        const textureMatrix = new TextureMatrix(sprite.texture);
        const filterUniforms = new UniformGroup({
          uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
          uAlpha: { value: 1, type: "f32" },
          uInverse: { value: options.inverse ? 1 : 0, type: "f32" }
        });
        const gpuProgram3 = GpuProgram.from({
          vertex: {
            source: source2,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: source2,
            entryPoint: "mainFragment"
          }
        });
        const glProgram3 = GlProgram.from({
          vertex: vertex3,
          fragment: fragment3,
          name: "mask-filter"
        });
        super({
          ...rest,
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          clipToViewport: false,
          resources: {
            filterUniforms,
            uMaskTexture: sprite.texture.source
          }
        });
        this.sprite = sprite;
        this._textureMatrix = textureMatrix;
      }
      set inverse(value) {
        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;
      }
      get inverse() {
        return this.resources.filterUniforms.uniforms.uInverse === 1;
      }
      apply(filterManager, input, output, clearMode) {
        this._textureMatrix.texture = this.sprite.texture;
        filterManager.calculateSpriteMatrix(
          this.resources.filterUniforms.uniforms.uFilterMatrix,
          this.sprite
        ).prepend(this._textureMatrix.mapCoord);
        this.resources.uMaskTexture = this.sprite.texture.source;
        filterManager.applyFilter(this, input, output, clearMode);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
var tempBounds3, AlphaMaskEffect, AlphaMaskPipe;
var init_AlphaMaskPipe = __esm({
  "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
    init_Extensions();
    init_FilterEffect();
    init_MaskFilter();
    init_Bounds();
    init_getGlobalBounds();
    init_Sprite();
    init_PoolGroup();
    init_Texture();
    init_TexturePool();
    init_types2();
    tempBounds3 = new Bounds();
    AlphaMaskEffect = class extends FilterEffect {
      constructor() {
        super();
        this.filters = [new MaskFilter({
          sprite: new Sprite(Texture.EMPTY),
          inverse: false,
          resolution: "inherit",
          antialias: "inherit"
        })];
      }
      get sprite() {
        return this.filters[0].sprite;
      }
      set sprite(value) {
        this.filters[0].sprite = value;
      }
      get inverse() {
        return this.filters[0].inverse;
      }
      set inverse(value) {
        this.filters[0].inverse = value;
      }
    };
    AlphaMaskPipe = class {
      constructor(renderer) {
        this._activeMaskStage = [];
        this._renderer = renderer;
      }
      push(mask, maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "alphaMask",
          action: "pushMaskBegin",
          mask,
          inverse: maskedContainer._maskOptions.inverse,
          canBundle: false,
          maskedContainer
        });
        mask.inverse = maskedContainer._maskOptions.inverse;
        if (mask.renderMaskToTexture) {
          const maskContainer = mask.mask;
          maskContainer.includeInBuild = true;
          maskContainer.collectRenderables(
            instructionSet,
            renderer,
            null
          );
          maskContainer.includeInBuild = false;
        }
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "alphaMask",
          action: "pushMaskEnd",
          mask,
          maskedContainer,
          inverse: maskedContainer._maskOptions.inverse,
          canBundle: false
        });
      }
      pop(mask, _maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "alphaMask",
          action: "popMaskEnd",
          mask,
          inverse: _maskedContainer._maskOptions.inverse,
          canBundle: false
        });
      }
      execute(instruction) {
        const renderer = this._renderer;
        const renderMask = instruction.mask.renderMaskToTexture;
        if (instruction.action === "pushMaskBegin") {
          const filterEffect = BigPool.get(AlphaMaskEffect);
          filterEffect.inverse = instruction.inverse;
          if (renderMask) {
            instruction.mask.mask.measurable = true;
            const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
            instruction.mask.mask.measurable = false;
            bounds.ceil();
            const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
            const filterTexture = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              colorTextureSource._resolution,
              colorTextureSource.antialias
            );
            renderer.renderTarget.push(filterTexture, true);
            renderer.globalUniforms.push({
              offset: bounds,
              worldColor: 4294967295
            });
            const sprite = filterEffect.sprite;
            sprite.texture = filterTexture;
            sprite.worldTransform.tx = bounds.minX;
            sprite.worldTransform.ty = bounds.minY;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer,
              filterTexture
            });
          } else {
            filterEffect.sprite = instruction.mask.mask;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer
            });
          }
        } else if (instruction.action === "pushMaskEnd") {
          const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
          if (renderMask) {
            if (renderer.type === RendererType.WEBGL) {
              renderer.renderTarget.finishRenderPass();
            }
            renderer.renderTarget.pop();
            renderer.globalUniforms.pop();
          }
          renderer.filter.push({
            renderPipeId: "filter",
            action: "pushFilter",
            container: maskData.maskedContainer,
            filterEffect: maskData.filterEffect,
            canBundle: false
          });
        } else if (instruction.action === "popMaskEnd") {
          renderer.filter.pop();
          const maskData = this._activeMaskStage.pop();
          if (renderMask) {
            TexturePool.returnTexture(maskData.filterTexture);
          }
          BigPool.return(maskData.filterEffect);
        }
      }
      destroy() {
        this._renderer = null;
        this._activeMaskStage = null;
      }
    };
    AlphaMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "alphaMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
var ColorMaskPipe;
var init_ColorMaskPipe = __esm({
  "node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
    init_Extensions();
    ColorMaskPipe = class {
      constructor(renderer) {
        this._colorStack = [];
        this._colorStackIndex = 0;
        this._currentColor = 0;
        this._renderer = renderer;
      }
      buildStart() {
        this._colorStack[0] = 15;
        this._colorStackIndex = 1;
        this._currentColor = 15;
      }
      push(mask, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
        const currentColor = this._colorStack[this._colorStackIndex];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            renderPipeId: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
        this._colorStackIndex++;
      }
      pop(_mask, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        this._colorStackIndex--;
        const currentColor = colorStack[this._colorStackIndex - 1];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            renderPipeId: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
      }
      execute(instruction) {
        const renderer = this._renderer;
        renderer.colorMask.setMask(instruction.colorMask);
      }
      destroy() {
        this._renderer = null;
        this._colorStack = null;
      }
    };
    ColorMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "colorMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
var StencilMaskPipe;
var init_StencilMaskPipe = __esm({
  "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
    init_Extensions();
    init_const7();
    init_const3();
    StencilMaskPipe = class {
      constructor(renderer) {
        this._maskStackHash = {};
        this._maskHash = /* @__PURE__ */ new WeakMap();
        this._renderer = renderer;
      }
      push(mask, _container, instructionSet) {
        var _a;
        const effect = mask;
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "pushMaskBegin",
          mask,
          inverse: _container._maskOptions.inverse,
          canBundle: false
        });
        const maskContainer = effect.mask;
        maskContainer.includeInBuild = true;
        if (!this._maskHash.has(effect)) {
          this._maskHash.set(effect, {
            instructionsStart: 0,
            instructionsLength: 0
          });
        }
        const maskData = this._maskHash.get(effect);
        maskData.instructionsStart = instructionSet.instructionSize;
        maskContainer.collectRenderables(
          instructionSet,
          renderer,
          null
        );
        maskContainer.includeInBuild = false;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "pushMaskEnd",
          mask,
          inverse: _container._maskOptions.inverse,
          canBundle: false
        });
        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
        maskData.instructionsLength = instructionsLength;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
      }
      pop(mask, _container, instructionSet) {
        const effect = mask;
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "popMaskBegin",
          inverse: _container._maskOptions.inverse,
          canBundle: false
        });
        const maskData = this._maskHash.get(mask);
        for (let i2 = 0; i2 < maskData.instructionsLength; i2++) {
          instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
        }
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "popMaskEnd",
          canBundle: false
        });
      }
      execute(instruction) {
        var _a;
        const renderer = this._renderer;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
        if (instruction.action === "pushMaskBegin") {
          renderer.renderTarget.ensureDepthStencil();
          renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
          maskStackIndex++;
          renderer.colorMask.setMask(0);
        } else if (instruction.action === "pushMaskEnd") {
          if (instruction.inverse) {
            renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
          } else {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          }
          renderer.colorMask.setMask(15);
        } else if (instruction.action === "popMaskBegin") {
          renderer.colorMask.setMask(0);
          if (maskStackIndex !== 0) {
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
          } else {
            renderer.renderTarget.clear(null, CLEAR.STENCIL);
            renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
          }
          maskStackIndex--;
        } else if (instruction.action === "popMaskEnd") {
          if (instruction.inverse) {
            renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
          } else {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          }
          renderer.colorMask.setMask(15);
        }
        this._maskStackHash[renderTargetUid] = maskStackIndex;
      }
      destroy() {
        this._renderer = null;
        this._maskStackHash = null;
        this._maskHash = null;
      }
    };
    StencilMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "stencilMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
var _BackgroundSystem, BackgroundSystem;
var init_BackgroundSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
    init_Color();
    init_Extensions();
    init_warn();
    _BackgroundSystem = class _BackgroundSystem2 {
      constructor() {
        this.clearBeforeRender = true;
        this._backgroundColor = new Color(0);
        this.color = this._backgroundColor;
        this.alpha = 1;
      }
      /**
       * initiates the background system
       * @param options - the options for the background colors
       */
      init(options) {
        options = { ..._BackgroundSystem2.defaultOptions, ...options };
        this.clearBeforeRender = options.clearBeforeRender;
        this.color = options.background || options.backgroundColor || this._backgroundColor;
        this.alpha = options.backgroundAlpha;
        this._backgroundColor.setAlpha(options.backgroundAlpha);
      }
      /** The background color to fill if not transparent */
      get color() {
        return this._backgroundColor;
      }
      set color(value) {
        const incoming = Color.shared.setValue(value);
        if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {
          warn(
            "Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application."
          );
        }
        this._backgroundColor.setValue(value);
      }
      /** The background color alpha. Setting this to 0 will make the canvas transparent. */
      get alpha() {
        return this._backgroundColor.alpha;
      }
      set alpha(value) {
        this._backgroundColor.setAlpha(value);
      }
      /** The background color as an [R, G, B, A] array. */
      get colorRgba() {
        return this._backgroundColor.toArray();
      }
      /**
       * destroys the background system
       * @internal
       */
      destroy() {
      }
    };
    _BackgroundSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "background",
      priority: 0
    };
    _BackgroundSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.backgroundAlpha}
       * @default 1
       */
      backgroundAlpha: 1,
      /**
       * {@link WebGLOptions.backgroundColor}
       * @default 0x000000
       */
      backgroundColor: 0,
      /**
       * {@link WebGLOptions.clearBeforeRender}
       * @default true
       */
      clearBeforeRender: true
    };
    BackgroundSystem = _BackgroundSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
var BLEND_MODE_FILTERS, BlendModePipe;
var init_BlendModePipe = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
    init_Extensions();
    init_FilterEffect();
    init_RenderGroup();
    init_warn();
    BLEND_MODE_FILTERS = {};
    extensions.handle(ExtensionType.BlendMode, (value) => {
      if (!value.name) {
        throw new Error("BlendMode extension must have a name property");
      }
      BLEND_MODE_FILTERS[value.name] = value.ref;
    }, (value) => {
      delete BLEND_MODE_FILTERS[value.name];
    });
    BlendModePipe = class {
      constructor(renderer) {
        this._blendModeStack = [];
        this._isAdvanced = false;
        this._filterHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        this._renderer.runners.prerender.add(this);
      }
      prerender() {
        this._activeBlendMode = "normal";
        this._isAdvanced = false;
      }
      /**
       * Push a blend mode onto the internal stack and apply it to the instruction set if needed.
       * @param renderable - The renderable or {@link RenderGroup} associated with the change.
       * @param blendMode - The blend mode to activate.
       * @param instructionSet - The instruction set being built.
       */
      pushBlendMode(renderable, blendMode, instructionSet) {
        this._blendModeStack.push(blendMode);
        this.setBlendMode(renderable, blendMode, instructionSet);
      }
      /**
       * Pop the last blend mode from the stack and apply the new top-of-stack mode.
       * @param instructionSet - The instruction set being built.
       */
      popBlendMode(instructionSet) {
        this._blendModeStack.pop();
        const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? "normal";
        this.setBlendMode(null, blendMode, instructionSet);
      }
      /**
       * Ensure a blend mode switch is added to the instruction set when the mode changes.
       * If an advanced blend mode is active, subsequent renderables will be collected so they can be
       * rendered within a single filter pass.
       * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.
       * @param blendMode - The target blend mode.
       * @param instructionSet - The instruction set being built.
       */
      setBlendMode(renderable, blendMode, instructionSet) {
        const isRenderGroup = renderable instanceof RenderGroup;
        if (this._activeBlendMode === blendMode) {
          if (this._isAdvanced && renderable && !isRenderGroup) {
            this._renderableList?.push(renderable);
          }
          return;
        }
        if (this._isAdvanced)
          this._endAdvancedBlendMode(instructionSet);
        this._activeBlendMode = blendMode;
        if (!renderable)
          return;
        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
        if (this._isAdvanced)
          this._beginAdvancedBlendMode(renderable, instructionSet);
      }
      _beginAdvancedBlendMode(renderable, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        const blendMode = this._activeBlendMode;
        if (!BLEND_MODE_FILTERS[blendMode]) {
          warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
          return;
        }
        const filterEffect = this._ensureFilterEffect(blendMode);
        const isRenderGroup = renderable instanceof RenderGroup;
        const instruction = {
          renderPipeId: "filter",
          action: "pushFilter",
          filterEffect,
          renderables: isRenderGroup ? null : [renderable],
          container: isRenderGroup ? renderable.root : null,
          canBundle: false
        };
        this._renderableList = instruction.renderables;
        instructionSet.add(instruction);
      }
      _ensureFilterEffect(blendMode) {
        let filterEffect = this._filterHash[blendMode];
        if (!filterEffect) {
          filterEffect = this._filterHash[blendMode] = new FilterEffect();
          filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
        }
        return filterEffect;
      }
      _endAdvancedBlendMode(instructionSet) {
        this._isAdvanced = false;
        this._renderableList = null;
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      /**
       * called when the instruction build process is starting this will reset internally to the default blend mode
       * @internal
       */
      buildStart() {
        this._isAdvanced = false;
      }
      /**
       * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
       * active, we add the final render instructions added to the instruction set
       * @param instructionSet - The instruction set we are adding to
       * @internal
       */
      buildEnd(instructionSet) {
        if (!this._isAdvanced)
          return;
        this._endAdvancedBlendMode(instructionSet);
      }
      /** @internal */
      destroy() {
        this._renderer = null;
        this._renderableList = null;
        for (const i2 in this._filterHash) {
          this._filterHash[i2].destroy();
        }
        this._filterHash = null;
      }
    };
    BlendModePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "blendMode"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
var imageTypes, _ExtractSystem, ExtractSystem;
var init_ExtractSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
    init_adapter();
    init_Extensions();
    init_Container();
    init_Texture();
    imageTypes = {
      png: "image/png",
      jpg: "image/jpeg",
      webp: "image/webp"
    };
    _ExtractSystem = class _ExtractSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
      }
      _normalizeOptions(options, defaults = {}) {
        if (options instanceof Container || options instanceof Texture) {
          return {
            target: options,
            ...defaults
          };
        }
        return {
          ...defaults,
          ...options
        };
      }
      /**
       * Creates an IImage from a display object or texture.
       * @param options - Options for creating the image, or the target to extract
       * @returns Promise that resolves with the generated IImage
       * @example
       * ```ts
       * // Basic usage with a sprite
       * const sprite = new Sprite(texture);
       * const image = await renderer.extract.image(sprite);
       * document.body.appendChild(image);
       *
       * // Advanced usage with options
       * const image = await renderer.extract.image({
       *     target: container,
       *     format: 'webp',
       *     quality: 0.8,
       *     frame: new Rectangle(0, 0, 100, 100),
       *     resolution: 2,
       *     clearColor: '#ff0000',
       *     antialias: true
       * });
       *
       * // Extract directly from a texture
       * const texture = Texture.from('myTexture.png');
       * const image = await renderer.extract.image(texture);
       * ```
       * @see {@link ExtractImageOptions} For detailed options
       * @see {@link ExtractSystem.base64} For base64 string output
       * @see {@link ExtractSystem.canvas} For canvas output
       * @see {@link ImageLike} For the image interface
       * @category rendering
       */
      async image(options) {
        const image = DOMAdapter.get().createImage();
        image.src = await this.base64(options);
        return image;
      }
      /**
       * Converts the target into a base64 encoded string.
       *
       * This method works by first creating
       * a canvas using `Extract.canvas` and then converting it to a base64 string.
       * @param options - The options for creating the base64 string, or the target to extract
       * @returns Promise that resolves with the base64 encoded string
       * @example
       * ```ts
       * // Basic usage with a sprite
       * const sprite = new Sprite(texture);
       * const base64 = await renderer.extract.base64(sprite);
       * console.log(base64); // data:image/png;base64,...
       *
       * // Advanced usage with options
       * const base64 = await renderer.extract.base64({
       *     target: container,
       *     format: 'webp',
       *     quality: 0.8,
       *     frame: new Rectangle(0, 0, 100, 100),
       *     resolution: 2
       * });
       * ```
       * @throws Will throw an error if the platform doesn't support any of:
       * - ICanvas.toDataURL
       * - ICanvas.toBlob
       * - ICanvas.convertToBlob
       * @see {@link ExtractImageOptions} For detailed options
       * @see {@link ExtractSystem.canvas} For canvas output
       * @see {@link ExtractSystem.image} For HTMLImage output
       * @category rendering
       */
      async base64(options) {
        options = this._normalizeOptions(
          options,
          _ExtractSystem2.defaultImageOptions
        );
        const { format, quality } = options;
        const canvas = this.canvas(options);
        if (canvas.toBlob !== void 0) {
          return new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
              if (!blob) {
                reject(new Error("ICanvas.toBlob failed!"));
                return;
              }
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            }, imageTypes[format], quality);
          });
        }
        if (canvas.toDataURL !== void 0) {
          return canvas.toDataURL(imageTypes[format], quality);
        }
        if (canvas.convertToBlob !== void 0) {
          const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
      }
      /**
       * Creates a Canvas element, renders the target to it and returns it.
       * This method is useful for creating static images or when you need direct canvas access.
       * @param options - The options for creating the canvas, or the target to extract
       * @returns A Canvas element with the texture rendered on
       * @example
       * ```ts
       * // Basic canvas extraction from a sprite
       * const sprite = new Sprite(texture);
       * const canvas = renderer.extract.canvas(sprite);
       * document.body.appendChild(canvas);
       *
       * // Extract with custom region
       * const canvas = renderer.extract.canvas({
       *     target: container,
       *     frame: new Rectangle(0, 0, 100, 100)
       * });
       *
       * // Extract with high resolution
       * const canvas = renderer.extract.canvas({
       *     target: sprite,
       *     resolution: 2,
       *     clearColor: '#ff0000'
       * });
       *
       * // Extract directly from a texture
       * const texture = Texture.from('myTexture.png');
       * const canvas = renderer.extract.canvas(texture);
       *
       * // Extract with anti-aliasing
       * const canvas = renderer.extract.canvas({
       *     target: graphics,
       *     antialias: true
       * });
       * ```
       * @see {@link ExtractOptions} For detailed options
       * @see {@link ExtractSystem.image} For HTMLImage output
       * @see {@link ExtractSystem.pixels} For raw pixel data
       * @category rendering
       */
      canvas(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        if (target instanceof Texture) {
          return renderer.texture.generateCanvas(target);
        }
        const texture = renderer.textureGenerator.generateTexture(options);
        const canvas = renderer.texture.generateCanvas(texture);
        texture.destroy(true);
        return canvas;
      }
      /**
       * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,
       * with integer values between 0 and 255 (inclusive).
       * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA
       * @param options - The options for extracting the image, or the target to extract
       * @returns One-dimensional Uint8Array containing the pixel data in RGBA format
       * @example
       * ```ts
       * // Basic pixel extraction
       * const sprite = new Sprite(texture);
       * const pixels = renderer.extract.pixels(sprite);
       * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values
       *
       * // Extract with custom region
       * const pixels = renderer.extract.pixels({
       *     target: sprite,
       *     frame: new Rectangle(0, 0, 100, 100)
       * });
       *
       * // Extract with high resolution
       * const pixels = renderer.extract.pixels({
       *     target: sprite,
       *     resolution: 2
       * });
       * ```
       * @see {@link ExtractOptions} For detailed options
       * @see {@link ExtractSystem.canvas} For canvas output
       * @see {@link ExtractSystem.image} For image output
       * @category rendering
       */
      pixels(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
        const pixelInfo = renderer.texture.getPixels(texture);
        if (target instanceof Container) {
          texture.destroy(true);
        }
        return pixelInfo;
      }
      /**
       * Creates a texture from a display object or existing texture.
       *
       * This is useful for creating
       * reusable textures from rendered content or making copies of existing textures.
       * > [!NOTE] The returned texture should be destroyed when no longer needed
       * @param options - The options for creating the texture, or the target to extract
       * @returns A new texture containing the extracted content
       * @example
       * ```ts
       * // Basic texture extraction from a sprite
       * const sprite = new Sprite(texture);
       * const extractedTexture = renderer.extract.texture(sprite);
       *
       * // Extract with custom region
       * const regionTexture = renderer.extract.texture({
       *     target: container,
       *     frame: new Rectangle(0, 0, 100, 100)
       * });
       *
       * // Extract with high resolution
       * const hiResTexture = renderer.extract.texture({
       *     target: sprite,
       *     resolution: 2,
       *     clearColor: '#ff0000'
       * });
       *
       * // Create a new sprite from extracted texture
       * const newSprite = new Sprite(
       *     renderer.extract.texture({
       *         target: graphics,
       *         antialias: true
       *     })
       * );
       *
       * // Clean up when done
       * extractedTexture.destroy(true);
       * ```
       * @see {@link ExtractOptions} For detailed options
       * @see {@link Texture} For texture management
       * @see {@link GenerateTextureSystem} For texture generation
       * @category rendering
       */
      texture(options) {
        options = this._normalizeOptions(options);
        if (options.target instanceof Texture)
          return options.target;
        return this._renderer.textureGenerator.generateTexture(options);
      }
      /**
       * Extracts and downloads content from the renderer as an image file.
       * This is a convenient way to save screenshots or export rendered content.
       * > [!NOTE] The download will use PNG format regardless of the filename extension
       * @param options - The options for downloading and extracting the image, or the target to extract
       * @example
       * ```ts
       * // Basic download with default filename
       * const sprite = new Sprite(texture);
       * renderer.extract.download(sprite); // Downloads as 'image.png'
       *
       * // Download with custom filename
       * renderer.extract.download({
       *     target: sprite,
       *     filename: 'screenshot.png'
       * });
       *
       * // Download with custom region
       * renderer.extract.download({
       *     target: container,
       *     filename: 'region.png',
       *     frame: new Rectangle(0, 0, 100, 100)
       * });
       *
       * // Download with high resolution and background
       * renderer.extract.download({
       *     target: stage,
       *     filename: 'hd-screenshot.png',
       *     resolution: 2,
       *     clearColor: '#ff0000'
       * });
       *
       * // Download with anti-aliasing
       * renderer.extract.download({
       *     target: graphics,
       *     filename: 'smooth.png',
       *     antialias: true
       * });
       * ```
       * @see {@link ExtractDownloadOptions} For detailed options
       * @see {@link ExtractSystem.image} For creating images without download
       * @see {@link ExtractSystem.canvas} For canvas output
       * @category rendering
       */
      download(options) {
        options = this._normalizeOptions(options);
        const canvas = this.canvas(options);
        const link = document.createElement("a");
        link.download = options.filename ?? "image.png";
        link.href = canvas.toDataURL("image/png");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      /**
       * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
       * The image will be displayed in the browser's console using CSS background images.
       * @param options - The options for logging the image, or the target to log
       * @param options.width - The width of the logged image preview in the console (in pixels)
       * @example
       * ```ts
       * // Basic usage
       * const sprite = new Sprite(texture);
       * renderer.extract.log(sprite);
       * ```
       * @see {@link ExtractSystem.canvas} For getting raw canvas output
       * @see {@link ExtractSystem.pixels} For raw pixel data
       * @category rendering
       * @advanced
       */
      log(options) {
        const width = options.width ?? 200;
        options = this._normalizeOptions(options);
        const canvas = this.canvas(options);
        const base64 = canvas.toDataURL();
        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
        const style = [
          "font-size: 1px;",
          `padding: ${width}px ${300}px;`,
          `background: url(${base64}) no-repeat;`,
          "background-size: contain;"
        ].join(" ");
        console.log("%c ", style);
      }
      destroy() {
        this._renderer = null;
      }
    };
    _ExtractSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "extract"
    };
    _ExtractSystem.defaultImageOptions = {
      format: "png",
      quality: 1
    };
    ExtractSystem = _ExtractSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
var RenderTexture;
var init_RenderTexture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
    init_TextureSource();
    init_Texture();
    RenderTexture = class _RenderTexture extends Texture {
      static create(options) {
        return new _RenderTexture({
          source: new TextureSource(options)
        });
      }
      /**
       * Resizes the render texture.
       * @param width - The new width of the render texture.
       * @param height - The new height of the render texture.
       * @param resolution - The new resolution of the render texture.
       * @returns This texture.
       */
      resize(width, height, resolution) {
        this.source.resize(width, height, resolution);
        return this;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
var tempRect5, tempBounds4, noColor, GenerateTextureSystem;
var init_GenerateTextureSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
    init_Color();
    init_Extensions();
    init_Matrix();
    init_Rectangle();
    init_Bounds();
    init_getLocalBounds();
    init_Container();
    init_RenderTexture();
    tempRect5 = new Rectangle();
    tempBounds4 = new Bounds();
    noColor = [0, 0, 0, 0];
    GenerateTextureSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * Creates a texture from a display object that can be used for creating sprites and other textures.
       * This is particularly useful for optimizing performance when a complex container needs to be reused.
       * @param options - Generate texture options or a container to convert to texture
       * @returns A new RenderTexture containing the rendered display object
       * @example
       * ```ts
       * // Basic usage with a container
       * const container = new Container();
       * container.addChild(
       *     new Graphics()
       *         .circle(0, 0, 50)
       *         .fill('red')
       * );
       *
       * const texture = renderer.textureGenerator.generateTexture(container);
       *
       * // Advanced usage with options
       * const texture = renderer.textureGenerator.generateTexture({
       *     target: container,
       *     frame: new Rectangle(0, 0, 100, 100), // Specific region
       *     resolution: 2,                        // High DPI
       *     clearColor: '#ff0000',               // Red background
       *     antialias: true                      // Smooth edges
       * });
       *
       * // Create a sprite from the generated texture
       * const sprite = new Sprite(texture);
       *
       * // Clean up when done
       * texture.destroy(true);
       * ```
       * @see {@link GenerateTextureOptions} For detailed texture generation options
       * @see {@link RenderTexture} For the type of texture created
       * @category rendering
       */
      generateTexture(options) {
        if (options instanceof Container) {
          options = {
            target: options,
            frame: void 0,
            textureSourceOptions: {},
            resolution: void 0
          };
        }
        const resolution = options.resolution || this._renderer.resolution;
        const antialias = options.antialias || this._renderer.view.antialias;
        const container = options.target;
        let clearColor = options.clearColor;
        if (clearColor) {
          const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
          clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
        } else {
          clearColor = noColor;
        }
        const region = options.frame?.copyTo(tempRect5) || getLocalBounds(container, tempBounds4).rectangle;
        region.width = Math.max(region.width, 1 / resolution) | 0;
        region.height = Math.max(region.height, 1 / resolution) | 0;
        const target = RenderTexture.create({
          ...options.textureSourceOptions,
          width: region.width,
          height: region.height,
          resolution,
          antialias
        });
        const transform = Matrix.shared.translate(-region.x, -region.y);
        this._renderer.render({
          container,
          transform,
          target,
          clearColor
        });
        target.source.updateMipmaps();
        return target;
      }
      destroy() {
        this._renderer = null;
      }
    };
    GenerateTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGenerator"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
var GlobalUniformSystem;
var init_GlobalUniformSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Point();
    init_colorToUniform();
    init_BindGroup();
    init_types2();
    init_UniformGroup();
    GlobalUniformSystem = class {
      constructor(renderer) {
        this._stackIndex = 0;
        this._globalUniformDataStack = [];
        this._uniformsPool = [];
        this._activeUniforms = [];
        this._bindGroupPool = [];
        this._activeBindGroups = [];
        this._renderer = renderer;
      }
      reset() {
        this._stackIndex = 0;
        for (let i2 = 0; i2 < this._activeUniforms.length; i2++) {
          this._uniformsPool.push(this._activeUniforms[i2]);
        }
        for (let i2 = 0; i2 < this._activeBindGroups.length; i2++) {
          this._bindGroupPool.push(this._activeBindGroups[i2]);
        }
        this._activeUniforms.length = 0;
        this._activeBindGroups.length = 0;
      }
      start(options) {
        this.reset();
        this.push(options);
      }
      bind({
        size,
        projectionMatrix,
        worldTransformMatrix,
        worldColor,
        offset
      }) {
        const renderTarget = this._renderer.renderTarget.renderTarget;
        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
          projectionData: renderTarget,
          worldTransformMatrix: new Matrix(),
          worldColor: 4294967295,
          offset: new Point()
        };
        const globalUniformData = {
          projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
          resolution: size || renderTarget.size,
          worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
          worldColor: worldColor || currentGlobalUniformData.worldColor,
          offset: offset || currentGlobalUniformData.offset,
          bindGroup: null
        };
        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
        this._activeUniforms.push(uniformGroup);
        const uniforms = uniformGroup.uniforms;
        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
        uniforms.uResolution = globalUniformData.resolution;
        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
        color32BitToUniform(
          globalUniformData.worldColor,
          uniforms.uWorldColorAlpha,
          0
        );
        uniformGroup.update();
        let bindGroup;
        if (this._renderer.renderPipes.uniformBatch) {
          bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
        } else {
          bindGroup = this._bindGroupPool.pop() || new BindGroup();
          this._activeBindGroups.push(bindGroup);
          bindGroup.setResource(uniformGroup, 0);
        }
        globalUniformData.bindGroup = bindGroup;
        this._currentGlobalUniformData = globalUniformData;
      }
      push(options) {
        this.bind(options);
        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
      }
      pop() {
        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
        if (this._renderer.type === RendererType.WEBGL) {
          this._currentGlobalUniformData.bindGroup.resources[0].update();
        }
      }
      get bindGroup() {
        return this._currentGlobalUniformData.bindGroup;
      }
      get globalUniformData() {
        return this._currentGlobalUniformData;
      }
      get uniformGroup() {
        return this._currentGlobalUniformData.bindGroup.resources[0];
      }
      _createUniforms() {
        const globalUniforms = new UniformGroup({
          uProjectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uWorldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
          uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
          uResolution: { value: [0, 0], type: "vec2<f32>" }
        }, {
          isStatic: true
        });
        return globalUniforms;
      }
      destroy() {
        this._renderer = null;
        this._globalUniformDataStack.length = 0;
        this._uniformsPool.length = 0;
        this._activeUniforms.length = 0;
        this._bindGroupPool.length = 0;
        this._activeBindGroups.length = 0;
        this._currentGlobalUniformData = null;
      }
    };
    GlobalUniformSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "globalUniforms"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs
var uid2, SchedulerSystem;
var init_SchedulerSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs"() {
    init_Extensions();
    init_Ticker();
    uid2 = 1;
    SchedulerSystem = class {
      constructor() {
        this._tasks = [];
        this._offset = 0;
      }
      /** Initializes the scheduler system and starts the ticker. */
      init() {
        Ticker.system.add(this._update, this);
      }
      /**
       * Schedules a repeating task.
       * @param func - The function to execute.
       * @param duration - The interval duration in milliseconds.
       * @param useOffset - this will spread out tasks so that they do not all run at the same time
       * @returns The unique identifier for the scheduled task.
       */
      repeat(func, duration, useOffset = true) {
        const id = uid2++;
        let offset = 0;
        if (useOffset) {
          this._offset += 1e3;
          offset = this._offset;
        }
        this._tasks.push({
          func,
          duration,
          start: performance.now(),
          offset,
          last: performance.now(),
          repeat: true,
          id
        });
        return id;
      }
      /**
       * Cancels a scheduled task.
       * @param id - The unique identifier of the task to cancel.
       */
      cancel(id) {
        for (let i2 = 0; i2 < this._tasks.length; i2++) {
          if (this._tasks[i2].id === id) {
            this._tasks.splice(i2, 1);
            return;
          }
        }
      }
      /**
       * Updates and executes the scheduled tasks.
       * @private
       */
      _update() {
        const now = performance.now();
        for (let i2 = 0; i2 < this._tasks.length; i2++) {
          const task = this._tasks[i2];
          if (now - task.offset - task.last >= task.duration) {
            const elapsed = now - task.start;
            task.func(elapsed);
            task.last = now;
          }
        }
      }
      /**
       * Destroys the scheduler system and removes all tasks.
       * @internal
       */
      destroy() {
        Ticker.system.remove(this._update, this);
        this._tasks.length = 0;
      }
    };
    SchedulerSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "scheduler",
      priority: 0
    };
  }
});

// node_modules/pixi.js/lib/utils/sayHello.mjs
function sayHello(type) {
  if (saidHello) {
    return;
  }
  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    const args = [
      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
      "background: #E72264; padding:5px 0;",
      "background: #6CA2EA; padding:5px 0;",
      "background: #B5D33D; padding:5px 0;",
      "background: #FED23F; padding:5px 0;",
      "color: #FFFFFF; background: #E72264; padding:5px 0;",
      "color: #E72264; background: #FFFFFF; padding:5px 0;"
    ];
    globalThis.console.log(...args);
  } else if (globalThis.console) {
    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
  }
  saidHello = true;
}
var saidHello;
var init_sayHello = __esm({
  "node_modules/pixi.js/lib/utils/sayHello.mjs"() {
    init_adapter();
    init_const8();
    saidHello = false;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
var HelloSystem;
var init_HelloSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
    init_Extensions();
    init_sayHello();
    init_types2();
    HelloSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * It all starts here! This initiates every system, passing in the options for any system by name.
       * @param options - the config for the renderer and all its systems
       */
      init(options) {
        if (options.hello) {
          let name = this._renderer.name;
          if (this._renderer.type === RendererType.WEBGL) {
            name += ` ${this._renderer.context.webGLVersion}`;
          }
          sayHello(name);
        }
      }
    };
    HelloSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "hello",
      priority: -2
    };
    HelloSystem.defaultOptions = {
      /** {@link WebGLOptions.hello} */
      hello: false
    };
  }
});

// node_modules/pixi.js/lib/utils/data/clean.mjs
function cleanHash(hash) {
  let clean = false;
  for (const i2 in hash) {
    if (hash[i2] == void 0) {
      clean = true;
      break;
    }
  }
  if (!clean)
    return hash;
  const cleanHash2 = /* @__PURE__ */ Object.create(null);
  for (const i2 in hash) {
    const value = hash[i2];
    if (value) {
      cleanHash2[i2] = value;
    }
  }
  return cleanHash2;
}
function cleanArray(arr) {
  let offset = 0;
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2] == void 0) {
      offset++;
    } else {
      arr[i2 - offset] = arr[i2];
    }
  }
  arr.length -= offset;
  return arr;
}
var init_clean = __esm({
  "node_modules/pixi.js/lib/utils/data/clean.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs
var renderableGCTick, _RenderableGCSystem, RenderableGCSystem;
var init_RenderableGCSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs"() {
    init_Extensions();
    init_clean();
    renderableGCTick = 0;
    _RenderableGCSystem = class _RenderableGCSystem2 {
      /**
       * Creates a new RenderableGCSystem instance.
       * @param renderer - The renderer this garbage collection system works for
       */
      constructor(renderer) {
        this._managedRenderables = [];
        this._managedHashes = [];
        this._managedArrays = [];
        this._renderer = renderer;
      }
      /**
       * Initializes the garbage collection system with the provided options.
       * @param options - Configuration options for the renderer
       */
      init(options) {
        options = { ..._RenderableGCSystem2.defaultOptions, ...options };
        this.maxUnusedTime = options.renderableGCMaxUnusedTime;
        this._frequency = options.renderableGCFrequency;
        this.enabled = options.renderableGCActive;
      }
      /**
       * Gets whether the garbage collection system is currently enabled.
       * @returns True if GC is enabled, false otherwise
       */
      get enabled() {
        return !!this._handler;
      }
      /**
       * Enables or disables the garbage collection system.
       * When enabled, schedules periodic cleanup of resources.
       * When disabled, cancels all scheduled cleanups.
       */
      set enabled(value) {
        if (this.enabled === value)
          return;
        if (value) {
          this._handler = this._renderer.scheduler.repeat(
            () => this.run(),
            this._frequency,
            false
          );
          this._hashHandler = this._renderer.scheduler.repeat(
            () => {
              for (const hash of this._managedHashes) {
                hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);
              }
            },
            this._frequency
          );
          this._arrayHandler = this._renderer.scheduler.repeat(
            () => {
              for (const array of this._managedArrays) {
                cleanArray(array.context[array.hash]);
              }
            },
            this._frequency
          );
        } else {
          this._renderer.scheduler.cancel(this._handler);
          this._renderer.scheduler.cancel(this._hashHandler);
          this._renderer.scheduler.cancel(this._arrayHandler);
        }
      }
      /**
       * Adds a hash table to be managed by the garbage collector.
       * @param context - The object containing the hash table
       * @param hash - The property name of the hash table
       */
      addManagedHash(context2, hash) {
        this._managedHashes.push({ context: context2, hash });
      }
      /**
       * Adds an array to be managed by the garbage collector.
       * @param context - The object containing the array
       * @param hash - The property name of the array
       */
      addManagedArray(context2, hash) {
        this._managedArrays.push({ context: context2, hash });
      }
      /**
       * Updates the GC timestamp and tracking before rendering.
       * @param options - The render options
       * @param options.container - The container to render
       */
      prerender({
        container
      }) {
        this._now = performance.now();
        container.renderGroup.gcTick = renderableGCTick++;
        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);
      }
      /**
       * Starts tracking a renderable for garbage collection.
       * @param renderable - The renderable to track
       */
      addRenderable(renderable) {
        if (!this.enabled)
          return;
        if (renderable._lastUsed === -1) {
          this._managedRenderables.push(renderable);
          renderable.once("destroyed", this._removeRenderable, this);
        }
        renderable._lastUsed = this._now;
      }
      /**
       * Performs garbage collection by cleaning up unused renderables.
       * Removes renderables that haven't been used for longer than maxUnusedTime.
       */
      run() {
        const now = this._now;
        const managedRenderables = this._managedRenderables;
        const renderPipes3 = this._renderer.renderPipes;
        let offset = 0;
        for (let i2 = 0; i2 < managedRenderables.length; i2++) {
          const renderable = managedRenderables[i2];
          if (renderable === null) {
            offset++;
            continue;
          }
          const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
          const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;
          if ((renderGroup?.gcTick ?? 0) === currentTick) {
            renderable._lastUsed = now;
          }
          if (now - renderable._lastUsed > this.maxUnusedTime) {
            if (!renderable.destroyed) {
              const rp = renderPipes3;
              if (renderGroup)
                renderGroup.structureDidChange = true;
              rp[renderable.renderPipeId].destroyRenderable(renderable);
            }
            renderable._lastUsed = -1;
            offset++;
            renderable.off("destroyed", this._removeRenderable, this);
          } else {
            managedRenderables[i2 - offset] = renderable;
          }
        }
        managedRenderables.length -= offset;
      }
      /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */
      destroy() {
        this.enabled = false;
        this._renderer = null;
        this._managedRenderables.length = 0;
        this._managedHashes.length = 0;
        this._managedArrays.length = 0;
      }
      /**
       * Removes a renderable from being tracked when it's destroyed.
       * @param renderable - The renderable to stop tracking
       */
      _removeRenderable(renderable) {
        const index = this._managedRenderables.indexOf(renderable);
        if (index >= 0) {
          renderable.off("destroyed", this._removeRenderable, this);
          this._managedRenderables[index] = null;
        }
      }
      /**
       * Updates the GC tick counter for a render group and its children.
       * @param renderGroup - The render group to update
       * @param gcTick - The new tick value
       */
      _updateInstructionGCTick(renderGroup, gcTick) {
        renderGroup.instructionSet.gcTick = gcTick;
        for (const child of renderGroup.renderGroupChildren) {
          this._updateInstructionGCTick(child, gcTick);
        }
      }
    };
    _RenderableGCSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "renderableGC",
      priority: 0
    };
    _RenderableGCSystem.defaultOptions = {
      /** Enable/disable the garbage collector */
      renderableGCActive: true,
      /** Time in ms before an unused resource is collected (default 1 minute) */
      renderableGCMaxUnusedTime: 6e4,
      /** How often to run garbage collection in ms (default 30 seconds) */
      renderableGCFrequency: 3e4
    };
    RenderableGCSystem = _RenderableGCSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
var _TextureGCSystem, TextureGCSystem;
var init_TextureGCSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
    init_Extensions();
    _TextureGCSystem = class _TextureGCSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
        this.count = 0;
        this.checkCount = 0;
      }
      init(options) {
        options = { ..._TextureGCSystem2.defaultOptions, ...options };
        this.checkCountMax = options.textureGCCheckCountMax;
        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;
        this.active = options.textureGCActive;
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      postrender() {
        if (!this._renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (!this.active)
          return;
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      run() {
        const managedTextures = this._renderer.texture.managedTextures;
        for (let i2 = 0; i2 < managedTextures.length; i2++) {
          const texture = managedTextures[i2];
          if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
            texture._touched = -1;
            texture.unload();
          }
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    _TextureGCSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGC"
    };
    _TextureGCSystem.defaultOptions = {
      /**
       * If set to true, this will enable the garbage collector on the GPU.
       * @default true
       */
      textureGCActive: true,
      /**
       * @deprecated since 8.3.0
       * @see {@link TextureGCSystemOptions.textureGCMaxIdle}
       */
      textureGCAMaxIdle: null,
      /**
       * The maximum idle frames before a texture is destroyed by garbage collection.
       * @default 60 * 60
       */
      textureGCMaxIdle: 60 * 60,
      /**
       * Frames between two garbage collections.
       * @default 600
       */
      textureGCCheckCountMax: 600
    };
    TextureGCSystem = _TextureGCSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
var _RenderTarget, RenderTarget;
var init_RenderTarget = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
    init_uid();
    init_TextureSource();
    init_Texture();
    _RenderTarget = class _RenderTarget2 {
      /**
       * @param [descriptor] - Options for creating a render target.
       */
      constructor(descriptor = {}) {
        this.uid = uid("renderTarget");
        this.colorTextures = [];
        this.dirtyId = 0;
        this.isRoot = false;
        this._size = new Float32Array(2);
        this._managedColorTextures = false;
        descriptor = { ..._RenderTarget2.defaultOptions, ...descriptor };
        this.stencil = descriptor.stencil;
        this.depth = descriptor.depth;
        this.isRoot = descriptor.isRoot;
        if (typeof descriptor.colorTextures === "number") {
          this._managedColorTextures = true;
          for (let i2 = 0; i2 < descriptor.colorTextures; i2++) {
            this.colorTextures.push(
              new TextureSource({
                width: descriptor.width,
                height: descriptor.height,
                resolution: descriptor.resolution,
                antialias: descriptor.antialias
              })
            );
          }
        } else {
          this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
          const colorSource = this.colorTexture.source;
          this.resize(colorSource.width, colorSource.height, colorSource._resolution);
        }
        this.colorTexture.source.on("resize", this.onSourceResize, this);
        if (descriptor.depthStencilTexture || this.stencil) {
          if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
            this.depthStencilTexture = descriptor.depthStencilTexture.source;
          } else {
            this.ensureDepthStencilTexture();
          }
        }
      }
      get size() {
        const _size = this._size;
        _size[0] = this.pixelWidth;
        _size[1] = this.pixelHeight;
        return _size;
      }
      get width() {
        return this.colorTexture.source.width;
      }
      get height() {
        return this.colorTexture.source.height;
      }
      get pixelWidth() {
        return this.colorTexture.source.pixelWidth;
      }
      get pixelHeight() {
        return this.colorTexture.source.pixelHeight;
      }
      get resolution() {
        return this.colorTexture.source._resolution;
      }
      get colorTexture() {
        return this.colorTextures[0];
      }
      onSourceResize(source3) {
        this.resize(source3.width, source3.height, source3._resolution, true);
      }
      /**
       * This will ensure a depthStencil texture is created for this render target.
       * Most likely called by the mask system to make sure we have stencil buffer added.
       * @internal
       */
      ensureDepthStencilTexture() {
        if (!this.depthStencilTexture) {
          this.depthStencilTexture = new TextureSource({
            width: this.width,
            height: this.height,
            resolution: this.resolution,
            format: "depth24plus-stencil8",
            autoGenerateMipmaps: false,
            antialias: false,
            mipLevelCount: 1
            // sampleCount: handled by the render target system..
          });
        }
      }
      resize(width, height, resolution = this.resolution, skipColorTexture = false) {
        this.dirtyId++;
        this.colorTextures.forEach((colorTexture, i2) => {
          if (skipColorTexture && i2 === 0)
            return;
          colorTexture.source.resize(width, height, resolution);
        });
        if (this.depthStencilTexture) {
          this.depthStencilTexture.source.resize(width, height, resolution);
        }
      }
      destroy() {
        this.colorTexture.source.off("resize", this.onSourceResize, this);
        if (this._managedColorTextures) {
          this.colorTextures.forEach((texture) => {
            texture.destroy();
          });
        }
        if (this.depthStencilTexture) {
          this.depthStencilTexture.destroy();
          delete this.depthStencilTexture;
        }
      }
    };
    _RenderTarget.defaultOptions = {
      /** the width of the RenderTarget */
      width: 0,
      /** the height of the RenderTarget */
      height: 0,
      /** the resolution of the RenderTarget */
      resolution: 1,
      /** an array of textures, or a number indicating how many color textures there should be */
      colorTextures: 1,
      /** should this render target have a stencil buffer? */
      stencil: false,
      /** should this render target have a depth buffer? */
      depth: false,
      /** should this render target be antialiased? */
      antialias: false,
      // save on perf by default!
      /** is this a root element, true if this is gl context owners render target */
      isRoot: false
    };
    RenderTarget = _RenderTarget;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
function getCanvasTexture(canvas, options) {
  if (!canvasCache.has(canvas)) {
    const texture = new Texture({
      source: new CanvasSource({
        resource: canvas,
        ...options
      })
    });
    const onDestroy = () => {
      if (canvasCache.get(canvas) === texture) {
        canvasCache.delete(canvas);
      }
    };
    texture.once("destroy", onDestroy);
    texture.source.once("destroy", onDestroy);
    canvasCache.set(canvas, texture);
  }
  return canvasCache.get(canvas);
}
var canvasCache;
var init_getCanvasTexture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
    init_GlobalResourceRegistry();
    init_CanvasSource();
    init_Texture();
    canvasCache = /* @__PURE__ */ new Map();
    GlobalResourceRegistry.register(canvasCache);
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
var _ViewSystem, ViewSystem;
var init_ViewSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
    init_adapter();
    init_Extensions();
    init_Rectangle();
    init_deprecation();
    init_RenderTarget();
    init_getCanvasTexture();
    _ViewSystem = class _ViewSystem2 {
      /**
       * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
       * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.
       * @type {boolean}
       */
      get autoDensity() {
        return this.texture.source.autoDensity;
      }
      set autoDensity(value) {
        this.texture.source.autoDensity = value;
      }
      /** The resolution / device pixel ratio of the renderer. */
      get resolution() {
        return this.texture.source._resolution;
      }
      set resolution(value) {
        this.texture.source.resize(
          this.texture.source.width,
          this.texture.source.height,
          value
        );
      }
      /**
       * initiates the view system
       * @param options - the options for the view
       */
      init(options) {
        options = {
          ..._ViewSystem2.defaultOptions,
          ...options
        };
        if (options.view) {
          deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
          options.canvas = options.view;
        }
        this.screen = new Rectangle(0, 0, options.width, options.height);
        this.canvas = options.canvas || DOMAdapter.get().createCanvas();
        this.antialias = !!options.antialias;
        this.texture = getCanvasTexture(this.canvas, options);
        this.renderTarget = new RenderTarget({
          colorTextures: [this.texture],
          depth: !!options.depth,
          isRoot: true
        });
        this.texture.source.transparent = options.backgroundAlpha < 1;
        this.resolution = options.resolution;
      }
      /**
       * Resizes the screen and canvas to the specified dimensions.
       * @param desiredScreenWidth - The new width of the screen.
       * @param desiredScreenHeight - The new height of the screen.
       * @param resolution
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        this.screen.width = this.texture.frame.width;
        this.screen.height = this.texture.frame.height;
      }
      /**
       * Destroys this System and optionally removes the canvas from the dom.
       * @param {options | false} options - The options for destroying the view, or "false".
       * @example
       * viewSystem.destroy();
       * viewSystem.destroy(true);
       * viewSystem.destroy({ removeView: true });
       */
      destroy(options = false) {
        const removeView = typeof options === "boolean" ? options : !!options?.removeView;
        if (removeView && this.canvas.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
        }
        this.texture.destroy();
      }
    };
    _ViewSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "view",
      priority: 0
    };
    _ViewSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.width}
       * @default 800
       */
      width: 800,
      /**
       * {@link WebGLOptions.height}
       * @default 600
       */
      height: 600,
      /**
       * {@link WebGLOptions.autoDensity}
       * @default false
       */
      autoDensity: false,
      /**
       * {@link WebGLOptions.antialias}
       * @default false
       */
      antialias: false
    };
    ViewSystem = _ViewSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
var SharedSystems, SharedRenderPipes;
var init_SharedSystems = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
    init_CustomRenderPipe();
    init_RenderGroupPipe();
    init_RenderGroupSystem();
    init_SpritePipe();
    init_globalHooks();
    init_BatcherPipe();
    init_AlphaMaskPipe();
    init_ColorMaskPipe();
    init_StencilMaskPipe();
    init_BackgroundSystem();
    init_BlendModePipe();
    init_ExtractSystem();
    init_GenerateTextureSystem();
    init_GlobalUniformSystem();
    init_SchedulerSystem();
    init_HelloSystem();
    init_RenderableGCSystem();
    init_TextureGCSystem();
    init_ViewSystem();
    SharedSystems = [
      BackgroundSystem,
      GlobalUniformSystem,
      HelloSystem,
      ViewSystem,
      RenderGroupSystem,
      TextureGCSystem,
      GenerateTextureSystem,
      ExtractSystem,
      RendererInitHook,
      RenderableGCSystem,
      SchedulerSystem
    ];
    SharedRenderPipes = [
      BlendModePipe,
      BatcherPipe,
      SpritePipe,
      RenderGroupPipe,
      AlphaMaskPipe,
      StencilMaskPipe,
      ColorMaskPipe,
      CustomRenderPipe
    ];
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
var BindGroupSystem;
var init_BindGroupSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
    init_Extensions();
    BindGroupSystem = class {
      constructor(renderer) {
        this._hash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_hash");
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getBindGroup(bindGroup, program, groupIndex) {
        bindGroup._updateKey();
        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
        return gpuBindGroup;
      }
      _createBindGroup(group, program, groupIndex) {
        const device = this._gpu.device;
        const groupLayout = program.layout[groupIndex];
        const entries = [];
        const renderer = this._renderer;
        for (const j2 in groupLayout) {
          const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
          let gpuResource;
          if (resource._resourceType === "uniformGroup") {
            const uniformGroup = resource;
            renderer.ubo.updateUniformGroup(uniformGroup);
            const buffer = uniformGroup.buffer;
            gpuResource = {
              buffer: renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource._resourceType === "buffer") {
            const buffer = resource;
            gpuResource = {
              buffer: renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource._resourceType === "bufferResource") {
            const bufferResource = resource;
            gpuResource = {
              buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
              offset: bufferResource.offset,
              size: bufferResource.size
            };
          } else if (resource._resourceType === "textureSampler") {
            const sampler = resource;
            gpuResource = renderer.texture.getGpuSampler(sampler);
          } else if (resource._resourceType === "textureSource") {
            const texture = resource;
            gpuResource = renderer.texture.getGpuSource(texture).createView({});
          }
          entries.push({
            binding: groupLayout[j2],
            resource: gpuResource
          });
        }
        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
        const gpuBindGroup = device.createBindGroup({
          layout,
          entries
        });
        this._hash[group._key] = gpuBindGroup;
        return gpuBindGroup;
      }
      destroy() {
        for (const key of Object.keys(this._hash)) {
          this._hash[key] = null;
        }
        this._hash = null;
        this._renderer = null;
      }
    };
    BindGroupSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "bindGroup"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
var GpuBufferSystem;
var init_GpuBufferSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
    init_Extensions();
    init_fastCopy();
    GpuBufferSystem = class {
      constructor(renderer) {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._managedBuffers = [];
        renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getGPUBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
      }
      updateBuffer(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        const data = buffer.data;
        if (buffer._updateID && data) {
          buffer._updateID = 0;
          this._gpu.device.queue.writeBuffer(
            gpuBuffer,
            0,
            data.buffer,
            0,
            // round to the nearest 4 bytes
            (buffer._updateSize || data.byteLength) + 3 & ~3
          );
        }
        return gpuBuffer;
      }
      /** dispose all WebGL resources of all managed buffers */
      destroyAll() {
        for (const id in this._gpuBuffers) {
          this._gpuBuffers[id].destroy();
        }
        this._gpuBuffers = {};
      }
      createGPUBuffer(buffer) {
        if (!this._gpuBuffers[buffer.uid]) {
          buffer.on("update", this.updateBuffer, this);
          buffer.on("change", this.onBufferChange, this);
          buffer.on("destroy", this.onBufferDestroy, this);
          this._managedBuffers.push(buffer);
        }
        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
        buffer._updateID = 0;
        if (buffer.data) {
          fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
          gpuBuffer.unmap();
        }
        this._gpuBuffers[buffer.uid] = gpuBuffer;
        return gpuBuffer;
      }
      onBufferChange(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        buffer._updateID = 0;
        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
      }
      /**
       * Disposes buffer
       * @param buffer - buffer with data
       */
      onBufferDestroy(buffer) {
        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
        this._destroyBuffer(buffer);
      }
      destroy() {
        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
        this._managedBuffers = null;
        this._gpuBuffers = null;
      }
      _destroyBuffer(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        buffer.off("update", this.updateBuffer, this);
        buffer.off("change", this.onBufferChange, this);
        buffer.off("destroy", this.onBufferDestroy, this);
        this._gpuBuffers[buffer.uid] = null;
      }
    };
    GpuBufferSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "buffer"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
var GpuColorMaskSystem;
var init_GpuColorMaskSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
    init_Extensions();
    GpuColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.pipeline.setColorMask(colorMask);
      }
      destroy() {
        this._renderer = null;
        this._colorMaskCache = null;
      }
    };
    GpuColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "colorMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
var GpuDeviceSystem;
var init_GpuDeviceSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
    init_adapter();
    init_Extensions();
    GpuDeviceSystem = class {
      /**
       * @param {WebGPURenderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._renderer = renderer;
      }
      async init(options) {
        if (this._initPromise)
          return this._initPromise;
        this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options)).then((gpu) => {
          this.gpu = gpu;
          this._renderer.runners.contextChange.emit(this.gpu);
        });
        return this._initPromise;
      }
      /**
       * Handle the context change event
       * @param gpu
       */
      contextChange(gpu) {
        this._renderer.gpu = gpu;
      }
      /**
       * Helper class to create a WebGL Context
       * @param {object} options - An options object that gets passed in to the canvas element containing the
       *    context attributes
       * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
       * @returns {WebGLRenderingContext} the WebGL context
       */
      async _createDeviceAndAdaptor(options) {
        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({
          powerPreference: options.powerPreference,
          forceFallbackAdapter: options.forceFallbackAdapter
        });
        const requiredFeatures = [
          "texture-compression-bc",
          "texture-compression-astc",
          "texture-compression-etc2"
        ].filter((feature) => adapter.features.has(feature));
        const device = await adapter.requestDevice({
          requiredFeatures
        });
        return { adapter, device };
      }
      destroy() {
        this.gpu = null;
        this._renderer = null;
      }
    };
    GpuDeviceSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "device"
    };
    GpuDeviceSystem.defaultOptions = {
      /**
       * {@link WebGPUOptions.powerPreference}
       * @default default
       */
      powerPreference: void 0,
      /**
       * Force the use of the fallback adapter
       * @default false
       */
      forceFallbackAdapter: false
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
var GpuEncoderSystem;
var init_GpuEncoderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
    init_Extensions();
    GpuEncoderSystem = class {
      constructor(renderer) {
        this._boundBindGroup = /* @__PURE__ */ Object.create(null);
        this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      renderStart() {
        this.commandFinished = new Promise((resolve) => {
          this._resolveCommandFinished = resolve;
        });
        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
      }
      beginRenderPass(gpuRenderTarget) {
        this.endRenderPass();
        this._clearCache();
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
      }
      endRenderPass() {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
        }
        this.renderPassEncoder = null;
      }
      setViewport(viewport) {
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      }
      setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
        this.setPipeline(pipeline);
      }
      setPipeline(pipeline) {
        if (this._boundPipeline === pipeline)
          return;
        this._boundPipeline = pipeline;
        this.renderPassEncoder.setPipeline(pipeline);
      }
      _setVertexBuffer(index, buffer) {
        if (this._boundVertexBuffer[index] === buffer)
          return;
        this._boundVertexBuffer[index] = buffer;
        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
      }
      _setIndexBuffer(buffer) {
        if (this._boundIndexBuffer === buffer)
          return;
        this._boundIndexBuffer = buffer;
        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
      }
      resetBindGroup(index) {
        this._boundBindGroup[index] = null;
      }
      setBindGroup(index, bindGroup, program) {
        if (this._boundBindGroup[index] === bindGroup)
          return;
        this._boundBindGroup[index] = bindGroup;
        bindGroup._touch(this._renderer.textureGC.count);
        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
      }
      setGeometry(geometry, program) {
        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
        for (const i2 in buffersToBind) {
          this._setVertexBuffer(parseInt(i2, 10), geometry.attributes[buffersToBind[i2]].buffer);
        }
        if (geometry.indexBuffer) {
          this._setIndexBuffer(geometry.indexBuffer);
        }
      }
      _setShaderBindGroups(shader, skipSync) {
        for (const i2 in shader.groups) {
          const bindGroup = shader.groups[i2];
          if (!skipSync) {
            this._syncBindGroup(bindGroup);
          }
          this.setBindGroup(i2, bindGroup, shader.gpuProgram);
        }
      }
      _syncBindGroup(bindGroup) {
        for (const j2 in bindGroup.resources) {
          const resource = bindGroup.resources[j2];
          if (resource.isUniformGroup) {
            this._renderer.ubo.updateUniformGroup(resource);
          }
        }
      }
      draw(options) {
        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;
        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
        this.setGeometry(geometry, shader.gpuProgram);
        this._setShaderBindGroups(shader, skipSync);
        if (geometry.indexBuffer) {
          this.renderPassEncoder.drawIndexed(
            size || geometry.indexBuffer.data.length,
            instanceCount ?? geometry.instanceCount,
            start || 0
          );
        } else {
          this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);
        }
      }
      finishRenderPass() {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
          this.renderPassEncoder = null;
        }
      }
      postrender() {
        this.finishRenderPass();
        this._gpu.device.queue.submit([this.commandEncoder.finish()]);
        this._resolveCommandFinished();
        this.commandEncoder = null;
      }
      // restores a render pass if finishRenderPass was called
      // not optimised as really used for debugging!
      // used when we want to stop drawing and log a texture..
      restoreRenderPass() {
        const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
          this._renderer.renderTarget.renderTarget,
          false,
          [0, 0, 0, 1]
        );
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
        const boundPipeline = this._boundPipeline;
        const boundVertexBuffer = { ...this._boundVertexBuffer };
        const boundIndexBuffer = this._boundIndexBuffer;
        const boundBindGroup = { ...this._boundBindGroup };
        this._clearCache();
        const viewport = this._renderer.renderTarget.viewport;
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        this.setPipeline(boundPipeline);
        for (const i2 in boundVertexBuffer) {
          this._setVertexBuffer(i2, boundVertexBuffer[i2]);
        }
        for (const i2 in boundBindGroup) {
          this.setBindGroup(i2, boundBindGroup[i2], null);
        }
        this._setIndexBuffer(boundIndexBuffer);
      }
      _clearCache() {
        for (let i2 = 0; i2 < 16; i2++) {
          this._boundBindGroup[i2] = null;
          this._boundVertexBuffer[i2] = null;
        }
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      destroy() {
        this._renderer = null;
        this._gpu = null;
        this._boundBindGroup = null;
        this._boundVertexBuffer = null;
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
    };
    GpuEncoderSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "encoder",
      priority: 1
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs
var GpuLimitsSystem;
var init_GpuLimitsSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs"() {
    init_Extensions();
    GpuLimitsSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      contextChange() {
        this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;
        this.maxBatchableTextures = this.maxTextures;
      }
      destroy() {
      }
    };
    GpuLimitsSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "limits"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
var GpuStencilSystem;
var init_GpuStencilSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
    init_Extensions();
    init_const3();
    GpuStencilSystem = class {
      constructor(renderer) {
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(renderTarget) {
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this._activeRenderTarget = renderTarget;
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        const renderer = this._renderer;
        renderer.pipeline.setStencilMode(stencilMode);
        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
      }
      destroy() {
        this._renderer.renderTarget.onRenderTargetChange.remove(this);
        this._renderer = null;
        this._activeRenderTarget = null;
        this._renderTargetStencilState = null;
      }
    };
    GpuStencilSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "stencil"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs
var UboSystem;
var init_UboSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs"() {
    init_unsafeEvalSupported();
    init_Buffer();
    init_const4();
    UboSystem = class {
      constructor(adaptor) {
        this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
        this._adaptor = adaptor;
        this._systemCheck();
      }
      /**
       * Overridable function by `pixi.js/unsafe-eval` to silence
       * throwing an error if platform doesn't support unsafe-evals.
       * @private
       */
      _systemCheck() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
      }
      ensureUniformGroup(uniformGroup) {
        const uniformData = this.getUniformGroupData(uniformGroup);
        uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
          data: new Float32Array(uniformData.layout.size / 4),
          usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
        }));
      }
      getUniformGroupData(uniformGroup) {
        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
      }
      _initUniformGroup(uniformGroup) {
        const uniformGroupSignature = uniformGroup._signature;
        let uniformData = this._syncFunctionHash[uniformGroupSignature];
        if (!uniformData) {
          const elements = Object.keys(uniformGroup.uniformStructures).map((i2) => uniformGroup.uniformStructures[i2]);
          const layout = this._adaptor.createUboElements(elements);
          const syncFunction = this._generateUboSync(layout.uboElements);
          uniformData = this._syncFunctionHash[uniformGroupSignature] = {
            layout,
            syncFunction
          };
        }
        return this._syncFunctionHash[uniformGroupSignature];
      }
      _generateUboSync(uboElements) {
        return this._adaptor.generateUboSync(uboElements);
      }
      syncUniformGroup(uniformGroup, data, offset) {
        const uniformGroupData = this.getUniformGroupData(uniformGroup);
        uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
          data: new Float32Array(uniformGroupData.layout.size / 4),
          usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
        }));
        let dataInt32 = null;
        if (!data) {
          data = uniformGroup.buffer.data;
          dataInt32 = uniformGroup.buffer.dataInt32;
        }
        offset || (offset = 0);
        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);
        return true;
      }
      updateUniformGroup(uniformGroup) {
        if (uniformGroup.isStatic && !uniformGroup._dirtyId)
          return false;
        uniformGroup._dirtyId = 0;
        const synced = this.syncUniformGroup(uniformGroup);
        uniformGroup.buffer.update();
        return synced;
      }
      destroy() {
        this._syncFunctionHash = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
function createUboElementsWGSL(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let offset = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, align) * uboElement.data.size;
    }
    offset = Math.ceil(offset / align) * align;
    uboElement.size = size;
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_ALIGN_SIZE_DATA;
var init_createUboElementsWGSL = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs"() {
    "use strict";
    WGSL_ALIGN_SIZE_DATA = {
      i32: { align: 4, size: 4 },
      u32: { align: 4, size: 4 },
      f32: { align: 4, size: 4 },
      f16: { align: 2, size: 2 },
      "vec2<i32>": { align: 8, size: 8 },
      "vec2<u32>": { align: 8, size: 8 },
      "vec2<f32>": { align: 8, size: 8 },
      "vec2<f16>": { align: 4, size: 4 },
      "vec3<i32>": { align: 16, size: 12 },
      "vec3<u32>": { align: 16, size: 12 },
      "vec3<f32>": { align: 16, size: 12 },
      "vec3<f16>": { align: 8, size: 6 },
      "vec4<i32>": { align: 16, size: 16 },
      "vec4<u32>": { align: 16, size: 16 },
      "vec4<f32>": { align: 16, size: 16 },
      "vec4<f16>": { align: 8, size: 8 },
      "mat2x2<f32>": { align: 8, size: 16 },
      "mat2x2<f16>": { align: 4, size: 8 },
      "mat3x2<f32>": { align: 8, size: 24 },
      "mat3x2<f16>": { align: 4, size: 12 },
      "mat4x2<f32>": { align: 8, size: 32 },
      "mat4x2<f16>": { align: 4, size: 16 },
      "mat2x3<f32>": { align: 16, size: 32 },
      "mat2x3<f16>": { align: 8, size: 16 },
      "mat3x3<f32>": { align: 16, size: 48 },
      "mat3x3<f16>": { align: 8, size: 24 },
      "mat4x3<f32>": { align: 16, size: 64 },
      "mat4x3<f16>": { align: 8, size: 32 },
      "mat2x4<f32>": { align: 16, size: 32 },
      "mat2x4<f16>": { align: 8, size: 16 },
      "mat3x4<f32>": { align: 16, size: 48 },
      "mat3x4<f16>": { align: 8, size: 24 },
      "mat4x4<f32>": { align: 16, size: 64 },
      "mat4x4<f16>": { align: 8, size: 32 }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
var uniformParsers;
var init_uniformParsers = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs"() {
    "use strict";
    uniformParsers = [
      // uploading pixi matrix object to mat3
      {
        type: "mat3x3<f32>",
        test: (data) => {
          const value = data.value;
          return value.a !== void 0;
        },
        ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
        uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
      },
      // uploading a pixi rectangle as a vec4
      {
        type: "vec4<f32>",
        test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
      },
      // uploading a pixi point as a vec2
      {
        type: "vec2<f32>",
        test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
      },
      // uploading a pixi color as a vec4
      {
        type: "vec4<f32>",
        test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
      },
      // uploading a pixi color as a vec3
      {
        type: "vec3<f32>",
        test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
      }
    ];
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
  const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
  let prev = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    const name = uboElement.data.name;
    let parsed = false;
    let offset = 0;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      const uniformParser = uniformParsers[j2];
      if (uniformParser.test(uboElement.data)) {
        offset = uboElement.offset / 4;
        funcFragments.push(
          `name = "${name}";`,
          `offset += ${offset - prev};`,
          uniformParsers[j2][parserCode] || uniformParsers[j2].ubo
        );
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        offset = uboElement.offset / 4;
        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
      } else {
        const template = singleSettersMap[uboElement.data.type];
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
        );
      }
    }
    prev = offset;
  }
  const fragmentSrc = funcFragments.join("\n");
  return new Function(
    "uv",
    "data",
    "dataInt32",
    "offset",
    fragmentSrc
  );
}
var init_createUboSyncFunction = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs"() {
    init_uniformParsers();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
function loopMatrix(col, row) {
  const total = col * row;
  return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
}
var uboSyncFunctionsSTD40, uboSyncFunctionsWGSL;
var init_uboSyncFunctions = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs"() {
    "use strict";
    uboSyncFunctionsSTD40 = {
      f32: `
        data[offset] = v;`,
      i32: `
        dataInt32[offset] = v;`,
      "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
      "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
      "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
      "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
      "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
      "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
      "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
      "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
      "mat3x2<f32>": loopMatrix(3, 2),
      "mat4x2<f32>": loopMatrix(4, 2),
      "mat2x3<f32>": loopMatrix(2, 3),
      "mat4x3<f32>": loopMatrix(4, 3),
      "mat2x4<f32>": loopMatrix(2, 4),
      "mat3x4<f32>": loopMatrix(3, 4)
    };
    uboSyncFunctionsWGSL = {
      ...uboSyncFunctionsSTD40,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
function generateArraySyncWGSL(uboElement, offsetToAdd) {
  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
  const remainder = (align - size) / 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 ${data}[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
}
var init_generateArraySyncWGSL = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs"() {
    init_createUboElementsWGSL();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
function createUboSyncFunctionWGSL(uboElements) {
  return createUboSyncFunction(
    uboElements,
    "uboWgsl",
    generateArraySyncWGSL,
    uboSyncFunctionsWGSL
  );
}
var init_createUboSyncFunctionWGSL = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs"() {
    init_createUboSyncFunction();
    init_uboSyncFunctions();
    init_generateArraySyncWGSL();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs
var GpuUboSystem;
var init_GpuUboSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs"() {
    init_Extensions();
    init_UboSystem();
    init_createUboElementsWGSL();
    init_createUboSyncFunctionWGSL();
    GpuUboSystem = class extends UboSystem {
      constructor() {
        super({
          createUboElements: createUboElementsWGSL,
          generateUboSync: createUboSyncFunctionWGSL
        });
      }
    };
    GpuUboSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "ubo"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
var BufferResource;
var init_BufferResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
    init_eventemitter3();
    init_uid();
    BufferResource = class extends eventemitter3_default {
      /**
       * Create a new Buffer Resource.
       * @param options - The options for the buffer resource
       * @param options.buffer - The underlying buffer that this resource is using
       * @param options.offset - The offset of the buffer this resource is using.
       * If not provided, then it will use the offset of the buffer.
       * @param options.size - The size of the buffer this resource is using.
       * If not provided, then it will use the size of the buffer.
       */
      constructor({ buffer, offset, size }) {
        super();
        this.uid = uid("buffer");
        this._resourceType = "bufferResource";
        this._touched = 0;
        this._resourceId = uid("resource");
        this._bufferResource = true;
        this.destroyed = false;
        this.buffer = buffer;
        this.offset = offset | 0;
        this.size = size;
        this.buffer.on("change", this.onBufferChange, this);
      }
      onBufferChange() {
        this._resourceId = uid("resource");
        this.emit("change", this);
      }
      /**
       * Destroys this resource. Make sure the underlying buffer is not used anywhere else
       * if you want to destroy it as well, or code will explode
       * @param destroyBuffer - Should the underlying buffer be destroyed as well?
       */
      destroy(destroyBuffer = false) {
        this.destroyed = true;
        if (destroyBuffer) {
          this.buffer.destroy();
        }
        this.emit("change", this);
        this.buffer = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
var UboBatch;
var init_UboBatch = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs"() {
    "use strict";
    UboBatch = class {
      constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
        this._minUniformOffsetAlignment = 256;
        this.byteIndex = 0;
        this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
        this.data = new Float32Array(65535);
      }
      clear() {
        this.byteIndex = 0;
      }
      addEmptyGroup(size) {
        if (size > this._minUniformOffsetAlignment / 4) {
          throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
        }
        const start = this.byteIndex;
        let newSize = start + size * 4;
        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
        if (newSize > this.data.length * 4) {
          throw new Error("UniformBufferBatch: ubo batch got too big");
        }
        this.byteIndex = newSize;
        return start;
      }
      addGroup(array) {
        const offset = this.addEmptyGroup(array.length);
        for (let i2 = 0; i2 < array.length; i2++) {
          this.data[offset / 4 + i2] = array[i2];
        }
        return offset;
      }
      destroy() {
        this.data = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
var minUniformOffsetAlignment, GpuUniformBatchPipe;
var init_GpuUniformBatchPipe = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
    init_Extensions();
    init_Buffer();
    init_BufferResource();
    init_const4();
    init_UboBatch();
    init_BindGroup();
    minUniformOffsetAlignment = 128;
    GpuUniformBatchPipe = class {
      constructor(renderer) {
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._buffers = [];
        this._bindGroups = [];
        this._bufferResources = [];
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
        const totalBuffers = 256 / minUniformOffsetAlignment;
        for (let i2 = 0; i2 < totalBuffers; i2++) {
          let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
          if (i2 === 0)
            usage |= BufferUsage.COPY_SRC;
          this._buffers.push(new Buffer2({
            data: this._batchBuffer.data,
            usage
          }));
        }
      }
      renderEnd() {
        this._uploadBindGroups();
        this._resetBindGroups();
      }
      _resetBindGroups() {
        for (const i2 in this._bindGroupHash) {
          this._bindGroupHash[i2] = null;
        }
        this._batchBuffer.clear();
      }
      // just works for single bind groups for now
      getUniformBindGroup(group, duplicate) {
        if (!duplicate && this._bindGroupHash[group.uid]) {
          return this._bindGroupHash[group.uid];
        }
        this._renderer.ubo.ensureUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addEmptyGroup(data.length);
        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
        return this._bindGroupHash[group.uid];
      }
      getUboResource(group) {
        this._renderer.ubo.updateUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addGroup(data);
        return this._getBufferResource(offset / minUniformOffsetAlignment);
      }
      getArrayBindGroup(data) {
        const offset = this._batchBuffer.addGroup(data);
        return this._getBindGroup(offset / minUniformOffsetAlignment);
      }
      getArrayBufferResource(data) {
        const offset = this._batchBuffer.addGroup(data);
        const index = offset / minUniformOffsetAlignment;
        return this._getBufferResource(index);
      }
      _getBufferResource(index) {
        if (!this._bufferResources[index]) {
          const buffer = this._buffers[index % 2];
          this._bufferResources[index] = new BufferResource({
            buffer,
            offset: (index / 2 | 0) * 256,
            size: minUniformOffsetAlignment
          });
        }
        return this._bufferResources[index];
      }
      _getBindGroup(index) {
        if (!this._bindGroups[index]) {
          const bindGroup = new BindGroup({
            0: this._getBufferResource(index)
          });
          this._bindGroups[index] = bindGroup;
        }
        return this._bindGroups[index];
      }
      _uploadBindGroups() {
        const bufferSystem = this._renderer.buffer;
        const firstBuffer = this._buffers[0];
        firstBuffer.update(this._batchBuffer.byteIndex);
        bufferSystem.updateBuffer(firstBuffer);
        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        for (let i2 = 1; i2 < this._buffers.length; i2++) {
          const buffer = this._buffers[i2];
          commandEncoder.copyBufferToBuffer(
            bufferSystem.getGPUBuffer(firstBuffer),
            minUniformOffsetAlignment,
            bufferSystem.getGPUBuffer(buffer),
            0,
            this._batchBuffer.byteIndex
          );
        }
        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
      }
      destroy() {
        for (let i2 = 0; i2 < this._bindGroups.length; i2++) {
          this._bindGroups[i2]?.destroy();
        }
        this._bindGroups = null;
        this._bindGroupHash = null;
        for (let i2 = 0; i2 < this._buffers.length; i2++) {
          this._buffers[i2].destroy();
        }
        this._buffers = null;
        for (let i2 = 0; i2 < this._bufferResources.length; i2++) {
          this._bufferResources[i2].destroy();
        }
        this._bufferResources = null;
        this._batchBuffer.destroy();
        this._bindGroupHash = null;
        this._renderer = null;
      }
    };
    GpuUniformBatchPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "uniformBatch"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
function ensureAttributes(geometry, extractedData) {
  for (const i2 in geometry.attributes) {
    const attribute = geometry.attributes[i2];
    const attributeData = extractedData[i2];
    if (attributeData) {
      attribute.format ?? (attribute.format = attributeData.format);
      attribute.offset ?? (attribute.offset = attributeData.offset);
      attribute.instance ?? (attribute.instance = attributeData.instance);
    } else {
      warn(`Attribute ${i2} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
    }
  }
  ensureStartAndStride(geometry);
}
function ensureStartAndStride(geometry) {
  const { buffers, attributes } = geometry;
  const tempStride = {};
  const tempStart = {};
  for (const j2 in buffers) {
    const buffer = buffers[j2];
    tempStride[buffer.uid] = 0;
    tempStart[buffer.uid] = 0;
  }
  for (const j2 in attributes) {
    const attribute = attributes[j2];
    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
  for (const j2 in attributes) {
    const attribute = attributes[j2];
    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
}
var init_ensureAttributes = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs"() {
    init_warn();
    init_getAttributeInfoFromFormat();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
var GpuStencilModesToPixi;
var init_GpuStencilModesToPixi = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
    init_const3();
    GpuStencilModesToPixi = [];
    GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
    GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
      stencilWriteMask: 0,
      stencilReadMask: 0
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
      stencilFront: {
        compare: "equal",
        passOp: "increment-clamp"
      },
      stencilBack: {
        compare: "equal",
        passOp: "increment-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
      stencilFront: {
        compare: "equal",
        passOp: "decrement-clamp"
      },
      stencilBack: {
        compare: "equal",
        passOp: "decrement-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
      stencilWriteMask: 0,
      stencilFront: {
        compare: "equal",
        passOp: "keep"
      },
      stencilBack: {
        compare: "equal",
        passOp: "keep"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
      stencilWriteMask: 0,
      stencilFront: {
        compare: "not-equal",
        passOp: "keep"
      },
      stencilBack: {
        compare: "not-equal",
        passOp: "keep"
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
}
function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
}
var topologyStringToId, PipelineSystem;
var init_PipelineSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
    init_Extensions();
    init_warn();
    init_ensureAttributes();
    init_const3();
    init_createIdFromString();
    init_GpuStencilModesToPixi();
    topologyStringToId = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 2,
      "triangle-list": 3,
      "triangle-strip": 4
    };
    PipelineSystem = class {
      constructor(renderer) {
        this._moduleCache = /* @__PURE__ */ Object.create(null);
        this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
        this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
        this._pipeCache = /* @__PURE__ */ Object.create(null);
        this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
        this._colorMask = 15;
        this._multisampleCount = 1;
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
        this.setStencilMode(STENCIL_MODES.DISABLED);
        this._updatePipeHash();
      }
      setMultisampleCount(multisampleCount) {
        if (this._multisampleCount === multisampleCount)
          return;
        this._multisampleCount = multisampleCount;
        this._updatePipeHash();
      }
      setRenderTarget(renderTarget) {
        this._multisampleCount = renderTarget.msaaSamples;
        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
        this._updatePipeHash();
      }
      setColorMask(colorMask) {
        if (this._colorMask === colorMask)
          return;
        this._colorMask = colorMask;
        this._updatePipeHash();
      }
      setStencilMode(stencilMode) {
        if (this._stencilMode === stencilMode)
          return;
        this._stencilMode = stencilMode;
        this._stencilState = GpuStencilModesToPixi[stencilMode];
        this._updatePipeHash();
      }
      setPipeline(geometry, program, state, passEncoder) {
        const pipeline = this.getPipeline(geometry, program, state);
        passEncoder.setPipeline(pipeline);
      }
      getPipeline(geometry, program, state, topology) {
        if (!geometry._layoutKey) {
          ensureAttributes(geometry, program.attributeData);
          this._generateBufferKey(geometry);
        }
        topology || (topology = geometry.topology);
        const key = getGraphicsStateKey(
          geometry._layoutKey,
          program._layoutKey,
          state.data,
          state._blendModeId,
          topologyStringToId[topology]
        );
        if (this._pipeCache[key])
          return this._pipeCache[key];
        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
        return this._pipeCache[key];
      }
      _createPipeline(geometry, program, state, topology) {
        const device = this._gpu.device;
        const buffers = this._createVertexBufferLayouts(geometry, program);
        const blendModes = this._renderer.state.getColorTargets(state);
        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
        const layout = this._renderer.shader.getProgramData(program).pipeline;
        const descriptor = {
          // TODO later check if its helpful to create..
          // layout,
          vertex: {
            module: this._getModule(program.vertex.source),
            entryPoint: program.vertex.entryPoint,
            // geometry..
            buffers
          },
          fragment: {
            module: this._getModule(program.fragment.source),
            entryPoint: program.fragment.entryPoint,
            targets: blendModes
          },
          primitive: {
            topology,
            cullMode: state.cullMode
          },
          layout,
          multisample: {
            count: this._multisampleCount
          },
          // depthStencil,
          label: `PIXI Pipeline`
        };
        if (this._depthStencilAttachment) {
          descriptor.depthStencil = {
            ...this._stencilState,
            format: "depth24plus-stencil8",
            depthWriteEnabled: state.depthTest,
            depthCompare: state.depthTest ? "less" : "always"
          };
        }
        const pipeline = device.createRenderPipeline(descriptor);
        return pipeline;
      }
      _getModule(code) {
        return this._moduleCache[code] || this._createModule(code);
      }
      _createModule(code) {
        const device = this._gpu.device;
        this._moduleCache[code] = device.createShaderModule({
          code
        });
        return this._moduleCache[code];
      }
      _generateBufferKey(geometry) {
        const keyGen = [];
        let index = 0;
        const attributeKeys = Object.keys(geometry.attributes).sort();
        for (let i2 = 0; i2 < attributeKeys.length; i2++) {
          const attribute = geometry.attributes[attributeKeys[i2]];
          keyGen[index++] = attribute.offset;
          keyGen[index++] = attribute.format;
          keyGen[index++] = attribute.stride;
          keyGen[index++] = attribute.instance;
        }
        const stringKey = keyGen.join("|");
        geometry._layoutKey = createIdFromString(stringKey, "geometry");
        return geometry._layoutKey;
      }
      _generateAttributeLocationsKey(program) {
        const keyGen = [];
        let index = 0;
        const attributeKeys = Object.keys(program.attributeData).sort();
        for (let i2 = 0; i2 < attributeKeys.length; i2++) {
          const attribute = program.attributeData[attributeKeys[i2]];
          keyGen[index++] = attribute.location;
        }
        const stringKey = keyGen.join("|");
        program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
        return program._attributeLocationsKey;
      }
      /**
       * Returns a hash of buffer names mapped to bind locations.
       * This is used to bind the correct buffer to the correct location in the shader.
       * @param geometry - The geometry where to get the buffer names
       * @param program - The program where to get the buffer names
       * @returns An object of buffer names mapped to the bind location.
       */
      getBufferNamesToBind(geometry, program) {
        const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
        if (this._bindingNamesCache[key])
          return this._bindingNamesCache[key];
        const data = this._createVertexBufferLayouts(geometry, program);
        const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
        const attributeData = program.attributeData;
        for (let i2 = 0; i2 < data.length; i2++) {
          const attributes = Object.values(data[i2].attributes);
          const shaderLocation = attributes[0].shaderLocation;
          for (const j2 in attributeData) {
            if (attributeData[j2].location === shaderLocation) {
              bufferNamesToBind[i2] = j2;
              break;
            }
          }
        }
        this._bindingNamesCache[key] = bufferNamesToBind;
        return bufferNamesToBind;
      }
      _createVertexBufferLayouts(geometry, program) {
        if (!program._attributeLocationsKey)
          this._generateAttributeLocationsKey(program);
        const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
        if (this._bufferLayoutsCache[key]) {
          return this._bufferLayoutsCache[key];
        }
        const vertexBuffersLayout = [];
        geometry.buffers.forEach((buffer) => {
          const bufferEntry = {
            arrayStride: 0,
            stepMode: "vertex",
            attributes: []
          };
          const bufferEntryAttributes = bufferEntry.attributes;
          for (const i2 in program.attributeData) {
            const attribute = geometry.attributes[i2];
            if ((attribute.divisor ?? 1) !== 1) {
              warn(`Attribute ${i2} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
            }
            if (attribute.buffer === buffer) {
              bufferEntry.arrayStride = attribute.stride;
              bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
              bufferEntryAttributes.push({
                shaderLocation: program.attributeData[i2].location,
                offset: attribute.offset,
                format: attribute.format
              });
            }
          }
          if (bufferEntryAttributes.length) {
            vertexBuffersLayout.push(bufferEntry);
          }
        });
        this._bufferLayoutsCache[key] = vertexBuffersLayout;
        return vertexBuffersLayout;
      }
      _updatePipeHash() {
        const key = getGlobalStateKey(
          this._stencilMode,
          this._multisampleCount,
          this._colorMask,
          this._depthStencilAttachment
        );
        if (!this._pipeStateCaches[key]) {
          this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
        }
        this._pipeCache = this._pipeStateCaches[key];
      }
      destroy() {
        this._renderer = null;
        this._bufferLayoutsCache = null;
      }
    };
    PipelineSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "pipeline"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
function calculateProjection(pm, x2, y2, width, height, flipY) {
  const sign2 = flipY ? 1 : -1;
  pm.identity();
  pm.a = 1 / width * 2;
  pm.d = sign2 * (1 / height * 2);
  pm.tx = -1 - x2 * pm.a;
  pm.ty = -sign2 - y2 * pm.d;
  return pm;
}
var init_calculateProjection = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
function isRenderingToScreen(renderTarget) {
  const resource = renderTarget.colorTexture.source.resource;
  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
}
var init_isRenderingToScreen = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
var RenderTargetSystem;
var init_RenderTargetSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"() {
    init_Matrix();
    init_Rectangle();
    init_const7();
    init_calculateProjection();
    init_SystemRunner();
    init_CanvasSource();
    init_TextureSource();
    init_Texture();
    init_getCanvasTexture();
    init_isRenderingToScreen();
    init_RenderTarget();
    RenderTargetSystem = class {
      constructor(renderer) {
        this.rootViewPort = new Rectangle();
        this.viewport = new Rectangle();
        this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
        this.projectionMatrix = new Matrix();
        this.defaultClearColor = [0, 0, 0, 0];
        this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        this._renderTargetStack = [];
        this._renderer = renderer;
        renderer.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
      }
      /** called when dev wants to finish a render pass */
      finishRenderPass() {
        this.adaptor.finishRenderPass(this.renderTarget);
      }
      /**
       * called when the renderer starts to render a scene.
       * @param options
       * @param options.target - the render target to render to
       * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
       * @param options.clearColor - the color to clear to
       * @param options.frame - the frame to render to
       */
      renderStart({
        target,
        clear,
        clearColor,
        frame
      }) {
        this._renderTargetStack.length = 0;
        this.push(
          target,
          clear,
          clearColor,
          frame
        );
        this.rootViewPort.copyFrom(this.viewport);
        this.rootRenderTarget = this.renderTarget;
        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        this.adaptor.prerender?.(this.rootRenderTarget);
      }
      postrender() {
        this.adaptor.postrender?.(this.rootRenderTarget);
      }
      /**
       * Binding a render surface! This is the main function of the render target system.
       * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
       * Once bound all draw calls will be rendered to the render surface.
       *
       * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
       * @param renderSurface - the render surface to bind
       * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
       * @param clearColor - the color to clear to
       * @param frame - the frame to render to
       * @returns the render target that was bound
       */
      bind(renderSurface, clear = true, clearColor, frame) {
        const renderTarget = this.getRenderTarget(renderSurface);
        const didChange = this.renderTarget !== renderTarget;
        this.renderTarget = renderTarget;
        this.renderSurface = renderSurface;
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
          this.adaptor.resizeGpuRenderTarget(renderTarget);
          gpuRenderTarget.width = renderTarget.pixelWidth;
          gpuRenderTarget.height = renderTarget.pixelHeight;
        }
        const source3 = renderTarget.colorTexture;
        const viewport = this.viewport;
        const pixelWidth = source3.pixelWidth;
        const pixelHeight = source3.pixelHeight;
        if (!frame && renderSurface instanceof Texture) {
          frame = renderSurface.frame;
        }
        if (frame) {
          const resolution = source3._resolution;
          viewport.x = frame.x * resolution + 0.5 | 0;
          viewport.y = frame.y * resolution + 0.5 | 0;
          viewport.width = frame.width * resolution + 0.5 | 0;
          viewport.height = frame.height * resolution + 0.5 | 0;
        } else {
          viewport.x = 0;
          viewport.y = 0;
          viewport.width = pixelWidth;
          viewport.height = pixelHeight;
        }
        calculateProjection(
          this.projectionMatrix,
          0,
          0,
          viewport.width / source3.resolution,
          viewport.height / source3.resolution,
          !renderTarget.isRoot
        );
        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
        if (didChange) {
          this.onRenderTargetChange.emit(renderTarget);
        }
        return renderTarget;
      }
      clear(target, clear = CLEAR.ALL, clearColor) {
        if (!clear)
          return;
        if (target) {
          target = this.getRenderTarget(target);
        }
        this.adaptor.clear(
          target || this.renderTarget,
          clear,
          clearColor,
          this.viewport
        );
      }
      contextChange() {
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Push a render surface to the renderer. This will bind the render surface to the renderer,
       * @param renderSurface - the render surface to push
       * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
       * @param clearColor - the color to clear to
       * @param frame - the frame to use when rendering to the render surface
       */
      push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {
        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
        this._renderTargetStack.push({
          renderTarget,
          frame
        });
        return renderTarget;
      }
      /** Pops the current render target from the renderer and restores the previous render target. */
      pop() {
        this._renderTargetStack.pop();
        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
      }
      /**
       * Gets the render target from the provide render surface. Eg if its a texture,
       * it will return the render target for the texture.
       * If its a render target, it will return the same render target.
       * @param renderSurface - the render surface to get the render target for
       * @returns the render target for the render surface
       */
      getRenderTarget(renderSurface) {
        if (renderSurface.isTexture) {
          renderSurface = renderSurface.source;
        }
        return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
      }
      /**
       * Copies a render surface to another texture.
       *
       * NOTE:
       * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer
       *
       * The following is not valid:
       * @example
       * const canvas = document.createElement('canvas')
       * canvas.width = 200;
       * canvas.height = 200;
       *
       * const ctx = canvas2.getContext('2d')!
       * ctx.fillStyle = 'red'
       * ctx.fillRect(0, 0, 200, 200);
       *
       * const texture = RenderTexture.create({
       *   width: 200,
       *   height: 200,
       * })
       * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);
       *
       * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});
       *
       * The best way to copy a canvas is to create a texture from it. Then render with that.
       *
       * Parsing in a RenderTarget canvas context (with a 2d context)
       * @param sourceRenderSurfaceTexture - the render surface to copy from
       * @param destinationTexture - the texture to copy to
       * @param originSrc - the origin of the copy
       * @param originSrc.x - the x origin of the copy
       * @param originSrc.y - the y origin of the copy
       * @param size - the size of the copy
       * @param size.width - the width of the copy
       * @param size.height - the height of the copy
       * @param originDest - the destination origin (top left to paste from!)
       * @param originDest.x - the x origin of the paste
       * @param originDest.y - the y origin of the paste
       */
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
        if (originSrc.x < 0) {
          size.width += originSrc.x;
          originDest.x -= originSrc.x;
          originSrc.x = 0;
        }
        if (originSrc.y < 0) {
          size.height += originSrc.y;
          originDest.y -= originSrc.y;
          originSrc.y = 0;
        }
        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
        size.width = Math.min(size.width, pixelWidth - originSrc.x);
        size.height = Math.min(size.height, pixelHeight - originSrc.y);
        return this.adaptor.copyToTexture(
          sourceRenderSurfaceTexture,
          destinationTexture,
          originSrc,
          size,
          originDest
        );
      }
      /**
       * ensures that we have a depth stencil buffer available to render to
       * This is used by the mask system to make sure we have a stencil buffer.
       */
      ensureDepthStencil() {
        if (!this.renderTarget.stencil) {
          this.renderTarget.stencil = true;
          this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
        }
      }
      /** nukes the render target system */
      destroy() {
        this._renderer = null;
        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
          if (renderTarget !== key) {
            renderTarget.destroy();
          }
        });
        this._renderSurfaceToRenderTargetHash.clear();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
      }
      _initRenderTarget(renderSurface) {
        let renderTarget = null;
        if (CanvasSource.test(renderSurface)) {
          renderSurface = getCanvasTexture(renderSurface).source;
        }
        if (renderSurface instanceof RenderTarget) {
          renderTarget = renderSurface;
        } else if (renderSurface instanceof TextureSource) {
          renderTarget = new RenderTarget({
            colorTextures: [renderSurface]
          });
          if (renderSurface.source instanceof CanvasSource) {
            renderTarget.isRoot = true;
          }
          renderSurface.once("destroy", () => {
            renderTarget.destroy();
            this._renderSurfaceToRenderTargetHash.delete(renderSurface);
            const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
            if (gpuRenderTarget) {
              this._gpuRenderTargetHash[renderTarget.uid] = null;
              this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
            }
          });
        }
        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
        return renderTarget;
      }
      getGpuRenderTarget(renderTarget) {
        return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
      }
      resetState() {
        this.renderTarget = null;
        this.renderSurface = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
var GpuRenderTarget;
var init_GpuRenderTarget = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
    "use strict";
    GpuRenderTarget = class {
      constructor() {
        this.contexts = [];
        this.msaaTextures = [];
        this.msaaSamples = 1;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
var GpuRenderTargetAdaptor;
var init_GpuRenderTargetAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs"() {
    init_const7();
    init_CanvasSource();
    init_TextureSource();
    init_GpuRenderTarget();
    GpuRenderTargetAdaptor = class {
      init(renderer, renderTargetSystem) {
        this._renderer = renderer;
        this._renderTargetSystem = renderTargetSystem;
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
        const renderer = this._renderer;
        const baseGpuTexture = this._getGpuColorTexture(
          sourceRenderSurfaceTexture
        );
        const backGpuTexture = renderer.texture.getGpuSource(
          destinationTexture.source
        );
        renderer.encoder.commandEncoder.copyTextureToTexture(
          {
            texture: baseGpuTexture,
            origin: originSrc
          },
          {
            texture: backGpuTexture,
            origin: originDest
          },
          size
        );
        return destinationTexture;
      }
      startRenderPass(renderTarget, clear = true, clearColor, viewport) {
        const renderTargetSystem = this._renderTargetSystem;
        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
        gpuRenderTarget.descriptor = descriptor;
        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
        this._renderer.encoder.beginRenderPass(gpuRenderTarget);
        this._renderer.encoder.setViewport(viewport);
      }
      finishRenderPass() {
        this._renderer.encoder.endRenderPass();
      }
      /**
       * returns the gpu texture for the first color texture in the render target
       * mainly used by the filter manager to get copy the texture for blending
       * @param renderTarget
       * @returns a gpu texture
       */
      _getGpuColorTexture(renderTarget) {
        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        if (gpuRenderTarget.contexts[0]) {
          return gpuRenderTarget.contexts[0].getCurrentTexture();
        }
        return this._renderer.texture.getGpuSource(
          renderTarget.colorTextures[0].source
        );
      }
      getDescriptor(renderTarget, clear, clearValue) {
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const renderTargetSystem = this._renderTargetSystem;
        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        const colorAttachments = renderTarget.colorTextures.map(
          (texture, i2) => {
            const context2 = gpuRenderTarget.contexts[i2];
            let view;
            let resolveTarget;
            if (context2) {
              const currentTexture = context2.getCurrentTexture();
              const canvasTextureView = currentTexture.createView();
              view = canvasTextureView;
            } else {
              view = this._renderer.texture.getGpuSource(texture).createView({
                mipLevelCount: 1
              });
            }
            if (gpuRenderTarget.msaaTextures[i2]) {
              resolveTarget = view;
              view = this._renderer.texture.getTextureView(
                gpuRenderTarget.msaaTextures[i2]
              );
            }
            const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
            clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
            return {
              view,
              resolveTarget,
              clearValue,
              storeOp: "store",
              loadOp
            };
          }
        );
        let depthStencilAttachment;
        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
          renderTarget.ensureDepthStencilTexture();
          renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
        }
        if (renderTarget.depthStencilTexture) {
          const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
          const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
          depthStencilAttachment = {
            view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
            stencilStoreOp: "store",
            stencilLoadOp,
            depthClearValue: 1,
            depthLoadOp,
            depthStoreOp: "store"
          };
        }
        const descriptor = {
          colorAttachments,
          depthStencilAttachment
        };
        return descriptor;
      }
      clear(renderTarget, clear = true, clearColor, viewport) {
        if (!clear)
          return;
        const { gpu, encoder } = this._renderer;
        const device = gpu.device;
        const standAlone = encoder.commandEncoder === null;
        if (standAlone) {
          const commandEncoder = device.createCommandEncoder();
          const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
          const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
          passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          passEncoder.end();
          const gpuCommands = commandEncoder.finish();
          device.queue.submit([gpuCommands]);
        } else {
          this.startRenderPass(renderTarget, clear, clearColor, viewport);
        }
      }
      initGpuRenderTarget(renderTarget) {
        renderTarget.isRoot = true;
        const gpuRenderTarget = new GpuRenderTarget();
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          if (colorTexture instanceof CanvasSource) {
            const context2 = colorTexture.resource.getContext(
              "webgpu"
            );
            const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
            try {
              context2.configure({
                device: this._renderer.gpu.device,
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                format: "bgra8unorm",
                alphaMode
              });
            } catch (e2) {
              console.error(e2);
            }
            gpuRenderTarget.contexts[i2] = context2;
          }
          gpuRenderTarget.msaa = colorTexture.source.antialias;
          if (colorTexture.source.antialias) {
            const msaaTexture = new TextureSource({
              width: 0,
              height: 0,
              sampleCount: 4
            });
            gpuRenderTarget.msaaTextures[i2] = msaaTexture;
          }
        });
        if (gpuRenderTarget.msaa) {
          gpuRenderTarget.msaaSamples = 4;
          if (renderTarget.depthStencilTexture) {
            renderTarget.depthStencilTexture.source.sampleCount = 4;
          }
        }
        return gpuRenderTarget;
      }
      destroyGpuRenderTarget(gpuRenderTarget) {
        gpuRenderTarget.contexts.forEach((context2) => {
          context2.unconfigure();
        });
        gpuRenderTarget.msaaTextures.forEach((texture) => {
          texture.destroy();
        });
        gpuRenderTarget.msaaTextures.length = 0;
        gpuRenderTarget.contexts.length = 0;
      }
      ensureDepthStencilTexture(renderTarget) {
        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
          renderTarget.depthStencilTexture.source.sampleCount = 4;
        }
      }
      resizeGpuRenderTarget(renderTarget) {
        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        gpuRenderTarget.width = renderTarget.width;
        gpuRenderTarget.height = renderTarget.height;
        if (gpuRenderTarget.msaa) {
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const msaaTexture = gpuRenderTarget.msaaTextures[i2];
            msaaTexture?.resize(
              colorTexture.source.width,
              colorTexture.source.height,
              colorTexture.source._resolution
            );
          });
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
var GpuRenderTargetSystem;
var init_GpuRenderTargetSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
    init_Extensions();
    init_RenderTargetSystem();
    init_GpuRenderTargetAdaptor();
    GpuRenderTargetSystem = class extends RenderTargetSystem {
      constructor(renderer) {
        super(renderer);
        this.adaptor = new GpuRenderTargetAdaptor();
        this.adaptor.init(renderer, this);
      }
    };
    GpuRenderTargetSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "renderTarget"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
var GpuShaderSystem;
var init_GpuShaderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
    init_Extensions();
    GpuShaderSystem = class {
      constructor() {
        this._gpuProgramData = /* @__PURE__ */ Object.create(null);
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getProgramData(program) {
        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
      }
      _createGPUProgramData(program) {
        const device = this._gpu.device;
        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
        this._gpuProgramData[program._layoutKey] = {
          bindGroups,
          pipeline: device.createPipelineLayout(pipelineLayoutDesc)
        };
        return this._gpuProgramData[program._layoutKey];
      }
      destroy() {
        this._gpu = null;
        this._gpuProgramData = null;
      }
    };
    GpuShaderSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "shader"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
var GpuBlendModesToPixi;
var init_GpuBlendModesToPixi = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
    "use strict";
    GpuBlendModesToPixi = {};
    GpuBlendModesToPixi.normal = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.add = {
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.multiply = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "dst",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.screen = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.overlay = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.none = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "zero",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["normal-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["add-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["screen-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.erase = {
      alpha: {
        srcFactor: "zero",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.min = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
      }
    };
    GpuBlendModesToPixi.max = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
var GpuStateSystem;
var init_GpuStateSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_GpuBlendModesToPixi();
    GpuStateSystem = class {
      constructor() {
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      /**
       * Gets the blend mode data for the current state
       * @param state - The state to get the blend mode from
       */
      getColorTargets(state) {
        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
        return [
          {
            format: "bgra8unorm",
            writeMask: 0,
            blend
          }
        ];
      }
      destroy() {
        this.gpu = null;
      }
    };
    GpuStateSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "state"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
var gpuUploadBufferImageResource;
var init_gpuUploadBufferImageResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
    "use strict";
    gpuUploadBufferImageResource = {
      type: "image",
      upload(source3, gpuTexture, gpu) {
        const resource = source3.resource;
        const total = (source3.pixelWidth | 0) * (source3.pixelHeight | 0);
        const bytesPerPixel = resource.byteLength / total;
        gpu.device.queue.writeTexture(
          { texture: gpuTexture },
          resource,
          {
            offset: 0,
            rowsPerImage: source3.pixelHeight,
            bytesPerRow: source3.pixelHeight * bytesPerPixel
          },
          {
            width: source3.pixelWidth,
            height: source3.pixelHeight,
            depthOrArrayLayers: 1
          }
        );
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
var blockDataMap, defaultBlockData, gpuUploadCompressedTextureResource;
var init_gpuUploadCompressedTextureResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs"() {
    "use strict";
    blockDataMap = {
      "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
      "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
      "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
    };
    defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
    gpuUploadCompressedTextureResource = {
      type: "compressed",
      upload(source3, gpuTexture, gpu) {
        let mipWidth = source3.pixelWidth;
        let mipHeight = source3.pixelHeight;
        const blockData = blockDataMap[source3.format] || defaultBlockData;
        for (let i2 = 0; i2 < source3.resource.length; i2++) {
          const levelBuffer = source3.resource[i2];
          const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
          gpu.device.queue.writeTexture(
            {
              texture: gpuTexture,
              mipLevel: i2
            },
            levelBuffer,
            {
              offset: 0,
              bytesPerRow
            },
            {
              width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
              height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
              depthOrArrayLayers: 1
            }
          );
          mipWidth = Math.max(mipWidth >> 1, 1);
          mipHeight = Math.max(mipHeight >> 1, 1);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
var gpuUploadImageResource;
var init_gpuUploadImageSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
    init_adapter();
    init_warn();
    gpuUploadImageResource = {
      type: "image",
      upload(source3, gpuTexture, gpu) {
        const resource = source3.resource;
        if (!resource)
          return;
        if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {
          const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);
          const context2 = canvas.getContext("2d");
          context2.drawImage(resource, 0, 0, resource.width, resource.height);
          source3.resource = canvas;
          warn("ImageSource: Image element passed, converting to canvas and replacing resource.");
        }
        const width = Math.min(gpuTexture.width, source3.resourceWidth || source3.pixelWidth);
        const height = Math.min(gpuTexture.height, source3.resourceHeight || source3.pixelHeight);
        const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
        gpu.device.queue.copyExternalImageToTexture(
          { source: resource },
          { texture: gpuTexture, premultipliedAlpha },
          {
            width,
            height
          }
        );
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
var gpuUploadVideoResource;
var init_gpuUploadVideoSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
    init_gpuUploadImageSource();
    gpuUploadVideoResource = {
      type: "video",
      upload(source3, gpuTexture, gpu) {
        gpuUploadImageResource.upload(source3, gpuTexture, gpu);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
var GpuMipmapGenerator;
var init_GpuMipmapGenerator = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
    "use strict";
    GpuMipmapGenerator = class {
      constructor(device) {
        this.device = device;
        this.sampler = device.createSampler({ minFilter: "linear" });
        this.pipelines = {};
      }
      _getMipmapPipeline(format) {
        let pipeline = this.pipelines[format];
        if (!pipeline) {
          if (!this.mipmapShaderModule) {
            this.mipmapShaderModule = this.device.createShaderModule({
              code: (
                /* wgsl */
                `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
              )
            });
          }
          pipeline = this.device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module: this.mipmapShaderModule,
              entryPoint: "vertexMain"
            },
            fragment: {
              module: this.mipmapShaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format }]
            }
          });
          this.pipelines[format] = pipeline;
        }
        return pipeline;
      }
      /**
       * Generates mipmaps for the given GPUTexture from the data in level 0.
       * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
       * @returns {module:External.GPUTexture} - The originally passed texture
       */
      generateMipmap(texture) {
        const pipeline = this._getMipmapPipeline(texture.format);
        if (texture.dimension === "3d" || texture.dimension === "1d") {
          throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
        }
        let mipTexture = texture;
        const arrayLayerCount = texture.depthOrArrayLayers || 1;
        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!renderToSource) {
          const mipTextureDescriptor = {
            size: {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            },
            format: texture.format,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
            mipLevelCount: texture.mipLevelCount - 1
          };
          mipTexture = this.device.createTexture(mipTextureDescriptor);
        }
        const commandEncoder = this.device.createCommandEncoder({});
        const bindGroupLayout = pipeline.getBindGroupLayout(0);
        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
          let srcView = texture.createView({
            baseMipLevel: 0,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: arrayLayer,
            arrayLayerCount: 1
          });
          let dstMipLevel = renderToSource ? 1 : 0;
          for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
            const dstView = mipTexture.createView({
              baseMipLevel: dstMipLevel++,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            const passEncoder = commandEncoder.beginRenderPass({
              colorAttachments: [{
                view: dstView,
                storeOp: "store",
                loadOp: "clear",
                clearValue: { r: 0, g: 0, b: 0, a: 0 }
              }]
            });
            const bindGroup = this.device.createBindGroup({
              layout: bindGroupLayout,
              entries: [{
                binding: 0,
                resource: this.sampler
              }, {
                binding: 1,
                resource: srcView
              }]
            });
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.draw(3, 1, 0, 0);
            passEncoder.end();
            srcView = dstView;
          }
        }
        if (!renderToSource) {
          const mipLevelSize = {
            width: Math.ceil(texture.width / 2),
            height: Math.ceil(texture.height / 2),
            depthOrArrayLayers: arrayLayerCount
          };
          for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
            commandEncoder.copyTextureToTexture({
              texture: mipTexture,
              mipLevel: i2 - 1
            }, {
              texture,
              mipLevel: i2
            }, mipLevelSize);
            mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
            mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
          }
        }
        this.device.queue.submit([commandEncoder.finish()]);
        if (!renderToSource) {
          mipTexture.destroy();
        }
        return texture;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
var GpuTextureSystem;
var init_GpuTextureSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
    init_adapter();
    init_Extensions();
    init_UniformGroup();
    init_CanvasPool();
    init_BindGroup();
    init_gpuUploadBufferImageResource();
    init_gpuUploadCompressedTextureResource();
    init_gpuUploadImageSource();
    init_gpuUploadVideoSource();
    init_GpuMipmapGenerator();
    GpuTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._gpuSources = /* @__PURE__ */ Object.create(null);
        this._gpuSamplers = /* @__PURE__ */ Object.create(null);
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._textureViewHash = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: gpuUploadImageResource,
          buffer: gpuUploadBufferImageResource,
          video: gpuUploadVideoResource,
          compressed: gpuUploadCompressedTextureResource
        };
        this._renderer = renderer;
        renderer.renderableGC.addManagedHash(this, "_gpuSources");
        renderer.renderableGC.addManagedHash(this, "_gpuSamplers");
        renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
        renderer.renderableGC.addManagedHash(this, "_textureViewHash");
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      /**
       * Initializes a texture source, if it has already been initialized nothing will happen.
       * @param source - The texture source to initialize.
       * @returns The initialized texture source.
       */
      initSource(source3) {
        if (this._gpuSources[source3.uid]) {
          return this._gpuSources[source3.uid];
        }
        return this._initSource(source3);
      }
      _initSource(source3) {
        if (source3.autoGenerateMipmaps) {
          const biggestDimension = Math.max(source3.pixelWidth, source3.pixelHeight);
          source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
        if (source3.uploadMethodId !== "compressed") {
          usage |= GPUTextureUsage.RENDER_ATTACHMENT;
          usage |= GPUTextureUsage.COPY_SRC;
        }
        const blockData = blockDataMap[source3.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
        const width = Math.ceil(source3.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
        const height = Math.ceil(source3.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
        const textureDescriptor = {
          label: source3.label,
          size: { width, height },
          format: source3.format,
          sampleCount: source3.sampleCount,
          mipLevelCount: source3.mipLevelCount,
          dimension: source3.dimension,
          usage
        };
        const gpuTexture = this._gpuSources[source3.uid] = this._gpu.device.createTexture(textureDescriptor);
        if (!this.managedTextures.includes(source3)) {
          source3.on("update", this.onSourceUpdate, this);
          source3.on("resize", this.onSourceResize, this);
          source3.on("destroy", this.onSourceDestroy, this);
          source3.on("unload", this.onSourceUnload, this);
          source3.on("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.push(source3);
        }
        this.onSourceUpdate(source3);
        return gpuTexture;
      }
      onSourceUpdate(source3) {
        const gpuTexture = this.getGpuSource(source3);
        if (!gpuTexture)
          return;
        if (this._uploads[source3.uploadMethodId]) {
          this._uploads[source3.uploadMethodId].upload(source3, gpuTexture, this._gpu);
        }
        if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
          this.onUpdateMipmaps(source3);
        }
      }
      onSourceUnload(source3) {
        const gpuTexture = this._gpuSources[source3.uid];
        if (gpuTexture) {
          this._gpuSources[source3.uid] = null;
          gpuTexture.destroy();
        }
      }
      onUpdateMipmaps(source3) {
        if (!this._mipmapGenerator) {
          this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
        }
        const gpuTexture = this.getGpuSource(source3);
        this._mipmapGenerator.generateMipmap(gpuTexture);
      }
      onSourceDestroy(source3) {
        source3.off("update", this.onSourceUpdate, this);
        source3.off("unload", this.onSourceUnload, this);
        source3.off("destroy", this.onSourceDestroy, this);
        source3.off("resize", this.onSourceResize, this);
        source3.off("updateMipmaps", this.onUpdateMipmaps, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
        this.onSourceUnload(source3);
      }
      onSourceResize(source3) {
        const gpuTexture = this._gpuSources[source3.uid];
        if (!gpuTexture) {
          this.initSource(source3);
        } else if (gpuTexture.width !== source3.pixelWidth || gpuTexture.height !== source3.pixelHeight) {
          this._textureViewHash[source3.uid] = null;
          this._bindGroupHash[source3.uid] = null;
          this.onSourceUnload(source3);
          this.initSource(source3);
        }
      }
      _initSampler(sampler) {
        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
        return this._gpuSamplers[sampler._resourceId];
      }
      getGpuSampler(sampler) {
        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
      }
      getGpuSource(source3) {
        return this._gpuSources[source3.uid] || this.initSource(source3);
      }
      /**
       * this returns s bind group for a specific texture, the bind group contains
       * - the texture source
       * - the texture style
       * - the texture matrix
       * This is cached so the bind group should only be created once per texture
       * @param texture - the texture you want the bindgroup for
       * @returns the bind group for the texture
       */
      getTextureBindGroup(texture) {
        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
      }
      _createTextureBindGroup(texture) {
        const source3 = texture.source;
        this._bindGroupHash[texture.uid] = new BindGroup({
          0: source3,
          1: source3.style,
          2: new UniformGroup({
            uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
          })
        });
        return this._bindGroupHash[texture.uid];
      }
      getTextureView(texture) {
        const source3 = texture.source;
        return this._textureViewHash[source3.uid] ?? this._createTextureView(source3);
      }
      _createTextureView(texture) {
        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
        return this._textureViewHash[texture.uid];
      }
      generateCanvas(texture) {
        const renderer = this._renderer;
        const commandEncoder = renderer.gpu.device.createCommandEncoder();
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = texture.source.pixelWidth;
        canvas.height = texture.source.pixelHeight;
        const context2 = canvas.getContext("webgpu");
        context2.configure({
          device: renderer.gpu.device,
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
          format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
          alphaMode: "premultiplied"
        });
        commandEncoder.copyTextureToTexture({
          texture: renderer.texture.getGpuSource(texture.source),
          origin: {
            x: 0,
            y: 0
          }
        }, {
          texture: context2.getCurrentTexture()
        }, {
          width: canvas.width,
          height: canvas.height
        });
        renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        return canvas;
      }
      getPixels(texture) {
        const webGPUCanvas = this.generateCanvas(texture);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
        const context2 = canvasAndContext.context;
        context2.drawImage(webGPUCanvas, 0, 0);
        const { width, height } = webGPUCanvas;
        const imageData = context2.getImageData(0, 0, width, height);
        const pixels = new Uint8ClampedArray(imageData.data.buffer);
        CanvasPool.returnCanvasAndContext(canvasAndContext);
        return { pixels, width, height };
      }
      destroy() {
        this.managedTextures.slice().forEach((source3) => this.onSourceDestroy(source3));
        this.managedTextures = null;
        for (const k2 of Object.keys(this._bindGroupHash)) {
          const key = Number(k2);
          const bindGroup = this._bindGroupHash[key];
          bindGroup?.destroy();
          this._bindGroupHash[key] = null;
        }
        this._gpu = null;
        this._mipmapGenerator = null;
        this._gpuSources = null;
        this._bindGroupHash = null;
        this._textureViewHash = null;
        this._gpuSamplers = null;
      }
    };
    GpuTextureSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "texture"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
var WebGPURenderer_exports = {};
__export(WebGPURenderer_exports, {
  WebGPURenderer: () => WebGPURenderer
});
var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
var init_WebGPURenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
    init_Extensions();
    init_GpuGraphicsAdaptor();
    init_GpuMeshAdapter();
    init_GpuBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types2();
    init_BindGroupSystem();
    init_GpuBufferSystem();
    init_GpuColorMaskSystem();
    init_GpuDeviceSystem();
    init_GpuEncoderSystem();
    init_GpuLimitsSystem();
    init_GpuStencilSystem();
    init_GpuUboSystem();
    init_GpuUniformBatchPipe();
    init_PipelineSystem();
    init_GpuRenderTargetSystem();
    init_GpuShaderSystem();
    init_GpuStateSystem();
    init_GpuTextureSystem();
    DefaultWebGPUSystems = [
      ...SharedSystems,
      GpuUboSystem,
      GpuEncoderSystem,
      GpuDeviceSystem,
      GpuLimitsSystem,
      GpuBufferSystem,
      GpuTextureSystem,
      GpuRenderTargetSystem,
      GpuShaderSystem,
      GpuStateSystem,
      PipelineSystem,
      GpuColorMaskSystem,
      GpuStencilSystem,
      BindGroupSystem
    ];
    DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
    DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
    systems = [];
    renderPipes = [];
    renderPipeAdaptors = [];
    extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
    extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
    extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
    extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
    WebGPURenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgpu",
          type: RendererType.WEBGPU,
          systems,
          renderPipes,
          renderPipeAdaptors
        };
        super(systemConfig);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
var GlGraphicsAdaptor;
var init_GlGraphicsAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_getBatchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    GlGraphicsAdaptor = class {
      contextChange(renderer) {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        const maxTextures = renderer.limits.maxBatchableTextures;
        const glProgram3 = compileHighShaderGlProgram({
          name: "graphics",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(maxTextures),
            localUniformBitGl,
            roundPixelsBitGl
          ]
        });
        this.shader = new Shader({
          glProgram: glProgram3,
          resources: {
            localUniforms: uniforms,
            batchSamplers: getBatchSamplersUniformGroup(maxTextures)
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context2 = renderable.context;
        const shader = context2.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          batcher,
          instructions
        } = contextSystem.getContextRenderData(context2);
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        renderer.state.set(graphicsPipe.state);
        renderer.shader.bind(shader);
        renderer.geometry.bind(batcher.geometry, shader.glProgram);
        const batches = instructions.instructions;
        for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
          const batch = batches[i2];
          if (batch.size) {
            for (let j2 = 0; j2 < batch.textures.count; j2++) {
              renderer.texture.bind(batch.textures.textures[j2], j2);
            }
            renderer.geometry.draw(batch.topology, batch.size, batch.start);
          }
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GlGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
var GlMeshAdaptor;
var init_GlMeshAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    init_warn();
    GlMeshAdaptor = class {
      init() {
        const glProgram3 = compileHighShaderGlProgram({
          name: "mesh",
          bits: [
            localUniformBitGl,
            textureBitGl,
            roundPixelsBitGl
          ]
        });
        this._shader = new Shader({
          glProgram: glProgram3,
          resources: {
            uTexture: Texture.EMPTY.source,
            textureUniforms: {
              uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
            }
          }
        });
      }
      execute(meshPipe, mesh) {
        const renderer = meshPipe.renderer;
        let shader = mesh._shader;
        if (!shader) {
          shader = this._shader;
          const texture = mesh.texture;
          const source3 = texture.source;
          shader.resources.uTexture = source3;
          shader.resources.uSampler = source3.style;
          shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
        } else if (!shader.glProgram) {
          warn("Mesh shader has no glProgram", mesh.shader);
          return;
        }
        shader.groups[100] = renderer.globalUniforms.bindGroup;
        shader.groups[101] = meshPipe.localUniformsBindGroup;
        renderer.encoder.draw({
          geometry: mesh._geometry,
          shader,
          state: mesh.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GlMeshAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
var GlBatchAdaptor;
var init_GlBatchAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
    init_Extensions();
    init_State();
    GlBatchAdaptor = class {
      constructor() {
        this._tempState = State.for2d();
        this._didUploadHash = {};
      }
      init(batcherPipe) {
        batcherPipe.renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._didUploadHash = {};
      }
      start(batchPipe, geometry, shader) {
        const renderer = batchPipe.renderer;
        const didUpload = this._didUploadHash[shader.uid];
        renderer.shader.bind(shader, didUpload);
        if (!didUpload) {
          this._didUploadHash[shader.uid] = true;
        }
        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
        renderer.geometry.bind(geometry, shader.glProgram);
      }
      execute(batchPipe, batch) {
        const renderer = batchPipe.renderer;
        this._tempState.blendMode = batch.blendMode;
        renderer.state.set(this._tempState);
        const textures = batch.textures.textures;
        for (let i2 = 0; i2 < batch.textures.count; i2++) {
          renderer.texture.bind(textures[i2], i2);
        }
        renderer.geometry.draw(batch.topology, batch.size, batch.start);
      }
    };
    GlBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
var BUFFER_TYPE;
var init_const9 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
    "use strict";
    BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
      BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
      return BUFFER_TYPE2;
    })(BUFFER_TYPE || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
var GlBuffer;
var init_GlBuffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
    "use strict";
    GlBuffer = class {
      constructor(buffer, type) {
        this._lastBindBaseLocation = -1;
        this._lastBindCallId = -1;
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.type = type;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
var GlBufferSystem;
var init_GlBufferSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
    init_Extensions();
    init_const4();
    init_const9();
    init_GlBuffer();
    GlBufferSystem = class {
      /**
       * @param {Renderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._boundBufferBases = /* @__PURE__ */ Object.create(null);
        this._minBaseLocation = 0;
        this._nextBindBaseIndex = this._minBaseLocation;
        this._bindCallId = 0;
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
      }
      /** @ignore */
      destroy() {
        this._renderer = null;
        this._gl = null;
        this._gpuBuffers = null;
        this._boundBufferBases = null;
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        this._gl = this._renderer.gl;
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._maxBindings = this._renderer.limits.maxUniformBindings;
      }
      getGlBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
      }
      /**
       * This binds specified buffer. On first run, it will create the webGL buffers for the context too
       * @param buffer - the buffer to bind to the renderer
       */
      bind(buffer) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
      }
      /**
       * Binds an uniform buffer to at the given index.
       *
       * A cache is used so a buffer will not be bound again if already bound.
       * @param glBuffer - the buffer to bind
       * @param index - the base index to bind it to.
       */
      bindBufferBase(glBuffer, index) {
        const { _gl: gl } = this;
        if (this._boundBufferBases[index] !== glBuffer) {
          this._boundBufferBases[index] = glBuffer;
          glBuffer._lastBindBaseLocation = index;
          gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
        }
      }
      nextBindBase(hasTransformFeedback) {
        this._bindCallId++;
        this._minBaseLocation = 0;
        if (hasTransformFeedback) {
          this._boundBufferBases[0] = null;
          this._minBaseLocation = 1;
          if (this._nextBindBaseIndex < 1) {
            this._nextBindBaseIndex = 1;
          }
        }
      }
      freeLocationForBufferBase(glBuffer) {
        let freeIndex = this.getLastBindBaseLocation(glBuffer);
        if (freeIndex >= this._minBaseLocation) {
          glBuffer._lastBindCallId = this._bindCallId;
          return freeIndex;
        }
        let loop = 0;
        let nextIndex = this._nextBindBaseIndex;
        while (loop < 2) {
          if (nextIndex >= this._maxBindings) {
            nextIndex = this._minBaseLocation;
            loop++;
          }
          const curBuf = this._boundBufferBases[nextIndex];
          if (curBuf && curBuf._lastBindCallId === this._bindCallId) {
            nextIndex++;
            continue;
          }
          break;
        }
        freeIndex = nextIndex;
        this._nextBindBaseIndex = nextIndex + 1;
        if (loop >= 2) {
          return -1;
        }
        glBuffer._lastBindCallId = this._bindCallId;
        this._boundBufferBases[freeIndex] = null;
        return freeIndex;
      }
      getLastBindBaseLocation(glBuffer) {
        const index = glBuffer._lastBindBaseLocation;
        if (this._boundBufferBases[index] === glBuffer) {
          return index;
        }
        return -1;
      }
      /**
       * Binds a buffer whilst also binding its range.
       * This will make the buffer start from the offset supplied rather than 0 when it is read.
       * @param glBuffer - the buffer to bind
       * @param index - the base index to bind at, defaults to 0
       * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
       * @param size - the size to bind at (this is blocks of 256).
       */
      bindBufferRange(glBuffer, index, offset, size) {
        const { _gl: gl } = this;
        offset || (offset = 0);
        index || (index = 0);
        this._boundBufferBases[index] = null;
        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);
      }
      /**
       * Will ensure the data in the buffer is uploaded to the GPU.
       * @param {Buffer} buffer - the buffer to update
       */
      updateBuffer(buffer) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        if (buffer._updateID === glBuffer.updateID) {
          return glBuffer;
        }
        glBuffer.updateID = buffer._updateID;
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        const data = buffer.data;
        const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
        if (data) {
          if (glBuffer.byteLength >= data.byteLength) {
            gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
          } else {
            glBuffer.byteLength = data.byteLength;
            gl.bufferData(glBuffer.type, data, drawType);
          }
        } else {
          glBuffer.byteLength = buffer.descriptor.size;
          gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);
        }
        return glBuffer;
      }
      /** dispose all WebGL resources of all managed buffers */
      destroyAll() {
        const gl = this._gl;
        for (const id in this._gpuBuffers) {
          gl.deleteBuffer(this._gpuBuffers[id].buffer);
        }
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Disposes buffer
       * @param {Buffer} buffer - buffer with data
       * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onBufferDestroy(buffer, contextLost) {
        const glBuffer = this._gpuBuffers[buffer.uid];
        const gl = this._gl;
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        this._gpuBuffers[buffer.uid] = null;
      }
      /**
       * creates and attaches a GLBuffer object tied to the current context.
       * @param buffer
       * @protected
       */
      createGLBuffer(buffer) {
        const { _gl: gl } = this;
        let type = BUFFER_TYPE.ARRAY_BUFFER;
        if (buffer.descriptor.usage & BufferUsage.INDEX) {
          type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
          type = BUFFER_TYPE.UNIFORM_BUFFER;
        }
        const glBuffer = new GlBuffer(gl.createBuffer(), type);
        this._gpuBuffers[buffer.uid] = glBuffer;
        buffer.on("destroy", this.onBufferDestroy, this);
        return glBuffer;
      }
      resetState() {
        this._boundBufferBases = /* @__PURE__ */ Object.create(null);
      }
    };
    GlBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "buffer"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
var _GlContextSystem, GlContextSystem;
var init_GlContextSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
    init_adapter();
    init_Extensions();
    init_warn();
    _GlContextSystem = class _GlContextSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this.supports = {
          /** Support for 32-bit indices buffer. */
          uint32Indices: true,
          /** Support for UniformBufferObjects */
          uniformBufferObject: true,
          /** Support for VertexArrayObjects */
          vertexArrayObject: true,
          /** Support for SRGB texture format */
          srgbTextures: true,
          /** Support for wrapping modes if a texture is non-power of two */
          nonPowOf2wrapping: true,
          /** Support for MSAA (antialiasing of dynamic textures) */
          msaa: true,
          /** Support for mipmaps if a texture is non-power of two */
          nonPowOf2mipmaps: true
        };
        this._renderer = renderer;
        this.extensions = /* @__PURE__ */ Object.create(null);
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
      }
      /**
       * `true` if the context is lost
       * @readonly
       */
      get isLost() {
        return !this.gl || this.gl.isContextLost();
      }
      /**
       * Handles the context change event.
       * @param {WebGLRenderingContext} gl - New WebGL context.
       */
      contextChange(gl) {
        this.gl = gl;
        this._renderer.gl = gl;
      }
      init(options) {
        options = { ..._GlContextSystem2.defaultOptions, ...options };
        let multiView = this.multiView = options.multiView;
        if (options.context && multiView) {
          warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
          multiView = false;
        }
        if (multiView) {
          this.canvas = DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
        } else {
          this.canvas = this._renderer.view.canvas;
        }
        if (options.context) {
          this.initFromContext(options.context);
        } else {
          const alpha = this._renderer.background.alpha < 1;
          const premultipliedAlpha = options.premultipliedAlpha ?? true;
          const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
          this.createContext(options.preferWebGLVersion, {
            alpha,
            premultipliedAlpha,
            antialias,
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: options.powerPreference ?? "default"
          });
        }
      }
      ensureCanvasSize(targetCanvas) {
        if (!this.multiView) {
          if (targetCanvas !== this.canvas) {
            warn("multiView is disabled, but targetCanvas is not the main canvas");
          }
          return;
        }
        const { canvas } = this;
        if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
          canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
          canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
        }
      }
      /**
       * Initializes the context.
       * @protected
       * @param {WebGLRenderingContext} gl - WebGL context
       */
      initFromContext(gl) {
        this.gl = gl;
        this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
        this.getExtensions();
        this.validateContext(gl);
        this._renderer.runners.contextChange.emit(gl);
        const element = this._renderer.view.canvas;
        element.addEventListener("webglcontextlost", this.handleContextLost, false);
        element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      /**
       * Initialize from context options
       * @protected
       * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
       * @param preferWebGLVersion
       * @param {object} options - context attributes
       */
      createContext(preferWebGLVersion, options) {
        let gl;
        const canvas = this.canvas;
        if (preferWebGLVersion === 2) {
          gl = canvas.getContext("webgl2", options);
        }
        if (!gl) {
          gl = canvas.getContext("webgl", options);
          if (!gl) {
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          }
        }
        this.gl = gl;
        this.initFromContext(this.gl);
      }
      /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
      getExtensions() {
        const { gl } = this;
        const common = {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          // eslint-disable-line camelcase
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc"),
          bptc: gl.getExtension("EXT_texture_compression_bptc"),
          rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
          loseContext: gl.getExtension("WEBGL_lose_context")
        };
        if (this.webGLVersion === 1) {
          this.extensions = {
            ...common,
            drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
            depthTexture: gl.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
            // Floats and half-floats
            floatTexture: gl.getExtension("OES_texture_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            textureHalfFloat: gl.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
            vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
            srgb: gl.getExtension("EXT_sRGB")
          };
        } else {
          this.extensions = {
            ...common,
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
          };
          const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
          if (provokeExt) {
            provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
          }
        }
      }
      /**
       * Handles a lost webgl context
       * @param {WebGLContextEvent} event - The context lost event.
       */
      handleContextLost(event) {
        event.preventDefault();
        if (this._contextLossForced) {
          this._contextLossForced = false;
          setTimeout(() => {
            if (this.gl.isContextLost()) {
              this.extensions.loseContext?.restoreContext();
            }
          }, 0);
        }
      }
      /** Handles a restored webgl context. */
      handleContextRestored() {
        this.getExtensions();
        this._renderer.runners.contextChange.emit(this.gl);
      }
      destroy() {
        const element = this._renderer.view.canvas;
        this._renderer = null;
        element.removeEventListener("webglcontextlost", this.handleContextLost);
        element.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        this.extensions.loseContext?.loseContext();
      }
      /**
       * this function can be called to force a webGL context loss
       * this will release all resources on the GPU.
       * Useful if you need to put Pixi to sleep, and save some GPU memory
       *
       * As soon as render is called - all resources will be created again.
       */
      forceContextLoss() {
        this.extensions.loseContext?.loseContext();
        this._contextLossForced = true;
      }
      /**
       * Validate context.
       * @param {WebGLRenderingContext} gl - Render context.
       */
      validateContext(gl) {
        const attributes = gl.getContextAttributes();
        if (attributes && !attributes.stencil) {
          warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        const supports = this.supports;
        const isWebGl2 = this.webGLVersion === 2;
        const extensions2 = this.extensions;
        supports.uint32Indices = isWebGl2 || !!extensions2.uint32ElementIndex;
        supports.uniformBufferObject = isWebGl2;
        supports.vertexArrayObject = isWebGl2 || !!extensions2.vertexArrayObject;
        supports.srgbTextures = isWebGl2 || !!extensions2.srgb;
        supports.nonPowOf2wrapping = isWebGl2;
        supports.nonPowOf2mipmaps = isWebGl2;
        supports.msaa = isWebGl2;
        if (!supports.uint32Indices) {
          warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
        }
      }
    };
    _GlContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "context"
    };
    _GlContextSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.context}
       * @default null
       */
      context: null,
      /**
       * {@link WebGLOptions.premultipliedAlpha}
       * @default true
       */
      premultipliedAlpha: true,
      /**
       * {@link WebGLOptions.preserveDrawingBuffer}
       * @default false
       */
      preserveDrawingBuffer: false,
      /**
       * {@link WebGLOptions.powerPreference}
       * @default default
       */
      powerPreference: void 0,
      /**
       * {@link WebGLOptions.webGLVersion}
       * @default 2
       */
      preferWebGLVersion: 2,
      /**
       * {@link WebGLOptions.multiView}
       * @default false
       */
      multiView: false
    };
    GlContextSystem = _GlContextSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
var GL_FORMATS, GL_TARGETS, GL_TYPES;
var init_const10 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
    "use strict";
    GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
      GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
      GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
      GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
      GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
      GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
      GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
      return GL_FORMATS2;
    })(GL_FORMATS || {});
    GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      return GL_TARGETS2;
    })(GL_TARGETS || {});
    GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
      GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
      GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
      GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
      GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
      GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
      GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
      GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
      return GL_TYPES2;
    })(GL_TYPES || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
function getGlTypeFromFormat(format) {
  return infoMap[format] ?? infoMap.float32;
}
var infoMap;
var init_getGlTypeFromFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs"() {
    init_const10();
    infoMap = {
      uint8x2: GL_TYPES.UNSIGNED_BYTE,
      uint8x4: GL_TYPES.UNSIGNED_BYTE,
      sint8x2: GL_TYPES.BYTE,
      sint8x4: GL_TYPES.BYTE,
      unorm8x2: GL_TYPES.UNSIGNED_BYTE,
      unorm8x4: GL_TYPES.UNSIGNED_BYTE,
      snorm8x2: GL_TYPES.BYTE,
      snorm8x4: GL_TYPES.BYTE,
      uint16x2: GL_TYPES.UNSIGNED_SHORT,
      uint16x4: GL_TYPES.UNSIGNED_SHORT,
      sint16x2: GL_TYPES.SHORT,
      sint16x4: GL_TYPES.SHORT,
      unorm16x2: GL_TYPES.UNSIGNED_SHORT,
      unorm16x4: GL_TYPES.UNSIGNED_SHORT,
      snorm16x2: GL_TYPES.SHORT,
      snorm16x4: GL_TYPES.SHORT,
      float16x2: GL_TYPES.HALF_FLOAT,
      float16x4: GL_TYPES.HALF_FLOAT,
      float32: GL_TYPES.FLOAT,
      float32x2: GL_TYPES.FLOAT,
      float32x3: GL_TYPES.FLOAT,
      float32x4: GL_TYPES.FLOAT,
      uint32: GL_TYPES.UNSIGNED_INT,
      uint32x2: GL_TYPES.UNSIGNED_INT,
      uint32x3: GL_TYPES.UNSIGNED_INT,
      uint32x4: GL_TYPES.UNSIGNED_INT,
      sint32: GL_TYPES.INT,
      sint32x2: GL_TYPES.INT,
      sint32x3: GL_TYPES.INT,
      sint32x4: GL_TYPES.INT
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
var topologyToGlMap, GlGeometrySystem;
var init_GlGeometrySystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
    init_Extensions();
    init_getAttributeInfoFromFormat();
    init_ensureAttributes();
    init_getGlTypeFromFormat();
    topologyToGlMap = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 3,
      "triangle-list": 4,
      "triangle-strip": 5
    };
    GlGeometrySystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        this._activeGeometry = null;
        this._activeVao = null;
        this.hasVao = true;
        this.hasInstance = true;
        this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        const gl = this.gl = this._renderer.gl;
        if (!this._renderer.context.supports.vertexArrayObject) {
          throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
        }
        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
        if (nativeVaoExtension) {
          gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
          gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
          gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
        }
        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
        if (nativeInstancedExtension) {
          gl.drawArraysInstanced = (a2, b2, c2, d2) => {
            nativeInstancedExtension.drawArraysInstancedANGLE(a2, b2, c2, d2);
          };
          gl.drawElementsInstanced = (a2, b2, c2, d2, e2) => {
            nativeInstancedExtension.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
          };
          gl.vertexAttribDivisor = (a2, b2) => nativeInstancedExtension.vertexAttribDivisorANGLE(a2, b2);
        }
        this._activeGeometry = null;
        this._activeVao = null;
        this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Binds geometry so that is can be drawn. Creating a Vao if required
       * @param geometry - Instance of geometry to bind.
       * @param program - Instance of program to use vao for.
       */
      bind(geometry, program) {
        const gl = this.gl;
        this._activeGeometry = geometry;
        const vao = this.getVao(geometry, program);
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          gl.bindVertexArray(vao);
        }
        this.updateBuffers();
      }
      /** Reset and unbind any active VAO and geometry. */
      resetState() {
        this.unbind();
      }
      /** Update buffers of the currently bound geometry. */
      updateBuffers() {
        const geometry = this._activeGeometry;
        const bufferSystem = this._renderer.buffer;
        for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
          const buffer = geometry.buffers[i2];
          bufferSystem.updateBuffer(buffer);
        }
      }
      /**
       * Check compatibility between a geometry and a program
       * @param geometry - Geometry instance.
       * @param program - Program instance.
       */
      checkCompatibility(geometry, program) {
        const geometryAttributes = geometry.attributes;
        const shaderAttributes = program._attributeData;
        for (const j2 in shaderAttributes) {
          if (!geometryAttributes[j2]) {
            throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
          }
        }
      }
      /**
       * Takes a geometry and program and generates a unique signature for them.
       * @param geometry - To get signature from.
       * @param program - To test geometry against.
       * @returns - Unique signature of the geometry and program
       */
      getSignature(geometry, program) {
        const attribs = geometry.attributes;
        const shaderAttributes = program._attributeData;
        const strings = ["g", geometry.uid];
        for (const i2 in attribs) {
          if (shaderAttributes[i2]) {
            strings.push(i2, shaderAttributes[i2].location);
          }
        }
        return strings.join("-");
      }
      getVao(geometry, program) {
        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
      }
      /**
       * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
       * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
       * attribute locations.
       * @param geometry - Instance of geometry to to generate Vao for.
       * @param program
       * @param _incRefCount - Increment refCount of all geometry buffers.
       */
      initGeometryVao(geometry, program, _incRefCount = true) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        this._renderer.shader._getProgramData(program);
        this.checkCompatibility(geometry, program);
        const signature = this.getSignature(geometry, program);
        if (!this._geometryVaoHash[geometry.uid]) {
          this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
          geometry.on("destroy", this.onGeometryDestroy, this);
        }
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        let vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program._key] = vao;
          return vao;
        }
        ensureAttributes(geometry, program._attributeData);
        const buffers = geometry.buffers;
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (let i2 = 0; i2 < buffers.length; i2++) {
          const buffer = buffers[i2];
          bufferSystem.bind(buffer);
        }
        this.activateVao(geometry, program);
        vaoObjectHash[program._key] = vao;
        vaoObjectHash[signature] = vao;
        gl.bindVertexArray(null);
        return vao;
      }
      /**
       * Disposes geometry.
       * @param geometry - Geometry with buffers. Only VAO will be disposed
       * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onGeometryDestroy(geometry, contextLost) {
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        const gl = this.gl;
        if (vaoObjectHash) {
          if (contextLost) {
            for (const i2 in vaoObjectHash) {
              if (this._activeVao !== vaoObjectHash[i2]) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[i2]);
            }
          }
          this._geometryVaoHash[geometry.uid] = null;
        }
      }
      /**
       * Dispose all WebGL resources of all managed geometries.
       * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
       */
      destroyAll(contextLost = false) {
        const gl = this.gl;
        for (const i2 in this._geometryVaoHash) {
          if (contextLost) {
            for (const j2 in this._geometryVaoHash[i2]) {
              const vaoObjectHash = this._geometryVaoHash[i2];
              if (this._activeVao !== vaoObjectHash) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[j2]);
            }
          }
          this._geometryVaoHash[i2] = null;
        }
      }
      /**
       * Activate vertex array object.
       * @param geometry - Geometry instance.
       * @param program - Shader program instance.
       */
      activateVao(geometry, program) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        const attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          bufferSystem.bind(geometry.indexBuffer);
        }
        let lastBuffer = null;
        for (const j2 in attributes) {
          const attribute = attributes[j2];
          const buffer = attribute.buffer;
          const glBuffer = bufferSystem.getGlBuffer(buffer);
          const programAttrib = program._attributeData[j2];
          if (programAttrib) {
            if (lastBuffer !== glBuffer) {
              bufferSystem.bind(buffer);
              lastBuffer = glBuffer;
            }
            const location = programAttrib.location;
            gl.enableVertexAttribArray(location);
            const attributeInfo = getAttributeInfoFromFormat(attribute.format);
            const type = getGlTypeFromFormat(attribute.format);
            if (programAttrib.format?.substring(1, 4) === "int") {
              gl.vertexAttribIPointer(
                location,
                attributeInfo.size,
                type,
                attribute.stride,
                attribute.offset
              );
            } else {
              gl.vertexAttribPointer(
                location,
                attributeInfo.size,
                type,
                attributeInfo.normalised,
                attribute.stride,
                attribute.offset
              );
            }
            if (attribute.instance) {
              if (this.hasInstance) {
                const divisor = attribute.divisor ?? 1;
                gl.vertexAttribDivisor(location, divisor);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      }
      /**
       * Draws the currently bound geometry.
       * @param topology - The type primitive to render.
       * @param size - The number of elements to be rendered. If not specified, all vertices after the
       *  starting vertex will be drawn.
       * @param start - The starting vertex in the geometry to start drawing from. If not specified,
       *  drawing will start from the first vertex.
       * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
       *  all instances will be drawn.
       * @returns This instance of the geometry system.
       */
      draw(topology, size, start, instanceCount) {
        const { gl } = this._renderer;
        const geometry = this._activeGeometry;
        const glTopology = topologyToGlMap[topology || geometry.topology];
        instanceCount ?? (instanceCount = geometry.instanceCount);
        if (geometry.indexBuffer) {
          const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (instanceCount !== 1) {
            gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
          } else {
            gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
          }
        } else if (instanceCount !== 1) {
          gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
        } else {
          gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
        }
        return this;
      }
      /** Unbind/reset everything. */
      unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      }
      destroy() {
        this._renderer = null;
        this.gl = null;
        this._activeVao = null;
        this._activeGeometry = null;
        this._geometryVaoHash = null;
      }
    };
    GlGeometrySystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "geometry"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
var bigTriangleGeometry, _GlBackBufferSystem, GlBackBufferSystem;
var init_GlBackBufferSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
    init_Extensions();
    init_warn();
    init_Geometry();
    init_Shader();
    init_State();
    init_TextureSource();
    init_Texture();
    init_GlProgram();
    bigTriangleGeometry = new Geometry({
      attributes: {
        aPosition: [
          -1,
          -1,
          // Bottom left corner
          3,
          -1,
          // Bottom right corner, extending beyond right edge
          -1,
          3
          // Top left corner, extending beyond top edge
        ]
      }
    });
    _GlBackBufferSystem = class _GlBackBufferSystem2 {
      constructor(renderer) {
        this.useBackBuffer = false;
        this._useBackBufferThisRender = false;
        this._renderer = renderer;
      }
      init(options = {}) {
        const { useBackBuffer, antialias } = { ..._GlBackBufferSystem2.defaultOptions, ...options };
        this.useBackBuffer = useBackBuffer;
        this._antialias = antialias;
        if (!this._renderer.context.supports.msaa) {
          warn("antialiasing, is not supported on when using the back buffer");
          this._antialias = false;
        }
        this._state = State.for2d();
        const bigTriangleProgram = new GlProgram({
          vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
          fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
          name: "big-triangle"
        });
        this._bigTriangleShader = new Shader({
          glProgram: bigTriangleProgram,
          resources: {
            uTexture: Texture.WHITE.source
          }
        });
      }
      /**
       * This is called before the RenderTargetSystem is started. This is where
       * we replace the target with the back buffer if required.
       * @param options - The options for this render.
       */
      renderStart(options) {
        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
        if (this._useBackBufferThisRender) {
          const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
          this._targetTexture = renderTarget2.colorTexture;
          options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
        }
      }
      renderEnd() {
        this._presentBackBuffer();
      }
      _presentBackBuffer() {
        const renderer = this._renderer;
        renderer.renderTarget.finishRenderPass();
        if (!this._useBackBufferThisRender)
          return;
        renderer.renderTarget.bind(this._targetTexture, false);
        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
        renderer.encoder.draw({
          geometry: bigTriangleGeometry,
          shader: this._bigTriangleShader,
          state: this._state
        });
      }
      _getBackBufferTexture(targetSourceTexture) {
        this._backBufferTexture = this._backBufferTexture || new Texture({
          source: new TextureSource({
            width: targetSourceTexture.width,
            height: targetSourceTexture.height,
            resolution: targetSourceTexture._resolution,
            antialias: this._antialias
          })
        });
        this._backBufferTexture.source.resize(
          targetSourceTexture.width,
          targetSourceTexture.height,
          targetSourceTexture._resolution
        );
        return this._backBufferTexture;
      }
      /** destroys the back buffer */
      destroy() {
        if (this._backBufferTexture) {
          this._backBufferTexture.destroy();
          this._backBufferTexture = null;
        }
      }
    };
    _GlBackBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "backBuffer",
      priority: 1
    };
    _GlBackBufferSystem.defaultOptions = {
      /** if true will use the back buffer where required */
      useBackBuffer: false
    };
    GlBackBufferSystem = _GlBackBufferSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
var GlColorMaskSystem;
var init_GlColorMaskSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
    init_Extensions();
    GlColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.gl.colorMask(
          !!(colorMask & 8),
          !!(colorMask & 4),
          !!(colorMask & 2),
          !!(colorMask & 1)
        );
      }
    };
    GlColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "colorMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
var GlEncoderSystem;
var init_GlEncoderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
    init_Extensions();
    GlEncoderSystem = class {
      constructor(renderer) {
        this.commandFinished = Promise.resolve();
        this._renderer = renderer;
      }
      setGeometry(geometry, shader) {
        this._renderer.geometry.bind(geometry, shader.glProgram);
      }
      finishRenderPass() {
      }
      draw(options) {
        const renderer = this._renderer;
        const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;
        renderer.shader.bind(shader, skipSync);
        renderer.geometry.bind(geometry, renderer.shader._activeProgram);
        if (state) {
          renderer.state.set(state);
        }
        renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);
      }
      destroy() {
        this._renderer = null;
      }
    };
    GlEncoderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "encoder"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.mjs
var GlLimitsSystem;
var init_GlLimitsSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.mjs"() {
    init_Extensions();
    init_checkMaxIfStatementsInShader();
    GlLimitsSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      contextChange() {
        const gl = this._renderer.gl;
        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.maxBatchableTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
        const isWebGl2 = this._renderer.context.webGLVersion === 2;
        this.maxUniformBindings = isWebGl2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
      }
      destroy() {
      }
    };
    GlLimitsSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "limits"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
var GlStencilSystem;
var init_GlStencilSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
    init_Extensions();
    init_GpuStencilModesToPixi();
    init_const3();
    GlStencilSystem = class {
      constructor(renderer) {
        this._stencilCache = {
          enabled: false,
          stencilReference: 0,
          stencilMode: STENCIL_MODES.NONE
        };
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      contextChange(gl) {
        this._gl = gl;
        this._comparisonFuncMapping = {
          always: gl.ALWAYS,
          never: gl.NEVER,
          equal: gl.EQUAL,
          "not-equal": gl.NOTEQUAL,
          less: gl.LESS,
          "less-equal": gl.LEQUAL,
          greater: gl.GREATER,
          "greater-equal": gl.GEQUAL
        };
        this._stencilOpsMapping = {
          keep: gl.KEEP,
          zero: gl.ZERO,
          replace: gl.REPLACE,
          invert: gl.INVERT,
          "increment-clamp": gl.INCR,
          "decrement-clamp": gl.DECR,
          "increment-wrap": gl.INCR_WRAP,
          "decrement-wrap": gl.DECR_WRAP
        };
        this.resetState();
      }
      onRenderTargetChange(renderTarget) {
        if (this._activeRenderTarget === renderTarget)
          return;
        this._activeRenderTarget = renderTarget;
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      resetState() {
        this._stencilCache.enabled = false;
        this._stencilCache.stencilMode = STENCIL_MODES.NONE;
        this._stencilCache.stencilReference = 0;
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        const gl = this._gl;
        const mode = GpuStencilModesToPixi[stencilMode];
        const _stencilCache = this._stencilCache;
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        if (stencilMode === STENCIL_MODES.DISABLED) {
          if (this._stencilCache.enabled) {
            this._stencilCache.enabled = false;
            gl.disable(gl.STENCIL_TEST);
          }
          return;
        }
        if (!this._stencilCache.enabled) {
          this._stencilCache.enabled = true;
          gl.enable(gl.STENCIL_TEST);
        }
        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
          _stencilCache.stencilMode = stencilMode;
          _stencilCache.stencilReference = stencilReference;
          gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
          gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
        }
      }
    };
    GlStencilSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "stencil"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
function createUboElementsSTD40(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  const chunkSize = 16;
  let size = 0;
  let offset = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    size = WGSL_TO_STD40_SIZE[uboElement.data.type];
    if (!size) {
      throw new Error(`Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, chunkSize) * uboElement.data.size;
    }
    const boundary = size === 12 ? 16 : size;
    uboElement.size = size;
    const curOffset = offset % chunkSize;
    if (curOffset > 0 && chunkSize - curOffset < boundary) {
      offset += (chunkSize - curOffset) % 16;
    } else {
      offset += (size - curOffset % size) % size;
    }
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_TO_STD40_SIZE;
var init_createUboElementsSTD40 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs"() {
    "use strict";
    WGSL_TO_STD40_SIZE = {
      f32: 4,
      i32: 4,
      "vec2<f32>": 8,
      "vec3<f32>": 12,
      "vec4<f32>": 16,
      "vec2<i32>": 8,
      "vec3<i32>": 12,
      "vec4<i32>": 16,
      "mat2x2<f32>": 16 * 2,
      "mat3x3<f32>": 16 * 3,
      "mat4x4<f32>": 16 * 4
      // TODO - not essential for now but support these in the future
      // int:      4,
      // ivec2:    8,
      // ivec3:    12,
      // ivec4:    16,
      // uint:     4,
      // uvec2:    8,
      // uvec3:    12,
      // uvec4:    16,
      // bool:     4,
      // bvec2:    8,
      // bvec3:    12,
      // bvec4:    16,
      // mat2:     16 * 2,
      // mat3:     16 * 3,
      // mat4:     16 * 4,
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
function generateArraySyncSTD40(uboElement, offsetToAdd) {
  const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
  const elementSize = uboElement.data.value.length / uboElement.data.size;
  const remainder = (4 - elementSize % 4) % 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                ${data}[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
}
var init_generateArraySyncSTD40 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs"() {
    init_createUboElementsSTD40();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
function createUboSyncFunctionSTD40(uboElements) {
  return createUboSyncFunction(
    uboElements,
    "uboStd40",
    generateArraySyncSTD40,
    uboSyncFunctionsSTD40
  );
}
var init_createUboSyncSTD40 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs"() {
    init_createUboSyncFunction();
    init_uboSyncFunctions();
    init_generateArraySyncSTD40();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs
var GlUboSystem;
var init_GlUboSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs"() {
    init_Extensions();
    init_UboSystem();
    init_createUboElementsSTD40();
    init_createUboSyncSTD40();
    GlUboSystem = class extends UboSystem {
      constructor() {
        super({
          createUboElements: createUboElementsSTD40,
          generateUboSync: createUboSyncFunctionSTD40
        });
      }
    };
    GlUboSystem.extension = {
      type: [ExtensionType.WebGLSystem],
      name: "ubo"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
var GlRenderTarget;
var init_GlRenderTarget = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
    "use strict";
    GlRenderTarget = class {
      constructor() {
        this.width = -1;
        this.height = -1;
        this.msaa = false;
        this.msaaRenderBuffer = [];
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
var GlRenderTargetAdaptor;
var init_GlRenderTargetAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs"() {
    init_Rectangle();
    init_warn();
    init_CanvasSource();
    init_const7();
    init_GlRenderTarget();
    GlRenderTargetAdaptor = class {
      constructor() {
        this._clearColorCache = [0, 0, 0, 0];
        this._viewPortCache = new Rectangle();
      }
      init(renderer, renderTargetSystem) {
        this._renderer = renderer;
        this._renderTargetSystem = renderTargetSystem;
        renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._clearColorCache = [0, 0, 0, 0];
        this._viewPortCache = new Rectangle();
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
        const renderTargetSystem = this._renderTargetSystem;
        const renderer = this._renderer;
        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
        const gl = renderer.gl;
        this.finishRenderPass(sourceRenderSurfaceTexture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        renderer.texture.bind(destinationTexture, 0);
        gl.copyTexSubImage2D(
          gl.TEXTURE_2D,
          0,
          originDest.x,
          originDest.y,
          originSrc.x,
          originSrc.y,
          size.width,
          size.height
        );
        return destinationTexture;
      }
      startRenderPass(renderTarget, clear = true, clearColor, viewport) {
        const renderTargetSystem = this._renderTargetSystem;
        const source3 = renderTarget.colorTexture;
        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        let viewPortY = viewport.y;
        if (renderTarget.isRoot) {
          viewPortY = source3.pixelHeight - viewport.height;
        }
        renderTarget.colorTextures.forEach((texture) => {
          this._renderer.texture.unbind(texture);
        });
        const gl = this._renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
        const viewPortCache = this._viewPortCache;
        if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
          viewPortCache.x = viewport.x;
          viewPortCache.y = viewPortY;
          viewPortCache.width = viewport.width;
          viewPortCache.height = viewport.height;
          gl.viewport(
            viewport.x,
            viewPortY,
            viewport.width,
            viewport.height
          );
        }
        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
          this._initStencil(gpuRenderTarget);
        }
        this.clear(renderTarget, clear, clearColor);
      }
      finishRenderPass(renderTarget) {
        const renderTargetSystem = this._renderTargetSystem;
        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        if (!glRenderTarget.msaa)
          return;
        const gl = this._renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
        gl.blitFramebuffer(
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          gl.COLOR_BUFFER_BIT,
          gl.NEAREST
        );
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
      }
      initGpuRenderTarget(renderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const glRenderTarget = new GlRenderTarget();
        const colorTexture = renderTarget.colorTexture;
        if (colorTexture instanceof CanvasSource) {
          this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
          glRenderTarget.framebuffer = null;
          return glRenderTarget;
        }
        this._initColor(renderTarget, glRenderTarget);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return glRenderTarget;
      }
      destroyGpuRenderTarget(gpuRenderTarget) {
        const gl = this._renderer.gl;
        if (gpuRenderTarget.framebuffer) {
          gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
          gpuRenderTarget.framebuffer = null;
        }
        if (gpuRenderTarget.resolveTargetFramebuffer) {
          gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
          gpuRenderTarget.resolveTargetFramebuffer = null;
        }
        if (gpuRenderTarget.depthStencilRenderBuffer) {
          gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
          gpuRenderTarget.depthStencilRenderBuffer = null;
        }
        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
          gl.deleteRenderbuffer(renderBuffer);
        });
        gpuRenderTarget.msaaRenderBuffer = null;
      }
      clear(_renderTarget, clear, clearColor) {
        if (!clear)
          return;
        const renderTargetSystem = this._renderTargetSystem;
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const gl = this._renderer.gl;
        if (clear & CLEAR.COLOR) {
          clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
          const clearColorCache = this._clearColorCache;
          const clearColorArray = clearColor;
          if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
            clearColorCache[0] = clearColorArray[0];
            clearColorCache[1] = clearColorArray[1];
            clearColorCache[2] = clearColorArray[2];
            clearColorCache[3] = clearColorArray[3];
            gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
          }
        }
        gl.clear(clear);
      }
      resizeGpuRenderTarget(renderTarget) {
        if (renderTarget.isRoot)
          return;
        const renderTargetSystem = this._renderTargetSystem;
        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        this._resizeColor(renderTarget, glRenderTarget);
        if (renderTarget.stencil || renderTarget.depth) {
          this._resizeStencil(glRenderTarget);
        }
      }
      _initColor(renderTarget, glRenderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const resolveTargetFramebuffer = gl.createFramebuffer();
        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          const source3 = colorTexture.source;
          if (source3.antialias) {
            if (renderer.context.supports.msaa) {
              glRenderTarget.msaa = true;
            } else {
              warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
            }
          }
          renderer.texture.bindSource(source3, 0);
          const glSource = renderer.texture.getGlSource(source3);
          const glTexture = glSource.texture;
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0 + i2,
            3553,
            // texture.target,
            glTexture,
            0
          );
        });
        if (glRenderTarget.msaa) {
          const viewFramebuffer = gl.createFramebuffer();
          glRenderTarget.framebuffer = viewFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((_, i2) => {
            const msaaRenderBuffer = gl.createRenderbuffer();
            glRenderTarget.msaaRenderBuffer[i2] = msaaRenderBuffer;
          });
        } else {
          glRenderTarget.framebuffer = resolveTargetFramebuffer;
        }
        this._resizeColor(renderTarget, glRenderTarget);
      }
      _resizeColor(renderTarget, glRenderTarget) {
        const source3 = renderTarget.colorTexture.source;
        glRenderTarget.width = source3.pixelWidth;
        glRenderTarget.height = source3.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          if (i2 === 0)
            return;
          colorTexture.source.resize(source3.width, source3.height, source3._resolution);
        });
        if (glRenderTarget.msaa) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const viewFramebuffer = glRenderTarget.framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const source22 = colorTexture.source;
            renderer.texture.bindSource(source22, 0);
            const glSource = renderer.texture.getGlSource(source22);
            const glInternalFormat = glSource.internalFormat;
            const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i2];
            gl.bindRenderbuffer(
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              glInternalFormat,
              source22.pixelWidth,
              source22.pixelHeight
            );
            gl.framebufferRenderbuffer(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
          });
        }
      }
      _initStencil(glRenderTarget) {
        if (glRenderTarget.framebuffer === null)
          return;
        const gl = this._renderer.gl;
        const depthStencilRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          gl.DEPTH_STENCIL_ATTACHMENT,
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
        this._resizeStencil(glRenderTarget);
      }
      _resizeStencil(glRenderTarget) {
        const gl = this._renderer.gl;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          glRenderTarget.depthStencilRenderBuffer
        );
        if (glRenderTarget.msaa) {
          gl.renderbufferStorageMultisample(
            gl.RENDERBUFFER,
            4,
            gl.DEPTH24_STENCIL8,
            glRenderTarget.width,
            glRenderTarget.height
          );
        } else {
          gl.renderbufferStorage(
            gl.RENDERBUFFER,
            this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
            glRenderTarget.width,
            glRenderTarget.height
          );
        }
      }
      prerender(renderTarget) {
        const resource = renderTarget.colorTexture.resource;
        if (this._renderer.context.multiView && CanvasSource.test(resource)) {
          this._renderer.context.ensureCanvasSize(resource);
        }
      }
      postrender(renderTarget) {
        if (!this._renderer.context.multiView)
          return;
        if (CanvasSource.test(renderTarget.colorTexture.resource)) {
          const contextCanvas = this._renderer.context.canvas;
          const canvasSource = renderTarget.colorTexture;
          canvasSource.context2D.drawImage(
            contextCanvas,
            0,
            canvasSource.pixelHeight - contextCanvas.height
          );
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
var GlRenderTargetSystem;
var init_GlRenderTargetSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs"() {
    init_Extensions();
    init_RenderTargetSystem();
    init_GlRenderTargetAdaptor();
    GlRenderTargetSystem = class extends RenderTargetSystem {
      constructor(renderer) {
        super(renderer);
        this.adaptor = new GlRenderTargetAdaptor();
        this.adaptor.init(renderer, this);
      }
    };
    GlRenderTargetSystem.extension = {
      type: [ExtensionType.WebGLSystem],
      name: "renderTarget"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
function generateShaderSyncCode(shader, shaderSystem) {
  const funcFragments = [];
  const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
  let addedTextreSystem = false;
  let textureCount = 0;
  const programData = shaderSystem._getProgramData(shader.glProgram);
  for (const i2 in shader.groups) {
    const group = shader.groups[i2];
    funcFragments.push(`
            resources = g[${i2}].resources;
        `);
    for (const j2 in group.resources) {
      const resource = group.resources[j2];
      if (resource instanceof UniformGroup) {
        if (resource.ubo) {
          const resName = shader._uniformBindMap[i2][Number(j2)];
          funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j2}],
                            '${resName}',
                            ${shader.glProgram._uniformBlockData[resName].index}
                        );
                    `);
        } else {
          funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j2}], p, sD);
                    `);
        }
      } else if (resource instanceof BufferResource) {
        const resName = shader._uniformBindMap[i2][Number(j2)];
        funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j2}],
                        '${resName}',
                        ${shader.glProgram._uniformBlockData[resName].index}
                    );
                `);
      } else if (resource instanceof TextureSource) {
        const uniformName = shader._uniformBindMap[i2][j2];
        const uniformData = programData.uniformData[uniformName];
        if (uniformData) {
          if (!addedTextreSystem) {
            addedTextreSystem = true;
            headerFragments.push(`
                        var tS = r.texture;
                        `);
          }
          shaderSystem._gl.uniform1i(uniformData.location, textureCount);
          funcFragments.push(`
                        tS.bind(resources[${j2}], ${textureCount});
                    `);
          textureCount++;
        }
      }
    }
  }
  const functionSource = [...headerFragments, ...funcFragments].join("\n");
  return new Function("r", "s", "sD", functionSource);
}
var init_GenerateShaderSyncCode = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs"() {
    init_BufferResource();
    init_UniformGroup();
    init_TextureSource();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
var GlProgramData;
var init_GlProgramData = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
    "use strict";
    GlProgramData = class {
      /**
       * Makes a new Pixi program.
       * @param program - webgl program
       * @param uniformData - uniforms
       */
      constructor(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
        this.uniformDirtyGroups = {};
        this.uniformBlockBindings = {};
      }
      /** Destroys this program. */
      destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.uniformDirtyGroups = null;
        this.uniformBlockBindings = null;
        this.program = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
var init_compileShader = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
function booleanArray(size) {
  const array = new Array(size);
  for (let i2 = 0; i2 < array.length; i2++) {
    array[i2] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultValue = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i2 = 0; i2 < typeNames.length; ++i2) {
      const tn = typeNames[i2];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
function mapGlToVertexFormat(gl, type) {
  const typeValue = mapType(gl, type);
  return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
}
var GL_TABLE, GL_TO_GLSL_TYPES, GLSL_TO_VERTEX_TYPES;
var init_mapType = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
    "use strict";
    GL_TABLE = null;
    GL_TO_GLSL_TYPES = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      UNSIGNED_INT: "uint",
      UNSIGNED_INT_VEC2: "uvec2",
      UNSIGNED_INT_VEC3: "uvec3",
      UNSIGNED_INT_VEC4: "uvec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };
    GLSL_TO_VERTEX_TYPES = {
      float: "float32",
      vec2: "float32x2",
      vec3: "float32x3",
      vec4: "float32x4",
      int: "sint32",
      ivec2: "sint32x2",
      ivec3: "sint32x3",
      ivec4: "sint32x4",
      uint: "uint32",
      uvec2: "uint32x2",
      uvec3: "uint32x3",
      uvec4: "uint32x4",
      bool: "uint32",
      bvec2: "uint32x2",
      bvec3: "uint32x3",
      bvec4: "uint32x4"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < totalAttributes; i2++) {
    const attribData = gl.getActiveAttrib(program, i2);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const format = mapGlToVertexFormat(gl, attribData.type);
    attributes[attribData.name] = {
      location: 0,
      // set further down..
      format,
      stride: getAttributeInfoFromFormat(format).stride,
      offset: 0,
      instance: false,
      start: 0
    };
  }
  const keys = Object.keys(attributes);
  if (sortAttributes) {
    keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
    for (let i2 = 0; i2 < keys.length; i2++) {
      attributes[keys[i2]].location = i2;
      gl.bindAttribLocation(program, i2, keys[i2]);
    }
    gl.linkProgram(program);
  } else {
    for (let i2 = 0; i2 < keys.length; i2++) {
      attributes[keys[i2]].location = gl.getAttribLocation(program, keys[i2]);
    }
  }
  return attributes;
}
var init_extractAttributesFromGlProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs"() {
    init_getAttributeInfoFromFormat();
    init_mapType();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs
function getUboData(program, gl) {
  if (!gl.ACTIVE_UNIFORM_BLOCKS)
    return {};
  const uniformBlocks = {};
  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let i2 = 0; i2 < totalUniformsBlocks; i2++) {
    const name = gl.getActiveUniformBlockName(program, i2);
    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
    const size = gl.getActiveUniformBlockParameter(program, i2, gl.UNIFORM_BLOCK_DATA_SIZE);
    uniformBlocks[name] = {
      name,
      index: uniformBlockIndex,
      size
    };
  }
  return uniformBlocks;
}
var init_getUboData = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i2 = 0; i2 < totalUniforms; i2++) {
    const uniformData = gl.getActiveUniform(program, i2);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i2,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
var init_getUniformData = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
    init_defaultValue();
    init_mapType();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
var init_logProgramError = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
function generateProgram(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(
        webGLProgram,
        transformFeedbackVaryings.names,
        transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
      );
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program._attributeData = extractAttributesFromGlProgram(
    webGLProgram,
    gl,
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
  );
  program._uniformData = getUniformData(webGLProgram, gl);
  program._uniformBlockData = getUboData(webGLProgram, gl);
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i2 in program._uniformData) {
    const data = program._uniformData[i2];
    uniformData[i2] = {
      location: gl.getUniformLocation(webGLProgram, i2),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram3 = new GlProgramData(webGLProgram, uniformData);
  return glProgram3;
}
var init_generateProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
    init_warn();
    init_GlProgramData();
    init_compileShader();
    init_defaultValue();
    init_extractAttributesFromGlProgram();
    init_getUboData();
    init_getUniformData();
    init_logProgramError();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
var defaultSyncData, GlShaderSystem;
var init_GlShaderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
    init_Extensions();
    init_GenerateShaderSyncCode();
    init_generateProgram();
    defaultSyncData = {
      textureCount: 0,
      blockIndex: 0
    };
    GlShaderSystem = class {
      constructor(renderer) {
        this._activeProgram = null;
        this._programDataHash = /* @__PURE__ */ Object.create(null);
        this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
      }
      contextChange(gl) {
        this._gl = gl;
        this._programDataHash = /* @__PURE__ */ Object.create(null);
        this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
        this._activeProgram = null;
      }
      /**
       * Changes the current shader to the one given in parameter.
       * @param shader - the new shader
       * @param skipSync - false if the shader should automatically sync its uniforms.
       * @returns the glProgram that belongs to the shader.
       */
      bind(shader, skipSync) {
        this._setProgram(shader.glProgram);
        if (skipSync)
          return;
        defaultSyncData.textureCount = 0;
        defaultSyncData.blockIndex = 0;
        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
        if (!syncFunction) {
          syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
        }
        this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);
        syncFunction(this._renderer, shader, defaultSyncData);
      }
      /**
       * Updates the uniform group.
       * @param uniformGroup - the uniform group to update
       */
      updateUniformGroup(uniformGroup) {
        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
      }
      /**
       * Binds a uniform block to the shader.
       * @param uniformGroup - the uniform group to bind
       * @param name - the name of the uniform block
       * @param index - the index of the uniform block
       */
      bindUniformBlock(uniformGroup, name, index = 0) {
        const bufferSystem = this._renderer.buffer;
        const programData = this._getProgramData(this._activeProgram);
        const isBufferResource = uniformGroup._bufferResource;
        if (!isBufferResource) {
          this._renderer.ubo.updateUniformGroup(uniformGroup);
        }
        const buffer = uniformGroup.buffer;
        const glBuffer = bufferSystem.updateBuffer(buffer);
        const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);
        if (isBufferResource) {
          const { offset, size } = uniformGroup;
          if (offset === 0 && size === buffer.data.byteLength) {
            bufferSystem.bindBufferBase(glBuffer, boundLocation);
          } else {
            bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);
          }
        } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {
          bufferSystem.bindBufferBase(glBuffer, boundLocation);
        }
        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
        if (programData.uniformBlockBindings[index] === boundLocation)
          return;
        programData.uniformBlockBindings[index] = boundLocation;
        this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);
      }
      _setProgram(program) {
        if (this._activeProgram === program)
          return;
        this._activeProgram = program;
        const programData = this._getProgramData(program);
        this._gl.useProgram(programData.program);
      }
      /**
       * @param program - the program to get the data for
       * @internal
       */
      _getProgramData(program) {
        return this._programDataHash[program._key] || this._createProgramData(program);
      }
      _createProgramData(program) {
        const key = program._key;
        this._programDataHash[key] = generateProgram(this._gl, program);
        return this._programDataHash[key];
      }
      destroy() {
        for (const key of Object.keys(this._programDataHash)) {
          const programData = this._programDataHash[key];
          programData.destroy();
          this._programDataHash[key] = null;
        }
        this._programDataHash = null;
        this._shaderSyncFunctions = null;
        this._activeProgram = null;
        this._renderer = null;
        this._gl = null;
      }
      /**
       * Creates a function that can be executed that will sync the shader as efficiently as possible.
       * Overridden by the unsafe eval package if you don't want eval used in your project.
       * @param shader - the shader to generate the sync function for
       * @param shaderSystem - the shader system to use
       * @returns - the generated sync function
       * @ignore
       */
      _generateShaderSync(shader, shaderSystem) {
        return generateShaderSyncCode(shader, shaderSystem);
      }
      resetState() {
        this._activeProgram = null;
      }
    };
    GlShaderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "shader"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
var UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS;
var init_generateUniformsSyncTypes = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs"() {
    "use strict";
    UNIFORM_TO_SINGLE_SETTERS = {
      f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
      "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
      "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
      "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
      i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
      "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
      "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
      "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
      u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
      "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
      "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
      "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
      bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
      "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
      "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
      "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
      "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
      "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
      "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
    };
    UNIFORM_TO_ARRAY_SETTERS = {
      f32: `gl.uniform1fv(location, v);`,
      "vec2<f32>": `gl.uniform2fv(location, v);`,
      "vec3<f32>": `gl.uniform3fv(location, v);`,
      "vec4<f32>": `gl.uniform4fv(location, v);`,
      "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
      "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
      "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
      i32: `gl.uniform1iv(location, v);`,
      "vec2<i32>": `gl.uniform2iv(location, v);`,
      "vec3<i32>": `gl.uniform3iv(location, v);`,
      "vec4<i32>": `gl.uniform4iv(location, v);`,
      u32: `gl.uniform1iv(location, v);`,
      "vec2<u32>": `gl.uniform2iv(location, v);`,
      "vec3<u32>": `gl.uniform3iv(location, v);`,
      "vec4<u32>": `gl.uniform4iv(location, v);`,
      bool: `gl.uniform1iv(location, v);`,
      "vec2<bool>": `gl.uniform2iv(location, v);`,
      "vec3<bool>": `gl.uniform3iv(location, v);`,
      "vec4<bool>": `gl.uniform4iv(location, v);`
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
  for (const i2 in group.uniforms) {
    if (!uniformData[i2]) {
      if (group.uniforms[i2] instanceof UniformGroup) {
        if (group.uniforms[i2].ubo) {
          funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i2}, "${i2}");
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i2});
                    `);
        }
      } else if (group.uniforms[i2] instanceof BufferResource) {
        funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i2}, "${i2}");
                    `);
      }
      continue;
    }
    const uniform = group.uniformStructures[i2];
    let parsed = false;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      const parser = uniformParsers[j2];
      if (uniform.type === parser.type && parser.test(uniform)) {
        funcFragments.push(`name = "${i2}";`, uniformParsers[j2].uniform);
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
      const template = templateType[uniform.type].replace("location", `ud["${i2}"].location`);
      funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var init_generateUniformsSync = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs"() {
    init_BufferResource();
    init_UniformGroup();
    init_uniformParsers();
    init_generateUniformsSyncTypes();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
var GlUniformGroupSystem;
var init_GlUniformGroupSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
    init_Extensions();
    init_generateUniformsSync();
    GlUniformGroupSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._cache = {};
        this._uniformGroupSyncHash = {};
        this._renderer = renderer;
        this.gl = null;
        this._cache = {};
      }
      contextChange(gl) {
        this.gl = gl;
      }
      /**
       * Uploads the uniforms values to the currently bound shader.
       * @param group - the uniforms values that be applied to the current shader
       * @param program
       * @param syncData
       * @param syncData.textureCount
       */
      updateUniformGroup(group, program, syncData) {
        const programData = this._renderer.shader._getProgramData(program);
        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
          programData.uniformDirtyGroups[group.uid] = group._dirtyId;
          const syncFunc = this._getUniformSyncFunction(group, program);
          syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
        }
      }
      /**
       * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
       * @param group
       * @param program
       */
      _getUniformSyncFunction(group, program) {
        return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
      }
      _createUniformSyncFunction(group, program) {
        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
        const id = this._getSignature(group, program._uniformData, "u");
        if (!this._cache[id]) {
          this._cache[id] = this._generateUniformsSync(group, program._uniformData);
        }
        uniformGroupSyncHash[program._key] = this._cache[id];
        return uniformGroupSyncHash[program._key];
      }
      _generateUniformsSync(group, uniformData) {
        return generateUniformsSync(group, uniformData);
      }
      /**
       * Takes a uniform group and data and generates a unique signature for them.
       * @param group - The uniform group to get signature of
       * @param group.uniforms
       * @param uniformData - Uniform information generated by the shader
       * @param preFix
       * @returns Unique signature of the uniform group
       */
      _getSignature(group, uniformData, preFix) {
        const uniforms = group.uniforms;
        const strings = [`${preFix}-`];
        for (const i2 in uniforms) {
          strings.push(i2);
          if (uniformData[i2]) {
            strings.push(uniformData[i2].type);
          }
        }
        return strings.join("-");
      }
      /** Destroys this System and removes all its textures. */
      destroy() {
        this._renderer = null;
        this._cache = null;
      }
    };
    GlUniformGroupSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "uniformGroup"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
function mapWebGLBlendModesToPixi(gl) {
  const blendMap = {};
  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.add = [gl.ONE, gl.ONE];
  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.none = [0, 0];
  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
  if (isWebGl2) {
    blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
    blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
  } else {
    const ext = gl.getExtension("EXT_blend_minmax");
    if (ext) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
    }
  }
  return blendMap;
}
var init_mapWebGLBlendModesToPixi = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
var init_GlStateSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_mapWebGLBlendModesToPixi();
    BLEND2 = 0;
    OFFSET2 = 1;
    CULLING2 = 2;
    DEPTH_TEST2 = 3;
    WINDING2 = 4;
    DEPTH_MASK2 = 5;
    _GlStateSystem = class _GlStateSystem2 {
      constructor(renderer) {
        this._invertFrontFace = false;
        this.gl = null;
        this.stateId = 0;
        this.polygonOffset = 0;
        this.blendMode = "none";
        this._blendEq = false;
        this.map = [];
        this.map[BLEND2] = this.setBlend;
        this.map[OFFSET2] = this.setOffset;
        this.map[CULLING2] = this.setCullFace;
        this.map[DEPTH_TEST2] = this.setDepthTest;
        this.map[WINDING2] = this.setFrontFace;
        this.map[DEPTH_MASK2] = this.setDepthMask;
        this.checks = [];
        this.defaultState = State.for2d();
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(renderTarget) {
        this._invertFrontFace = !renderTarget.isRoot;
        if (this._cullFace) {
          this.setFrontFace(this._frontFace);
        } else {
          this._frontFaceDirty = true;
        }
      }
      contextChange(gl) {
        this.gl = gl;
        this.blendModesMap = mapWebGLBlendModesToPixi(gl);
        this.resetState();
      }
      /**
       * Sets the current state
       * @param {*} state - The state to set.
       */
      set(state) {
        state || (state = this.defaultState);
        if (this.stateId !== state.data) {
          let diff = this.stateId ^ state.data;
          let i2 = 0;
          while (diff) {
            if (diff & 1) {
              this.map[i2].call(this, !!(state.data & 1 << i2));
            }
            diff >>= 1;
            i2++;
          }
          this.stateId = state.data;
        }
        for (let i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
      }
      /**
       * Sets the state, when previous state is unknown.
       * @param {*} state - The state to set
       */
      forceState(state) {
        state || (state = this.defaultState);
        for (let i2 = 0; i2 < this.map.length; i2++) {
          this.map[i2].call(this, !!(state.data & 1 << i2));
        }
        for (let i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
        this.stateId = state.data;
      }
      /**
       * Sets whether to enable or disable blending.
       * @param value - Turn on or off WebGl blending.
       */
      setBlend(value) {
        this._updateCheck(_GlStateSystem2._checkBlendMode, value);
        this.gl[value ? "enable" : "disable"](this.gl.BLEND);
      }
      /**
       * Sets whether to enable or disable polygon offset fill.
       * @param value - Turn on or off webgl polygon offset testing.
       */
      setOffset(value) {
        this._updateCheck(_GlStateSystem2._checkPolygonOffset, value);
        this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }
      /**
       * Sets whether to enable or disable depth test.
       * @param value - Turn on or off webgl depth testing.
       */
      setDepthTest(value) {
        this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }
      /**
       * Sets whether to enable or disable depth mask.
       * @param value - Turn on or off webgl depth mask.
       */
      setDepthMask(value) {
        this.gl.depthMask(value);
      }
      /**
       * Sets whether to enable or disable cull face.
       * @param {boolean} value - Turn on or off webgl cull face.
       */
      setCullFace(value) {
        this._cullFace = value;
        this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
        if (this._cullFace && this._frontFaceDirty) {
          this.setFrontFace(this._frontFace);
        }
      }
      /**
       * Sets the gl front face.
       * @param {boolean} value - true is clockwise and false is counter-clockwise
       */
      setFrontFace(value) {
        this._frontFace = value;
        this._frontFaceDirty = false;
        const faceMode = this._invertFrontFace ? !value : value;
        if (this._glFrontFace !== faceMode) {
          this._glFrontFace = faceMode;
          this.gl.frontFace(this.gl[faceMode ? "CW" : "CCW"]);
        }
      }
      /**
       * Sets the blend mode.
       * @param {number} value - The blend mode to set to.
       */
      setBlendMode(value) {
        if (!this.blendModesMap[value]) {
          value = "normal";
        }
        if (value === this.blendMode) {
          return;
        }
        this.blendMode = value;
        const mode = this.blendModesMap[value];
        const gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      }
      /**
       * Sets the polygon offset.
       * @param {number} value - the polygon offset
       * @param {number} scale - the polygon offset scale
       */
      setPolygonOffset(value, scale) {
        this.gl.polygonOffset(value, scale);
      }
      /** Resets all the logic and disables the VAOs. */
      resetState() {
        this._glFrontFace = false;
        this._frontFace = false;
        this._cullFace = false;
        this._frontFaceDirty = false;
        this._invertFrontFace = false;
        this.gl.frontFace(this.gl.CCW);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = "";
        this.setBlendMode("normal");
      }
      /**
       * Checks to see which updates should be checked based on which settings have been activated.
       *
       * For example, if blend is enabled then we should check the blend modes each time the state is changed
       * or if polygon fill is activated then we need to check if the polygon offset changes.
       * The idea is that we only check what we have too.
       * @param func - the checking function to add or remove
       * @param value - should the check function be added or removed.
       */
      _updateCheck(func, value) {
        const index = this.checks.indexOf(func);
        if (value && index === -1) {
          this.checks.push(func);
        } else if (!value && index !== -1) {
          this.checks.splice(index, 1);
        }
      }
      /**
       * A private little wrapper function that we call to check the blend mode.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
      }
      /**
       * A private little wrapper function that we call to check the polygon offset.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkPolygonOffset(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      }
      /** @ignore */
      destroy() {
        this.gl = null;
        this.checks.length = 0;
      }
    };
    _GlStateSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "state"
    };
    GlStateSystem = _GlStateSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
var GlTexture;
var init_GlTexture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
    init_const10();
    GlTexture = class {
      constructor(texture) {
        this.target = GL_TARGETS.TEXTURE_2D;
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.type = GL_TYPES.UNSIGNED_BYTE;
        this.internalFormat = GL_FORMATS.RGBA;
        this.format = GL_FORMATS.RGBA;
        this.samplerType = 0;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
var glUploadBufferImageResource;
var init_glUploadBufferImageResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
    "use strict";
    glUploadBufferImageResource = {
      id: "buffer",
      upload(source3, glTexture, gl) {
        if (glTexture.width === source3.width || glTexture.height === source3.height) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            source3.width,
            source3.height,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            source3.width,
            source3.height,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        }
        glTexture.width = source3.width;
        glTexture.height = source3.height;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
var compressedFormatMap, glUploadCompressedTextureResource;
var init_glUploadCompressedTextureResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs"() {
    "use strict";
    compressedFormatMap = {
      "bc1-rgba-unorm": true,
      "bc1-rgba-unorm-srgb": true,
      "bc2-rgba-unorm": true,
      "bc2-rgba-unorm-srgb": true,
      "bc3-rgba-unorm": true,
      "bc3-rgba-unorm-srgb": true,
      "bc4-r-unorm": true,
      "bc4-r-snorm": true,
      "bc5-rg-unorm": true,
      "bc5-rg-snorm": true,
      "bc6h-rgb-ufloat": true,
      "bc6h-rgb-float": true,
      "bc7-rgba-unorm": true,
      "bc7-rgba-unorm-srgb": true,
      // ETC2 compressed formats usable if "texture-compression-etc2" is both
      // supported by the device/user agent and enabled in requestDevice.
      "etc2-rgb8unorm": true,
      "etc2-rgb8unorm-srgb": true,
      "etc2-rgb8a1unorm": true,
      "etc2-rgb8a1unorm-srgb": true,
      "etc2-rgba8unorm": true,
      "etc2-rgba8unorm-srgb": true,
      "eac-r11unorm": true,
      "eac-r11snorm": true,
      "eac-rg11unorm": true,
      "eac-rg11snorm": true,
      // ASTC compressed formats usable if "texture-compression-astc" is both
      // supported by the device/user agent and enabled in requestDevice.
      "astc-4x4-unorm": true,
      "astc-4x4-unorm-srgb": true,
      "astc-5x4-unorm": true,
      "astc-5x4-unorm-srgb": true,
      "astc-5x5-unorm": true,
      "astc-5x5-unorm-srgb": true,
      "astc-6x5-unorm": true,
      "astc-6x5-unorm-srgb": true,
      "astc-6x6-unorm": true,
      "astc-6x6-unorm-srgb": true,
      "astc-8x5-unorm": true,
      "astc-8x5-unorm-srgb": true,
      "astc-8x6-unorm": true,
      "astc-8x6-unorm-srgb": true,
      "astc-8x8-unorm": true,
      "astc-8x8-unorm-srgb": true,
      "astc-10x5-unorm": true,
      "astc-10x5-unorm-srgb": true,
      "astc-10x6-unorm": true,
      "astc-10x6-unorm-srgb": true,
      "astc-10x8-unorm": true,
      "astc-10x8-unorm-srgb": true,
      "astc-10x10-unorm": true,
      "astc-10x10-unorm-srgb": true,
      "astc-12x10-unorm": true,
      "astc-12x10-unorm-srgb": true,
      "astc-12x12-unorm": true,
      "astc-12x12-unorm-srgb": true
    };
    glUploadCompressedTextureResource = {
      id: "compressed",
      upload(source3, glTexture, gl) {
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        let mipWidth = source3.pixelWidth;
        let mipHeight = source3.pixelHeight;
        const compressed = !!compressedFormatMap[source3.format];
        for (let i2 = 0; i2 < source3.resource.length; i2++) {
          const levelBuffer = source3.resource[i2];
          if (compressed) {
            gl.compressedTexImage2D(
              gl.TEXTURE_2D,
              i2,
              glTexture.internalFormat,
              mipWidth,
              mipHeight,
              0,
              levelBuffer
            );
          } else {
            gl.texImage2D(
              gl.TEXTURE_2D,
              i2,
              glTexture.internalFormat,
              mipWidth,
              mipHeight,
              0,
              glTexture.format,
              glTexture.type,
              levelBuffer
            );
          }
          mipWidth = Math.max(mipWidth >> 1, 1);
          mipHeight = Math.max(mipHeight >> 1, 1);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
var glUploadImageResource;
var init_glUploadImageResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
    "use strict";
    glUploadImageResource = {
      id: "image",
      upload(source3, glTexture, gl, webGLVersion) {
        const glWidth = glTexture.width;
        const glHeight = glTexture.height;
        const textureWidth = source3.pixelWidth;
        const textureHeight = source3.pixelHeight;
        const resourceWidth = source3.resourceWidth;
        const resourceHeight = source3.resourceHeight;
        if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
          if (glWidth !== textureWidth || glHeight !== textureHeight) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
          }
          if (webGLVersion === 2) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              resourceWidth,
              resourceHeight,
              glTexture.format,
              glTexture.type,
              source3.resource
            );
          } else {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source3.resource
            );
          }
        } else if (glWidth === textureWidth && glHeight === textureHeight) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else if (webGLVersion === 2) {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            textureWidth,
            textureHeight,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        }
        glTexture.width = textureWidth;
        glTexture.height = textureHeight;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
var glUploadVideoResource;
var init_glUploadVideoResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
    init_glUploadImageResource();
    glUploadVideoResource = {
      id: "video",
      upload(source3, glTexture, gl, webGLVersion) {
        if (!source3.isValid) {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            1,
            1,
            0,
            glTexture.format,
            glTexture.type,
            null
          );
          return;
        }
        glUploadImageResource.upload(source3, glTexture, gl, webGLVersion);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
var init_pixiToGlMaps = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
    "use strict";
    scaleModeToGlFilter = {
      linear: 9729,
      nearest: 9728
    };
    mipmapScaleModeToGlFilter = {
      linear: {
        linear: 9987,
        nearest: 9985
      },
      nearest: {
        linear: 9986,
        nearest: 9984
      }
    };
    wrapModeToGlAddress = {
      "clamp-to-edge": 33071,
      repeat: 10497,
      "mirror-repeat": 33648
    };
    compareModeToGlCompare = {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
  const castParam = firstParam;
  if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
    const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
    const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
    const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
    if (gl.TEXTURE_WRAP_R)
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
  }
  if (!firstCreation || style.magFilter !== "linear") {
    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
  }
  if (mipmaps) {
    if (!firstCreation || style.mipmapFilter !== "linear") {
      const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
    }
  } else {
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
  }
  if (anisotropicExt && style.maxAnisotropy > 1) {
    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
  }
  if (style.compare) {
    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
  }
}
var init_applyStyleParams = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
    init_pixiToGlMaps();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
function mapFormatToGlFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.RED,
    r8snorm: gl.RED,
    r8uint: gl.RED,
    r8sint: gl.RED,
    // 16-bit formats
    r16uint: gl.RED,
    r16sint: gl.RED,
    r16float: gl.RED,
    rg8unorm: gl.RG,
    rg8snorm: gl.RG,
    rg8uint: gl.RG,
    rg8sint: gl.RG,
    // 32-bit formats
    r32uint: gl.RED,
    r32sint: gl.RED,
    r32float: gl.RED,
    rg16uint: gl.RG,
    rg16sint: gl.RG,
    rg16float: gl.RG,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.RGBA,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA,
    rgba8uint: gl.RGBA,
    rgba8sint: gl.RGBA,
    bgra8unorm: gl.RGBA,
    "bgra8unorm-srgb": gl.RGBA,
    rgb9e5ufloat: gl.RGB,
    rgb10a2unorm: gl.RGBA,
    rg11b10ufloat: gl.RGB,
    // 64-bit formats
    rg32uint: gl.RG,
    rg32sint: gl.RG,
    rg32float: gl.RG,
    rgba16uint: gl.RGBA,
    rgba16sint: gl.RGBA,
    rgba16float: gl.RGBA,
    // 128-bit formats
    rgba32uint: gl.RGBA,
    rgba32sint: gl.RGBA,
    rgba32float: gl.RGBA,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT,
    depth24plus: gl.DEPTH_COMPONENT,
    "depth24plus-stencil8": gl.DEPTH_STENCIL,
    depth32float: gl.DEPTH_COMPONENT,
    "depth32float-stencil8": gl.DEPTH_STENCIL
  };
}
var init_mapFormatToGlFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
function mapFormatToGlInternalFormat(gl, extensions2) {
  let srgb = {};
  let bgra8unorm = gl.RGBA;
  if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
    srgb = {
      "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
      "bgra8unorm-srgb": gl.SRGB8_ALPHA8
    };
    bgra8unorm = gl.RGBA8;
  } else if (extensions2.srgb) {
    srgb = {
      "rgba8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT,
      "bgra8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT
    };
  }
  return {
    // 8-bit formats
    r8unorm: gl.R8,
    r8snorm: gl.R8_SNORM,
    r8uint: gl.R8UI,
    r8sint: gl.R8I,
    // 16-bit formats
    r16uint: gl.R16UI,
    r16sint: gl.R16I,
    r16float: gl.R16F,
    rg8unorm: gl.RG8,
    rg8snorm: gl.RG8_SNORM,
    rg8uint: gl.RG8UI,
    rg8sint: gl.RG8I,
    // 32-bit formats
    r32uint: gl.R32UI,
    r32sint: gl.R32I,
    r32float: gl.R32F,
    rg16uint: gl.RG16UI,
    rg16sint: gl.RG16I,
    rg16float: gl.RG16F,
    rgba8unorm: gl.RGBA,
    ...srgb,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA8_SNORM,
    rgba8uint: gl.RGBA8UI,
    rgba8sint: gl.RGBA8I,
    bgra8unorm,
    rgb9e5ufloat: gl.RGB9_E5,
    rgb10a2unorm: gl.RGB10_A2,
    rg11b10ufloat: gl.R11F_G11F_B10F,
    // 64-bit formats
    rg32uint: gl.RG32UI,
    rg32sint: gl.RG32I,
    rg32float: gl.RG32F,
    rgba16uint: gl.RGBA16UI,
    rgba16sint: gl.RGBA16I,
    rgba16float: gl.RGBA16F,
    // 128-bit formats
    rgba32uint: gl.RGBA32UI,
    rgba32sint: gl.RGBA32I,
    rgba32float: gl.RGBA32F,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT16,
    depth24plus: gl.DEPTH_COMPONENT24,
    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
    depth32float: gl.DEPTH_COMPONENT32F,
    "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
    // Compressed formats
    ...extensions2.s3tc ? {
      "bc1-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
    } : {},
    ...extensions2.s3tc_sRGB ? {
      "bc1-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    } : {},
    ...extensions2.rgtc ? {
      "bc4-r-unorm": extensions2.rgtc.COMPRESSED_RED_RGTC1_EXT,
      "bc4-r-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      "bc5-rg-unorm": extensions2.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
      "bc5-rg-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    } : {},
    ...extensions2.bptc ? {
      "bc6h-rgb-float": extensions2.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      "bc6h-rgb-ufloat": extensions2.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      "bc7-rgba-unorm": extensions2.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      "bc7-rgba-unorm-srgb": extensions2.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    } : {},
    ...extensions2.etc ? {
      "etc2-rgb8unorm": extensions2.etc.COMPRESSED_RGB8_ETC2,
      "etc2-rgb8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ETC2,
      "etc2-rgb8a1unorm": extensions2.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgb8a1unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgba8unorm": extensions2.etc.COMPRESSED_RGBA8_ETC2_EAC,
      "etc2-rgba8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      "eac-r11unorm": extensions2.etc.COMPRESSED_R11_EAC,
      // 'eac-r11snorm'
      "eac-rg11unorm": extensions2.etc.COMPRESSED_SIGNED_RG11_EAC
      // 'eac-rg11snorm'
    } : {},
    ...extensions2.astc ? {
      "astc-4x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
      "astc-4x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      "astc-5x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
      "astc-5x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
      "astc-5x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
      "astc-5x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      "astc-6x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
      "astc-6x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      "astc-6x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
      "astc-6x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      "astc-8x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
      "astc-8x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      "astc-8x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
      "astc-8x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      "astc-8x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
      "astc-8x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      "astc-10x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
      "astc-10x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      "astc-10x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
      "astc-10x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      "astc-10x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
      "astc-10x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      "astc-10x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
      "astc-10x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      "astc-12x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
      "astc-12x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      "astc-12x12-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
      "astc-12x12-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    } : {}
  };
}
var init_mapFormatToGlInternalFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
function mapFormatToGlType(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.UNSIGNED_BYTE,
    r8snorm: gl.BYTE,
    r8uint: gl.UNSIGNED_BYTE,
    r8sint: gl.BYTE,
    // 16-bit formats
    r16uint: gl.UNSIGNED_SHORT,
    r16sint: gl.SHORT,
    r16float: gl.HALF_FLOAT,
    rg8unorm: gl.UNSIGNED_BYTE,
    rg8snorm: gl.BYTE,
    rg8uint: gl.UNSIGNED_BYTE,
    rg8sint: gl.BYTE,
    // 32-bit formats
    r32uint: gl.UNSIGNED_INT,
    r32sint: gl.INT,
    r32float: gl.FLOAT,
    rg16uint: gl.UNSIGNED_SHORT,
    rg16sint: gl.SHORT,
    rg16float: gl.HALF_FLOAT,
    rgba8unorm: gl.UNSIGNED_BYTE,
    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
    // Packed 32-bit formats
    rgba8snorm: gl.BYTE,
    rgba8uint: gl.UNSIGNED_BYTE,
    rgba8sint: gl.BYTE,
    bgra8unorm: gl.UNSIGNED_BYTE,
    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
    // 64-bit formats
    rg32uint: gl.UNSIGNED_INT,
    rg32sint: gl.INT,
    rg32float: gl.FLOAT,
    rgba16uint: gl.UNSIGNED_SHORT,
    rgba16sint: gl.SHORT,
    rgba16float: gl.HALF_FLOAT,
    // 128-bit formats
    rgba32uint: gl.UNSIGNED_INT,
    rgba32sint: gl.INT,
    rgba32float: gl.FLOAT,
    // Depth/stencil formats
    stencil8: gl.UNSIGNED_BYTE,
    depth16unorm: gl.UNSIGNED_SHORT,
    depth24plus: gl.UNSIGNED_INT,
    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
    depth32float: gl.FLOAT,
    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}
var init_mapFormatToGlType = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
var BYTES_PER_PIXEL, GlTextureSystem;
var init_GlTextureSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
    init_adapter();
    init_Extensions();
    init_Texture();
    init_GlTexture();
    init_glUploadBufferImageResource();
    init_glUploadCompressedTextureResource();
    init_glUploadImageResource();
    init_glUploadVideoResource();
    init_applyStyleParams();
    init_mapFormatToGlFormat();
    init_mapFormatToGlInternalFormat();
    init_mapFormatToGlType();
    BYTES_PER_PIXEL = 4;
    GlTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._glTextures = /* @__PURE__ */ Object.create(null);
        this._glSamplers = /* @__PURE__ */ Object.create(null);
        this._boundTextures = [];
        this._activeTextureLocation = -1;
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: glUploadImageResource,
          buffer: glUploadBufferImageResource,
          video: glUploadVideoResource,
          compressed: glUploadCompressedTextureResource
        };
        this._premultiplyAlpha = false;
        this._useSeparateSamplers = false;
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_glTextures");
        this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
      }
      contextChange(gl) {
        this._gl = gl;
        if (!this._mapFormatToInternalFormat) {
          this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
          this._mapFormatToType = mapFormatToGlType(gl);
          this._mapFormatToFormat = mapFormatToGlFormat(gl);
        }
        this._glTextures = /* @__PURE__ */ Object.create(null);
        this._glSamplers = /* @__PURE__ */ Object.create(null);
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        this._premultiplyAlpha = false;
        for (let i2 = 0; i2 < 16; i2++) {
          this.bind(Texture.EMPTY, i2);
        }
      }
      /**
       * Initializes a texture source, if it has already been initialized nothing will happen.
       * @param source - The texture source to initialize.
       * @returns The initialized texture source.
       */
      initSource(source3) {
        this.bind(source3);
      }
      bind(texture, location = 0) {
        const source3 = texture.source;
        if (texture) {
          this.bindSource(source3, location);
          if (this._useSeparateSamplers) {
            this._bindSampler(source3.style, location);
          }
        } else {
          this.bindSource(null, location);
          if (this._useSeparateSamplers) {
            this._bindSampler(null, location);
          }
        }
      }
      bindSource(source3, location = 0) {
        const gl = this._gl;
        source3._touched = this._renderer.textureGC.count;
        if (this._boundTextures[location] !== source3) {
          this._boundTextures[location] = source3;
          this._activateLocation(location);
          source3 || (source3 = Texture.EMPTY.source);
          const glTexture = this.getGlSource(source3);
          gl.bindTexture(glTexture.target, glTexture.texture);
        }
      }
      _bindSampler(style, location = 0) {
        const gl = this._gl;
        if (!style) {
          this._boundSamplers[location] = null;
          gl.bindSampler(location, null);
          return;
        }
        const sampler = this._getGlSampler(style);
        if (this._boundSamplers[location] !== sampler) {
          this._boundSamplers[location] = sampler;
          gl.bindSampler(location, sampler);
        }
      }
      unbind(texture) {
        const source3 = texture.source;
        const boundTextures = this._boundTextures;
        const gl = this._gl;
        for (let i2 = 0; i2 < boundTextures.length; i2++) {
          if (boundTextures[i2] === source3) {
            this._activateLocation(i2);
            const glTexture = this.getGlSource(source3);
            gl.bindTexture(glTexture.target, null);
            boundTextures[i2] = null;
          }
        }
      }
      _activateLocation(location) {
        if (this._activeTextureLocation !== location) {
          this._activeTextureLocation = location;
          this._gl.activeTexture(this._gl.TEXTURE0 + location);
        }
      }
      _initSource(source3) {
        const gl = this._gl;
        const glTexture = new GlTexture(gl.createTexture());
        glTexture.type = this._mapFormatToType[source3.format];
        glTexture.internalFormat = this._mapFormatToInternalFormat[source3.format];
        glTexture.format = this._mapFormatToFormat[source3.format];
        if (source3.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source3.isPowerOfTwo)) {
          const biggestDimension = Math.max(source3.width, source3.height);
          source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        this._glTextures[source3.uid] = glTexture;
        if (!this.managedTextures.includes(source3)) {
          source3.on("update", this.onSourceUpdate, this);
          source3.on("resize", this.onSourceUpdate, this);
          source3.on("styleChange", this.onStyleChange, this);
          source3.on("destroy", this.onSourceDestroy, this);
          source3.on("unload", this.onSourceUnload, this);
          source3.on("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.push(source3);
        }
        this.onSourceUpdate(source3);
        this.updateStyle(source3, false);
        return glTexture;
      }
      onStyleChange(source3) {
        this.updateStyle(source3, false);
      }
      updateStyle(source3, firstCreation) {
        const gl = this._gl;
        const glTexture = this.getGlSource(source3);
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source3;
        applyStyleParams(
          source3.style,
          gl,
          source3.mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "texParameteri",
          gl.TEXTURE_2D,
          // will force a clamp to edge if the texture is not a power of two
          !this._renderer.context.supports.nonPowOf2wrapping && !source3.isPowerOfTwo,
          firstCreation
        );
      }
      onSourceUnload(source3) {
        const glTexture = this._glTextures[source3.uid];
        if (!glTexture)
          return;
        this.unbind(source3);
        this._glTextures[source3.uid] = null;
        this._gl.deleteTexture(glTexture.texture);
      }
      onSourceUpdate(source3) {
        const gl = this._gl;
        const glTexture = this.getGlSource(source3);
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source3;
        const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
        if (this._premultiplyAlpha !== premultipliedAlpha) {
          this._premultiplyAlpha = premultipliedAlpha;
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
        }
        if (this._uploads[source3.uploadMethodId]) {
          this._uploads[source3.uploadMethodId].upload(source3, glTexture, gl, this._renderer.context.webGLVersion);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source3.pixelWidth, source3.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
          this.onUpdateMipmaps(source3, false);
        }
      }
      onUpdateMipmaps(source3, bind = true) {
        if (bind)
          this.bindSource(source3, 0);
        const glTexture = this.getGlSource(source3);
        this._gl.generateMipmap(glTexture.target);
      }
      onSourceDestroy(source3) {
        source3.off("destroy", this.onSourceDestroy, this);
        source3.off("update", this.onSourceUpdate, this);
        source3.off("resize", this.onSourceUpdate, this);
        source3.off("unload", this.onSourceUnload, this);
        source3.off("styleChange", this.onStyleChange, this);
        source3.off("updateMipmaps", this.onUpdateMipmaps, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
        this.onSourceUnload(source3);
      }
      _initSampler(style) {
        const gl = this._gl;
        const glSampler = this._gl.createSampler();
        this._glSamplers[style._resourceId] = glSampler;
        applyStyleParams(
          style,
          gl,
          this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "samplerParameteri",
          glSampler,
          false,
          true
        );
        return this._glSamplers[style._resourceId];
      }
      _getGlSampler(sampler) {
        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
      }
      getGlSource(source3) {
        return this._glTextures[source3.uid] || this._initSource(source3);
      }
      generateCanvas(texture) {
        const { pixels, width, height } = this.getPixels(texture);
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (ctx) {
          const imageData = ctx.createImageData(width, height);
          imageData.data.set(pixels);
          ctx.putImageData(imageData, 0, 0);
        }
        return canvas;
      }
      getPixels(texture) {
        const resolution = texture.source.resolution;
        const frame = texture.frame;
        const width = Math.max(Math.round(frame.width * resolution), 1);
        const height = Math.max(Math.round(frame.height * resolution), 1);
        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
        const renderer = this._renderer;
        const renderTarget = renderer.renderTarget.getRenderTarget(texture);
        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
        const gl = renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
        gl.readPixels(
          Math.round(frame.x * resolution),
          Math.round(frame.y * resolution),
          width,
          height,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels
        );
        if (false) {
          unpremultiplyAlpha(pixels);
        }
        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
      }
      destroy() {
        this.managedTextures.slice().forEach((source3) => this.onSourceDestroy(source3));
        this.managedTextures = null;
        this._glTextures = null;
        this._glSamplers = null;
        this._boundTextures = null;
        this._boundSamplers = null;
        this._mapFormatToInternalFormat = null;
        this._mapFormatToType = null;
        this._mapFormatToFormat = null;
        this._uploads = null;
        this._renderer = null;
      }
      resetState() {
        this._activeTextureLocation = -1;
        this._boundTextures.fill(Texture.EMPTY.source);
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        const gl = this._gl;
        this._premultiplyAlpha = false;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
      }
    };
    GlTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "texture"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
var WebGLRenderer_exports = {};
__export(WebGLRenderer_exports, {
  WebGLRenderer: () => WebGLRenderer
});
var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
var init_WebGLRenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
    init_Extensions();
    init_GlGraphicsAdaptor();
    init_GlMeshAdaptor();
    init_GlBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types2();
    init_GlBufferSystem();
    init_GlContextSystem();
    init_GlGeometrySystem();
    init_GlBackBufferSystem();
    init_GlColorMaskSystem();
    init_GlEncoderSystem();
    init_GlLimitsSystem();
    init_GlStencilSystem();
    init_GlUboSystem();
    init_GlRenderTargetSystem();
    init_GlShaderSystem();
    init_GlUniformGroupSystem();
    init_GlStateSystem();
    init_GlTextureSystem();
    DefaultWebGLSystems = [
      ...SharedSystems,
      GlUboSystem,
      GlBackBufferSystem,
      GlContextSystem,
      GlLimitsSystem,
      GlBufferSystem,
      GlTextureSystem,
      GlRenderTargetSystem,
      GlGeometrySystem,
      GlUniformGroupSystem,
      GlShaderSystem,
      GlEncoderSystem,
      GlStateSystem,
      GlStencilSystem,
      GlColorMaskSystem
    ];
    DefaultWebGLPipes = [...SharedRenderPipes];
    DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
    systems2 = [];
    renderPipes2 = [];
    renderPipeAdaptors2 = [];
    extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
    extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
    extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
    extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
    WebGLRenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgl",
          type: RendererType.WEBGL,
          systems: systems2,
          renderPipes: renderPipes2,
          renderPipeAdaptors: renderPipeAdaptors2
        };
        super(systemConfig);
      }
    };
  }
});

// config.ts
var DEFAULT_CONFIG = {
  candles: {
    hollowUp: true,
    borderWidth: 1,
    wickWidth: 1,
    minBodyHeight: 1
  },
  colors: {
    theme: "light",
    upColor: "#26a69a",
    downColor: "#ef5350",
    upBorderColor: "#26a69a",
    downBorderColor: "#ef5350",
    volumeUpColor: "#26a69a80",
    volumeDownColor: "#ef535080"
  },
  volume: {
    enabled: true,
    heightPercent: 20
  },
  grid: {
    horizontal: 8,
    vertical: 6,
    style: "solid",
    opacity: 0.5
  },
  watermark: {
    enabled: true,
    opacity: 5,
    fontSize: 80
  },
  crosshair: {
    style: "dashed",
    width: 1,
    floatingLabels: true
  },
  priceScale: {
    autoFit: true,
    logarithmic: false,
    padding: 5
  },
  lastPrice: {
    enabled: true,
    lineStyle: "dashed",
    labelBg: true
  },
  indicators: {
    enabled: true,
    heightPercent: 30,
    rsi: {
      type: "rsi",
      period: 14,
      overlay: false,
      heatIntensity: 1
    }
  }
};
var ChartConfig = class {
  constructor() {
    this.config = this.loadFromStorage() || { ...DEFAULT_CONFIG };
  }
  loadFromStorage() {
    try {
      const stored = localStorage.getItem("chartConfig");
      if (stored) {
        const parsed = JSON.parse(stored);
        return this.deepMerge(DEFAULT_CONFIG, parsed);
      }
    } catch (e2) {
      console.warn("Failed to load config from localStorage:", e2);
    }
    return null;
  }
  saveToStorage() {
    try {
      localStorage.setItem("chartConfig", JSON.stringify(this.config));
      console.log("\u2705 Config saved to localStorage");
    } catch (e2) {
      console.error("Failed to save config:", e2);
    }
  }
  deepMerge(target, source3) {
    const result = { ...target };
    for (const key in source3) {
      if (source3[key] && typeof source3[key] === "object" && !Array.isArray(source3[key])) {
        result[key] = this.deepMerge(target[key] || {}, source3[key]);
      } else {
        result[key] = source3[key];
      }
    }
    return result;
  }
  get(path2) {
    const keys = path2.split(".");
    let value = this.config;
    for (const key of keys) {
      value = value[key];
      if (value === void 0) return void 0;
    }
    return value;
  }
  set(path2, value) {
    const keys = path2.split(".");
    let obj = this.config;
    for (let i2 = 0; i2 < keys.length - 1; i2++) {
      obj = obj[keys[i2]];
    }
    obj[keys[keys.length - 1]] = value;
    this.saveToStorage();
  }
  reset() {
    this.config = { ...DEFAULT_CONFIG };
    this.saveToStorage();
  }
  applyTheme(theme) {
    if (theme === "dark") {
      this.config.colors = {
        ...this.config.colors,
        theme: "dark"
      };
    } else {
      this.config.colors = {
        ...this.config.colors,
        theme: "light"
      };
    }
    this.saveToStorage();
  }
  getThemeColors() {
    const isDark = this.config.colors.theme === "dark";
    return {
      bg: isDark ? "#1e1e1e" : "#ffffff",
      grid: isDark ? "#2a2a2a" : "#f0f0f0",
      text: isDark ? "#d4d4d4" : "#333333",
      textLight: isDark ? "#808080" : "#999999",
      crosshair: isDark ? "#758696" : "#758696"
    };
  }
};
var chartConfig = new ChartConfig();

// node_modules/pixi.js/lib/environment-browser/browserExt.mjs
init_Extensions();
var browserExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "browser",
    priority: -1
  },
  test: () => true,
  load: async () => {
    await Promise.resolve().then(() => (init_browserAll(), browserAll_exports));
  }
};

// node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs
init_Extensions();
var webworkerExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await Promise.resolve().then(() => (init_webworkerAll(), webworkerAll_exports));
  }
};

// node_modules/pixi.js/lib/index.mjs
init_Extensions();
init_init6();
init_init5();

// node_modules/pixi.js/lib/app/Application.mjs
init_Extensions();

// node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
init_adapter();
init_AbstractRenderer();
var _isWebGLSupported;
function isWebGLSupported(failIfMajorPerformanceCaveat) {
  if (_isWebGLSupported !== void 0)
    return _isWebGLSupported;
  _isWebGLSupported = (() => {
    const contextOptions = {
      stencil: true,
      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!DOMAdapter.get().getWebGLRenderingContext()) {
        return false;
      }
      const canvas = DOMAdapter.get().createCanvas();
      let gl = canvas.getContext("webgl", contextOptions);
      const success = !!gl?.getContextAttributes()?.stencil;
      if (gl) {
        const loseContext = gl.getExtension("WEBGL_lose_context");
        if (loseContext) {
          loseContext.loseContext();
        }
      }
      gl = null;
      return success;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGLSupported;
}

// node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
init_adapter();
var _isWebGPUSupported;
async function isWebGPUSupported(options = {}) {
  if (_isWebGPUSupported !== void 0)
    return _isWebGPUSupported;
  _isWebGPUSupported = await (async () => {
    const gpu = DOMAdapter.get().getNavigator().gpu;
    if (!gpu) {
      return false;
    }
    try {
      const adapter = await gpu.requestAdapter(options);
      await adapter.requestDevice();
      return true;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGPUSupported;
}

// node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
init_AbstractRenderer();
var renderPriority = ["webgl", "webgpu", "canvas"];
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  let finalOptions = {};
  for (let i2 = 0; i2 < preferredOrder.length; i2++) {
    const rendererType = preferredOrder[i2];
    if (rendererType === "webgpu" && await isWebGPUSupported()) {
      const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
      RendererClass = WebGPURenderer2;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && isWebGLSupported(
      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
      RendererClass = WebGLRenderer2;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      finalOptions = { ...options };
      throw new Error("CanvasRenderer is not yet implemented");
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  if (!RendererClass) {
    throw new Error("No available renderer for the current environment");
  }
  const renderer = new RendererClass();
  await renderer.init(finalOptions);
  return renderer;
}

// node_modules/pixi.js/lib/app/Application.mjs
init_Container();
init_globalHooks();
init_deprecation();
var _Application = class _Application2 {
  constructor(...args) {
    this.stage = new Container();
    if (args[0] !== void 0) {
      deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
    }
  }
  /**
   * Initializes the PixiJS application with the specified options.
   *
   * This method must be called after creating a new Application instance.
   * @param options - Configuration options for the application and renderer
   * @returns A promise that resolves when initialization is complete
   * @example
   * ```js
   * const app = new Application();
   *
   * // Initialize with custom options
   * await app.init({
   *     width: 800,
   *     height: 600,
   *     backgroundColor: 0x1099bb,
   *     preference: 'webgl', // or 'webgpu'
   * });
   * ```
   */
  async init(options) {
    options = { ...options };
    this.renderer = await autoDetectRenderer(options);
    _Application2._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /**
   * Renders the current stage to the screen.
   *
   * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call
   * this method directly as rendering is handled automatically.
   *
   * Only use this method if you've disabled the {@link TickerPlugin} or need custom
   * render timing control.
   * @example
   * ```js
   * // Example 1: Default setup (TickerPlugin handles rendering)
   * const app = new Application();
   * await app.init();
   * // No need to call render() - TickerPlugin handles it
   *
   * // Example 2: Custom rendering loop (if TickerPlugin is disabled)
   * const app = new Application();
   * await app.init({ autoStart: false }); // Disable automatic rendering
   *
   * function animate() {
   *     app.render();
   *     requestAnimationFrame(animate);
   * }
   * animate();
   * ```
   */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element. This is the HTML element
   * that displays your application's graphics.
   * @readonly
   * @type {HTMLCanvasElement}
   * @example
   * ```js
   * // Create a new application
   * const app = new Application();
   * // Initialize the application
   * await app.init({...});
   * // Add canvas to the page
   * document.body.appendChild(app.canvas);
   *
   * // Access the canvas directly
   * console.log(app.canvas); // HTMLCanvasElement
   * ```
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @type {HTMLCanvasElement}
   * @deprecated since 8.0.0
   * @see {@link Application#canvas}
   */
  get view() {
    deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. This represents the visible area of your application.
   *
   * It's commonly used for:
   * - Setting filter areas for full-screen effects
   * - Defining hit areas for screen-wide interaction
   * - Determining the visible bounds of your application
   * @readonly
   * @example
   * ```js
   * // Use as filter area for a full-screen effect
   * const blurFilter = new BlurFilter();
   * sprite.filterArea = app.screen;
   *
   * // Use as hit area for screen-wide interaction
   * const screenSprite = new Sprite();
   * screenSprite.hitArea = app.screen;
   *
   * // Get screen dimensions
   * console.log(app.screen.width, app.screen.height);
   * ```
   * @see {@link Rectangle} For all available properties and methods
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   *
   * This method should be called when you want to completely
   * clean up the application and free all associated memory.
   * @param rendererDestroyOptions - Options for destroying the renderer:
   *  - `false` or `undefined`: Preserves the canvas element (default)
   *  - `true`: Removes the canvas element
   *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal
   * @param options - Options for destroying the application:
   *  - `false` or `undefined`: Basic cleanup (default)
   *  - `true`: Complete cleanup including children
   *  - Detailed options object:
   *    - `children`: Remove children
   *    - `texture`: Destroy textures
   *    - `textureSource`: Destroy texture sources
   *    - `context`: Destroy WebGL context
   * @example
   * ```js
   * // Basic cleanup
   * app.destroy();
   *
   * // Remove canvas and do complete cleanup
   * app.destroy(true, true);
   *
   * // Remove canvas with explicit options
   * app.destroy({ removeView: true }, true);
   *
   * // Detailed cleanup with specific options
   * app.destroy(
   *     { removeView: true },
   *     {
   *         children: true,
   *         texture: true,
   *         textureSource: true,
   *         context: true
   *     }
   * );
   * ```
   * > [!WARNING] After calling destroy, the application instance should no longer be used.
   * > All properties will be null and further operations will throw errors.
   */
  destroy(rendererDestroyOptions = false, options = false) {
    const plugins = _Application2._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(options);
    this.stage = null;
    this.renderer.destroy(rendererDestroyOptions);
    this.renderer = null;
  }
};
_Application._plugins = [];
var Application = _Application;
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ApplicationInitHook);

// node_modules/pixi.js/lib/scene/text/Text.mjs
init_TextureStyle();

// node_modules/pixi.js/lib/scene/text/AbstractText.mjs
init_ObservablePoint();
init_deprecation();
init_ViewContainer();
var AbstractText = class extends ViewContainer {
  constructor(options, styleClass) {
    const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;
    super({
      ...rest
    });
    this.batched = true;
    this._resolution = null;
    this._autoResolution = true;
    this._didTextUpdate = true;
    this._styleClass = styleClass;
    this.text = text ?? "";
    this.style = style;
    this.resolution = resolution ?? null;
    this.allowChildren = false;
    this._anchor = new ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    if (anchor)
      this.anchor = anchor;
    this.roundPixels = roundPixels ?? false;
    if (width !== void 0)
      this.width = width;
    if (height !== void 0)
      this.height = height;
  }
  /**
   * The anchor point of the text that controls the origin point for positioning and rotation.
   * Can be a number (same value for x/y) or a PointData object.
   * - (0,0) is top-left
   * - (0.5,0.5) is center
   * - (1,1) is bottom-right
   * ```ts
   * // Set anchor to center
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }
   * });
   * // Set anchor to top-left
   * const text2 = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: { x: 0, y: 0 } // Top-left corner
   * });
   * // Set anchor to bottom-right
   * const text3 = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: { x: 1, y: 1 } // Bottom-right corner
   * });
   * ```
   * @default { x: 0, y: 0 }
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  /**
   * The text content to display. Use '\n' for line breaks.
   * Accepts strings, numbers, or objects with toString() method.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Hello Pixi!',
   * });
   * const multilineText = new Text({
   *     text: 'Line 1\nLine 2\nLine 3',
   * });
   * const numberText = new Text({
   *     text: 12345, // Will be converted to '12345'
   * });
   * const objectText = new Text({
   *     text: { toString: () => 'Object Text' }, // Custom toString
   * });
   *
   * // Update text dynamically
   * text.text = 'Updated Text'; // Re-renders with new text
   * text.text = 67890; // Updates to '67890'
   * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method
   * // Clear text
   * text.text = ''; // Clears the text
   * ```
   * @default ''
   */
  set text(value) {
    value = value.toString();
    if (this._text === value)
      return;
    this._text = value;
    this.onViewUpdate();
  }
  get text() {
    return this._text;
  }
  /**
   * The resolution/device pixel ratio for rendering.
   * Higher values result in sharper text at the cost of performance.
   * Set to null for auto-resolution based on device.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     resolution: 2 // High DPI for sharper text
   * });
   * const autoResText = new Text({
   *     text: 'Auto Resolution',
   *     resolution: null // Use device's pixel ratio
   * });
   * ```
   * @default null
   */
  set resolution(value) {
    this._autoResolution = value === null;
    this._resolution = value;
    this.onViewUpdate();
  }
  get resolution() {
    return this._resolution;
  }
  get style() {
    return this._style;
  }
  /**
   * The style configuration for the text.
   * Can be a TextStyle instance or a configuration object.
   * Supports canvas text styles, HTML text styles, and bitmap text styles.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Styled Text',
   *     style: {
   *         fontSize: 24,
   *         fill: 0xff1010, // Red color
   *         fontFamily: 'Arial',
   *         align: 'center', // Center alignment
   *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke
   *         dropShadow: {
   *             color: '#000000', // Black shadow
   *             blur: 4, // Shadow blur
   *             distance: 6 // Shadow distance
   *         }
   *     }
   * });
   * const htmlText = new HTMLText({
   *     text: 'HTML Styled Text',
   *     style: {
   *         fontSize: '20px',
   *         fill: 'blue',
   *         fontFamily: 'Verdana',
   *     }
   * });
   * const bitmapText = new BitmapText({
   *     text: 'Bitmap Styled Text',
   *     style: {
   *         fontName: 'Arial',
   *         fontSize: 32,
   *     }
   * })
   *
   * // Update style dynamically
   * text.style = {
   *     fontSize: 30, // Change font size
   *     fill: 0x00ff00, // Change color to green
   *     align: 'right', // Change alignment to right
   *     stroke: { color: '#000000', width: 2 }, // Add black stroke
   * }
   */
  set style(style) {
    style || (style = {});
    this._style?.off("update", this.onViewUpdate, this);
    if (style instanceof this._styleClass) {
      this._style = style;
    } else {
      this._style = new this._styleClass(style);
    }
    this._style.on("update", this.onViewUpdate, this);
    this.onViewUpdate();
  }
  /**
   * The width of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set width directly
   * texture.width = 200;
   * console.log(texture.scale.x); // Scale adjusted to match width
   *
   * // For better performance when setting both width and height
   * texture.setSize(300, 400); // Avoids recalculating bounds twice
   * ```
   */
  get width() {
    return Math.abs(this.scale.x) * this.bounds.width;
  }
  set width(value) {
    this._setWidth(value, this.bounds.width);
  }
  /**
   * The height of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set height directly
   * texture.height = 200;
   * console.log(texture.scale.y); // Scale adjusted to match height
   *
   * // For better performance when setting both width and height
   * texture.setSize(300, 400); // Avoids recalculating bounds twice
   * ```
   */
  get height() {
    return Math.abs(this.scale.y) * this.bounds.height;
  }
  set height(value) {
    this._setHeight(value, this.bounds.height);
  }
  /**
   * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.
   * This is faster than getting width and height separately as it only calculates the bounds once.
   * @example
   * ```ts
   * // Basic size retrieval
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     style: { fontSize: 24 }
   * });
   * const size = text.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * text.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the Sprite
   * @see {@link Text#width} For getting just the width
   * @see {@link Text#height} For getting just the height
   * @see {@link Text#setSize} For setting both width and height
   */
  getSize(out2) {
    out2 || (out2 = {});
    out2.width = Math.abs(this.scale.x) * this.bounds.width;
    out2.height = Math.abs(this.scale.y) * this.bounds.height;
    return out2;
  }
  /**
   * Sets the size of the Text to the specified width and height.
   * This is faster than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * const text = new Text({
   *    text: 'Hello Pixi!',
   *    style: { fontSize: 24 }
   * });
   * text.setSize(100, 200); // Width: 100, Height: 200
   *
   * // Set uniform size
   * text.setSize(100); // Sets both width and height to 100
   *
   * // Set size with object
   * text.setSize({
   *     width: 200,
   *     height: 300
   * });
   * ```
   * @param value - This can be either a number or a {@link Size} object
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link Text#width} For setting width only
   * @see {@link Text#height} For setting height only
   */
  setSize(value, height) {
    if (typeof value === "object") {
      height = value.height ?? value.width;
      value = value.width;
    } else {
      height ?? (height = value);
    }
    value !== void 0 && this._setWidth(value, this.bounds.width);
    height !== void 0 && this._setHeight(height, this.bounds.height);
  }
  /**
   * Checks if the object contains the given point in local coordinates.
   * Uses the text's bounds for hit testing.
   * @example
   * ```ts
   * // Basic point check
   * const localPoint = { x: 50, y: 25 };
   * const contains = text.containsPoint(localPoint);
   * console.log('Point is inside:', contains);
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the text's bounds
   * @see {@link Container#toLocal} For converting global coordinates to local
   */
  containsPoint(point) {
    const width = this.bounds.width;
    const height = this.bounds.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x <= x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y <= y1 + height)
        return true;
    }
    return false;
  }
  /** @internal */
  onViewUpdate() {
    if (!this.didViewUpdate)
      this._didTextUpdate = true;
    super.onViewUpdate();
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * // Destroys the text and its style
   * text.destroy({ style: true, texture: true, textureSource: true });
   * text.destroy(true);
   * text.destroy() // Destroys the text, but not its style
   */
  destroy(options = false) {
    super.destroy(options);
    this.owner = null;
    this._bounds = null;
    this._anchor = null;
    if (typeof options === "boolean" ? options : options?.style) {
      this._style.destroy(options);
    }
    this._style = null;
    this._text = null;
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `${this._text}:${this._style.styleKey}:${this._resolution}`;
  }
};
function ensureTextOptions(args, name) {
  let options = args[0] ?? {};
  if (typeof options === "string" || args[1]) {
    deprecation(v8_0_0, `use new ${name}({ text: "hi!", style }) instead`);
    options = {
      text: options,
      style: args[1]
    };
  }
  return options;
}

// node_modules/pixi.js/lib/scene/text/Text.mjs
init_CanvasTextGenerator();
init_CanvasTextMetrics();
init_TextStyle();
var Text = class extends AbstractText {
  constructor(...args) {
    const options = ensureTextOptions(args, "Text");
    super(options, TextStyle);
    this.renderPipeId = "text";
    if (options.textureStyle) {
      this.textureStyle = options.textureStyle instanceof TextureStyle ? options.textureStyle : new TextureStyle(options.textureStyle);
    }
  }
  /** @private */
  updateBounds() {
    const bounds = this._bounds;
    const anchor = this._anchor;
    let width = 0;
    let height = 0;
    if (this._style.trim) {
      const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({
        text: this.text,
        style: this._style,
        resolution: 1
      });
      CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
      width = frame.width;
      height = frame.height;
    } else {
      const canvasMeasurement = CanvasTextMetrics.measureText(
        this._text,
        this._style
      );
      width = canvasMeasurement.width;
      height = canvasMeasurement.height;
    }
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
};

// node_modules/pixi.js/lib/index.mjs
init_textureFrom();
init_Container();
init_Graphics();
init_eventemitter3();
extensions.add(browserExt, webworkerExt);

// chart-engine.ts
var ChartEngine = class _ChartEngine {
  constructor(container, app2, options = {}) {
    this.container = container;
    this.app = app2;
    const pixiCanvas = this.app.canvas;
    pixiCanvas.style.position = "absolute";
    pixiCanvas.style.left = "0";
    pixiCanvas.style.top = "0";
    this.container.appendChild(pixiCanvas);
    this.bgLayer = new Container();
    this.mainLayer = new Container();
    this.overlayLayer = new Container();
    this.app.stage.addChild(this.bgLayer);
    this.app.stage.addChild(this.mainLayer);
    this.app.stage.addChild(this.overlayLayer);
    this.volumeGraphics = new Graphics();
    this.indicatorBgGraphics = new Graphics();
    this.wicksGraphics = new Graphics();
    this.bodiesDownGraphics = new Graphics();
    this.bodiesUpFilledGraphics = new Graphics();
    this.bodiesUpHollowGraphics = new Graphics();
    this.bordersGraphics = new Graphics();
    this.realtimeMarkersGraphics = new Graphics();
    this.rsiGraphics = new Graphics();
    this.mainLayer.addChild(this.volumeGraphics);
    this.mainLayer.addChild(this.indicatorBgGraphics);
    this.mainLayer.addChild(this.wicksGraphics);
    this.mainLayer.addChild(this.bodiesDownGraphics);
    this.mainLayer.addChild(this.bodiesUpFilledGraphics);
    this.mainLayer.addChild(this.bodiesUpHollowGraphics);
    this.mainLayer.addChild(this.bordersGraphics);
    this.mainLayer.addChild(this.realtimeMarkersGraphics);
    this.mainLayer.addChild(this.rsiGraphics);
    this.overlayCanvas = document.createElement("canvas");
    this.overlayCanvas.style.position = "absolute";
    this.overlayCanvas.style.left = "0";
    this.overlayCanvas.style.top = "0";
    this.overlayCanvas.style.pointerEvents = "all";
    this.overlayCtx = this.overlayCanvas.getContext("2d");
    this.container.appendChild(this.overlayCanvas);
    this.mainCtx = {
      clearRect: () => {
      },
      fillStyle: "",
      strokeStyle: "",
      fillRect: () => {
      },
      strokeRect: () => {
      },
      beginPath: () => {
      },
      moveTo: () => {
      },
      lineTo: () => {
      },
      stroke: () => {
      },
      fill: () => {
      },
      save: () => {
      },
      restore: () => {
      },
      setLineDash: () => {
      },
      measureText: (text) => ({ width: text.length * 7 }),
      lineWidth: 1,
      globalAlpha: 1,
      font: "",
      textAlign: "",
      textBaseline: "",
      fillText: () => {
      }
    };
    this.setupCanvasSizes();
    this.timeframes = [];
    this.rsiData = /* @__PURE__ */ new Map();
    this.rsiVisibility = /* @__PURE__ */ new Map();
    this.realtimeCandles = /* @__PURE__ */ new Map();
    this.realtimeWs = null;
    this.realtimeSubscribed = /* @__PURE__ */ new Set();
    this.realtimeUpdating = false;
    this.renderScheduled = false;
    this.overlayRenderScheduled = false;
    this.rafId = null;
    this.legendContainer = document.createElement("div");
    this.legendContainer.style.cssText = "position: absolute; bottom: 45px; left: 80px; z-index: 10; pointer-events: auto;";
    this.container.appendChild(this.legendContainer);
    this.state = {
      data: [],
      currentTimeframe: "1d",
      symbol: null,
      isLoading: false,
      // Vue (en timestamps secondes)
      viewStart: 0,
      viewEnd: 0,
      // Contraintes de zoom
      minBars: 80,
      maxBars: 200,
      // Prix
      priceMin: 0,
      priceMax: 0,
      // Souris
      mouseX: -1,
      mouseY: -1,
      isDragging: false,
      dragStartX: 0,
      dragStartViewStart: 0,
      dragStartViewEnd: 0,
      // Crosshair
      showCrosshair: false,
      crosshairCandle: null,
      // Zoom throttling
      isProcessingZoom: false,
      lastZoomTime: 0
    };
    this.callbacks = {
      onLoadData: options.onLoadData || (async () => []),
      onTimeframeChange: options.onTimeframeChange || (async () => {
      }),
      onError: options.onError || console.error
    };
    this.theme = {};
    this.updateTheme();
    this.layout = {
      marginLeft: 70,
      marginRight: 60,
      marginTop: 15,
      marginBottom: 40
    };
    this.setupEvents();
    this.renderBackground();
  }
  static async create(container, options = {}) {
    const app2 = new Application();
    await app2.init({
      width: container.clientWidth,
      height: container.clientHeight,
      backgroundColor: 16777215,
      antialias: true,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true
    });
    return new _ChartEngine(container, app2, options);
  }
  parseTimeframeToSeconds(tf) {
    const match = tf.match(/^(\d+)([mhd])$/);
    if (!match) return 86400;
    const value = parseInt(match[1]);
    const unit = match[2];
    switch (unit) {
      case "m":
        return value * 60;
      case "h":
        return value * 3600;
      case "d":
        return value * 86400;
      default:
        return 86400;
    }
  }
  calculateRSI(candles, period = 14) {
    if (candles.length < period + 1) return [];
    const rsi = [];
    let gains = 0;
    let losses = 0;
    for (let i2 = 1; i2 <= period; i2++) {
      const change = candles[i2].close - candles[i2 - 1].close;
      if (change > 0) gains += change;
      else losses += Math.abs(change);
    }
    let avgGain = gains / period;
    let avgLoss = losses / period;
    let rs = avgGain / avgLoss;
    rsi.push({ time: candles[period].time, value: 100 - 100 / (1 + rs) });
    for (let i2 = period + 1; i2 < candles.length; i2++) {
      const change = candles[i2].close - candles[i2 - 1].close;
      const gain = change > 0 ? change : 0;
      const loss = change < 0 ? Math.abs(change) : 0;
      avgGain = (avgGain * (period - 1) + gain) / period;
      avgLoss = (avgLoss * (period - 1) + loss) / period;
      rs = avgGain / avgLoss;
      rsi.push({ time: candles[i2].time, value: 100 - 100 / (1 + rs) });
    }
    return rsi;
  }
  setTimeframes(timeframes) {
    this.timeframes = timeframes.sort(
      (a2, b2) => this.parseTimeframeToSeconds(a2) - this.parseTimeframeToSeconds(b2)
    );
    console.log(`\u2699\uFE0F Timeframes configured: ${this.timeframes.join(", ")}`);
  }
  updateTheme() {
    const themeColors = chartConfig.getThemeColors();
    this.theme = {
      ...themeColors,
      upColor: chartConfig.get("colors.upColor"),
      downColor: chartConfig.get("colors.downColor"),
      upBorderColor: chartConfig.get("colors.upBorderColor"),
      downBorderColor: chartConfig.get("colors.downBorderColor"),
      tooltipBg: themeColors.bg === "#ffffff" ? "rgba(255, 255, 255, 0.95)" : "rgba(30, 30, 30, 0.95)",
      tooltipBorder: themeColors.grid
    };
  }
  setupCanvasSizes() {
    const rect = this.container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    this.overlayCanvas.width = rect.width * dpr;
    this.overlayCanvas.height = rect.height * dpr;
    this.overlayCanvas.style.width = rect.width + "px";
    this.overlayCanvas.style.height = rect.height + "px";
    this.overlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resizeCanvas() {
    const rect = this.container.getBoundingClientRect();
    this.app.renderer.resize(rect.width, rect.height);
    this.setupCanvasSizes();
  }
  setupEvents() {
    const canvas = this.overlayCanvas;
    canvas.addEventListener("wheel", (e2) => this.handleWheel(e2));
    canvas.addEventListener("mousemove", (e2) => this.handleMouseMove(e2));
    canvas.addEventListener("mouseleave", () => this.handleMouseLeave());
    canvas.addEventListener("mousedown", (e2) => this.handleMouseDown(e2));
    canvas.addEventListener("mouseup", () => this.handleMouseUp());
    window.addEventListener("resize", () => this.handleResize());
  }
  handleWheel(e2) {
    e2.preventDefault();
    if (this.state.isLoading || this.state.data.length === 0) return;
    const now = Date.now();
    if (this.state.isProcessingZoom) {
      console.log("\u23ED\uFE0F  Skipping zoom (already processing)");
      return;
    }
    if (now - this.state.lastZoomTime < 50) {
      console.log("\u23ED\uFE0F  Skipping zoom (too fast)");
      return;
    }
    this.state.isProcessingZoom = true;
    this.state.lastZoomTime = now;
    try {
      const rect = this.overlayCanvas.getBoundingClientRect();
      const mouseX = e2.clientX - rect.left;
      const chartWidth = rect.width - this.layout.marginLeft - this.layout.marginRight;
      const mouseXInChart = mouseX - this.layout.marginLeft;
      const clampedX = Math.max(0, Math.min(chartWidth, mouseXInChart));
      const viewWidth = this.state.viewEnd - this.state.viewStart;
      const pivotRatio = clampedX / chartWidth;
      const pivotTime = this.state.viewStart + pivotRatio * viewWidth;
      const pivotDateBefore = new Date(pivotTime * 1e3).toISOString().substring(0, 16);
      console.log(`\u{1F3AF} BEFORE zoom: Pivot at x=${clampedX.toFixed(0)}px, ratio=${pivotRatio.toFixed(3)}, time=${pivotDateBefore}`);
      console.log(`   View: ${new Date(this.state.viewStart * 1e3).toISOString().substring(0, 16)} \u2192 ${new Date(this.state.viewEnd * 1e3).toISOString().substring(0, 16)} (${Math.round(viewWidth / this.parseTimeframeToSeconds(this.state.currentTimeframe))} bars)`);
      const zoomFactor = e2.deltaY > 0 ? 1.15 : 0.87;
      let newWidth = viewWidth * zoomFactor;
      const tfSeconds = this.parseTimeframeToSeconds(this.state.currentTimeframe);
      const minWidth = 50 * tfSeconds;
      const currentIndex = this.timeframes.indexOf(this.state.currentTimeframe);
      if (newWidth < minWidth && currentIndex === 0 && zoomFactor < 1) {
        console.log(`\u26D4 Can't zoom more on ${this.state.currentTimeframe} (minimum ${Math.round(viewWidth / tfSeconds)} bars)`);
        return;
      }
      this.state.viewStart = pivotTime - newWidth * pivotRatio;
      this.state.viewEnd = pivotTime + newWidth * (1 - pivotRatio);
      console.log(`   AFTER zoom: View: ${new Date(this.state.viewStart * 1e3).toISOString().substring(0, 16)} \u2192 ${new Date(this.state.viewEnd * 1e3).toISOString().substring(0, 16)} (${Math.round(newWidth / this.parseTimeframeToSeconds(this.state.currentTimeframe))} bars)`);
      const newViewWidth = this.state.viewEnd - this.state.viewStart;
      const verifyPivotTime = this.state.viewStart + pivotRatio * newViewWidth;
      const pivotDateAfter = new Date(verifyPivotTime * 1e3).toISOString().substring(0, 16);
      console.log(`   \u2713 Verify pivot: ${pivotDateAfter} (should be ${pivotDateBefore})`);
      const didChange = this.checkAndSwitchTimeframe(pivotTime, pivotRatio);
      if (!didChange) {
        const currentWidth = this.state.viewEnd - this.state.viewStart;
        if (currentWidth < minWidth) {
          this.state.viewStart = pivotTime - minWidth * pivotRatio;
          this.state.viewEnd = pivotTime + minWidth * (1 - pivotRatio);
          console.log(`   \u26A0\uFE0F Clamped to minWidth, new view: ${new Date(this.state.viewStart * 1e3).toISOString().substring(0, 16)} \u2192 ${new Date(this.state.viewEnd * 1e3).toISOString().substring(0, 16)}`);
        }
        this.checkAndReloadData();
        this.scheduleRender();
      }
    } finally {
      this.state.isProcessingZoom = false;
    }
  }
  handleMouseMove(e2) {
    const rect = this.overlayCanvas.getBoundingClientRect();
    this.state.mouseX = e2.clientX - rect.left;
    this.state.mouseY = e2.clientY - rect.top;
    if (this.state.isDragging) {
      this.handleDrag(e2);
    } else {
      this.state.showCrosshair = true;
      this.updateCrosshair();
      this.scheduleOverlayRender();
    }
  }
  handleMouseLeave() {
    this.state.showCrosshair = false;
    this.state.mouseX = -1;
    this.state.mouseY = -1;
    const w2 = this.app.screen.width;
    const h2 = this.app.screen.height;
    this.overlayCtx.clearRect(0, 0, w2, h2);
    this.renderStaticOverlay();
  }
  handleMouseDown(e2) {
    if (this.state.isLoading || this.state.data.length === 0) return;
    this.state.isDragging = true;
    this.state.dragStartX = e2.clientX;
    this.state.dragStartViewStart = this.state.viewStart;
    this.state.dragStartViewEnd = this.state.viewEnd;
    this.overlayCanvas.style.cursor = "grabbing";
  }
  handleMouseUp() {
    this.state.isDragging = false;
    this.overlayCanvas.style.cursor = "crosshair";
    this.checkAndReloadData();
  }
  handleDrag(e2) {
    const dx = e2.clientX - this.state.dragStartX;
    const rect = this.overlayCanvas.getBoundingClientRect();
    const viewWidth = this.state.dragStartViewEnd - this.state.dragStartViewStart;
    const timeShift = -dx * viewWidth / rect.width;
    this.state.viewStart = this.state.dragStartViewStart + timeShift;
    this.state.viewEnd = this.state.dragStartViewEnd + timeShift;
    this.scheduleRender();
  }
  handleResize() {
    this.resizeCanvas();
    this.renderBackground();
    this.render();
  }
  checkAndSwitchTimeframe(pivotTime = null, pivotRatio = null) {
    const viewWidth = this.state.viewEnd - this.state.viewStart;
    const tfSeconds = this.parseTimeframeToSeconds(this.state.currentTimeframe);
    const visibleBars = viewWidth / tfSeconds;
    const currentIndex = this.timeframes.indexOf(this.state.currentTimeframe);
    if (visibleBars < this.state.minBars && currentIndex > 0) {
      const newTF = this.timeframes[currentIndex - 1];
      const savedRange = {
        start: this.state.viewStart,
        end: this.state.viewEnd,
        oldTFSeconds: tfSeconds,
        // Sauvegarder l'ancien TF pour calculer le nombre de bougies
        pivotTime,
        // Sauvegarder le pivot pour le préserver
        pivotRatio
        // Position relative du pivot dans la vue
      };
      console.log(`\u{1F53D} Zoom IN: ${this.state.currentTimeframe} \u2192 ${newTF} (${Math.round(visibleBars)} bars < ${this.state.minBars})`);
      console.log(`   \u{1F4BE} Saving current view with pivot at ${pivotTime ? new Date(pivotTime * 1e3).toISOString().substring(0, 16) : "N/A"} (ratio: ${pivotRatio ? pivotRatio.toFixed(3) : "N/A"})`);
      this.callbacks.onTimeframeChange(newTF, savedRange);
      return true;
    }
    if (visibleBars > this.state.maxBars && currentIndex < this.timeframes.length - 1) {
      const newTF = this.timeframes[currentIndex + 1];
      const savedRange = {
        start: this.state.viewStart,
        end: this.state.viewEnd,
        oldTFSeconds: tfSeconds,
        // Sauvegarder l'ancien TF pour calculer le nombre de bougies
        pivotTime,
        // Sauvegarder le pivot pour le préserver
        pivotRatio
        // Position relative du pivot dans la vue
      };
      console.log(`\u{1F53C} Zoom OUT: ${this.state.currentTimeframe} \u2192 ${newTF} (${Math.round(visibleBars)} bars > ${this.state.maxBars})`);
      console.log(`   \u{1F4BE} Saving current view with pivot at ${pivotTime ? new Date(pivotTime * 1e3).toISOString().substring(0, 16) : "N/A"} (ratio: ${pivotRatio ? pivotRatio.toFixed(3) : "N/A"})`);
      this.callbacks.onTimeframeChange(newTF, savedRange);
      return true;
    }
    return false;
  }
  checkAndReloadData() {
    if (this.state.isLoading || this.state.data.length === 0) return;
    const dataStart = this.state.data[0].time;
    const dataEnd = this.state.data[this.state.data.length - 1].time;
    const viewWidth = this.state.viewEnd - this.state.viewStart;
    const threshold = viewWidth * 0.5;
    const needsReload = this.state.viewStart < dataStart + threshold || this.state.viewEnd > dataEnd - threshold;
    if (needsReload) {
      console.log(`\u{1F504} Reloading data - view approaching data boundaries`);
      console.log(`   Data range: ${new Date(dataStart * 1e3).toISOString().substring(0, 16)} \u2192 ${new Date(dataEnd * 1e3).toISOString().substring(0, 16)}`);
      console.log(`   View range: ${new Date(this.state.viewStart * 1e3).toISOString().substring(0, 16)} \u2192 ${new Date(this.state.viewEnd * 1e3).toISOString().substring(0, 16)}`);
      this.loadData(this.state.symbol, this.state.currentTimeframe);
    }
  }
  updateCrosshair() {
    if (!this.state.showCrosshair || this.state.data.length === 0) return;
    const rect = this.overlayCanvas.getBoundingClientRect();
    const chartWidth = rect.width - this.layout.marginLeft - this.layout.marginRight;
    const relativeX = (this.state.mouseX - this.layout.marginLeft) / chartWidth;
    const timestampUnderCursor = this.state.viewStart + relativeX * (this.state.viewEnd - this.state.viewStart);
    let closest = null;
    let minDist = Infinity;
    for (const candle of this.state.data) {
      if (candle.time < this.state.viewStart || candle.time > this.state.viewEnd) continue;
      const dist = Math.abs(candle.time - timestampUnderCursor);
      if (dist < minDist) {
        minDist = dist;
        closest = candle;
      }
    }
    this.state.crosshairCandle = closest;
  }
  async loadData(symbol, timeframe, savedRange = null) {
    console.log(`\u{1F4CA} loadData() called: symbol=${symbol}, TF=${timeframe}, isLoading=${this.state.isLoading}`);
    if (this.state.isLoading) {
      console.warn("\u26A0\uFE0F Already loading data, ignoring loadData() call");
      return;
    }
    if (savedRange === null && this.state.data.length > 0 && this.state.viewStart !== 0) {
      savedRange = {
        start: this.state.viewStart,
        end: this.state.viewEnd
      };
      console.log(`\u{1F4BE} Saving exact range: ${new Date(savedRange.start * 1e3).toISOString()} \u2192 ${new Date(savedRange.end * 1e3).toISOString()}`);
    }
    this.state.symbol = symbol;
    this.state.currentTimeframe = timeframe;
    this.state.isLoading = true;
    this.renderLoading();
    try {
      let fetchStart = null;
      let fetchEnd = null;
      if (savedRange) {
        const width = savedRange.end - savedRange.start;
        const margin = width * 2;
        fetchStart = Math.floor(savedRange.start - margin);
        fetchEnd = Math.ceil(savedRange.end + margin);
      } else if (this.state.viewStart !== 0 && this.state.viewEnd !== 0) {
        const width = this.state.viewEnd - this.state.viewStart;
        const margin = width * 2;
        fetchStart = Math.floor(this.state.viewStart - margin);
        fetchEnd = Math.ceil(this.state.viewEnd + margin);
      }
      console.log(`\u{1F4E1} Fetching data range: ${fetchStart ? new Date(fetchStart * 1e3).toISOString().substring(0, 16) : "auto"} \u2192 ${fetchEnd ? new Date(fetchEnd * 1e3).toISOString().substring(0, 16) : "auto"}`);
      let data = await this.callbacks.onLoadData(symbol, timeframe, fetchStart, fetchEnd);
      if (!Array.isArray(data) || data.length === 0) {
        throw new Error("No data received");
      }
      this.state.data = data;
      console.log(`\u2705 Loaded ${data.length} candles for ${symbol} ${timeframe}`);
      const didFetch = await this.fillGapsIfNeeded(symbol, timeframe, data);
      if (didFetch) {
        data = await this.callbacks.onLoadData(symbol, timeframe, fetchStart, fetchEnd);
        this.state.data = data;
        console.log(`\u{1F504} Reloaded ${data.length} candles apr\xE8s fetch`);
      }
      const prices = data.flatMap((c2) => [c2.high, c2.low]);
      this.state.priceMin = Math.min(...prices);
      this.state.priceMax = Math.max(...prices);
      if (savedRange === null) {
        this.fitToData();
      } else {
        this.restoreViewFromRange(savedRange);
      }
      await this.loadIndicatorData();
      this.renderBackground();
      this.render();
      this.startRealtimeUpdates();
    } catch (error) {
      this.callbacks.onError(error);
      this.renderError(error.message);
    } finally {
      this.state.isLoading = false;
    }
  }
  async fillGapsIfNeeded(symbol, timeframe, data) {
    if (data.length === 0) return false;
    const lastCandle = data[data.length - 1];
    const now = Math.floor(Date.now() / 1e3);
    const gapSeconds = now - lastCandle.time;
    const tfSeconds = this.parseTimeframeToSeconds(timeframe);
    const missingCandles = gapSeconds / tfSeconds;
    if (missingCandles > 2) {
      console.log(`\u{1F50D} Gap d\xE9tect\xE9: ${Math.floor(missingCandles)} bougies manquantes, fetch...`);
      try {
        const response = await fetch(`/api/fetch?symbol=${symbol}&timeframe=${timeframe}`, {
          method: "POST"
        });
        if (response.ok) {
          const result = await response.json();
          if (result.inserted > 0) {
            console.log(`\u2705 ${result.inserted} bougies ajout\xE9es`);
            return true;
          }
        }
      } catch (error) {
        console.error("\u274C Erreur fetch:", error);
      }
    }
    return false;
  }
  async startRealtimeUpdates() {
    if (!this.state.symbol) {
      console.warn("\u26A0\uFE0F Cannot start realtime updates: no symbol");
      return;
    }
    if (this.realtimeUpdating) {
      console.log("\u23ED\uFE0F  Already updating realtime, skipping");
      return;
    }
    this.realtimeUpdating = true;
    try {
      const currentIdx = this.timeframes.indexOf(this.state.currentTimeframe);
      const watchedTFs = /* @__PURE__ */ new Set();
      if (currentIdx > 0) {
        watchedTFs.add(this.timeframes[currentIdx - 1]);
      }
      watchedTFs.add(this.state.currentTimeframe);
      if (currentIdx < this.timeframes.length - 1) {
        watchedTFs.add(this.timeframes[currentIdx + 1]);
      }
      const tfArray = Array.from(watchedTFs).sort(
        (a2, b2) => this.parseTimeframeToSeconds(a2) - this.parseTimeframeToSeconds(b2)
      );
      const newStreams = [];
      for (const tf of tfArray) {
        const streamKey = `${this.state.symbol}:${tf}`;
        if (!this.realtimeSubscribed.has(streamKey)) {
          newStreams.push(tf);
          this.realtimeSubscribed.add(streamKey);
        }
      }
      if (!this.realtimeWs || this.realtimeWs.readyState !== WebSocket.OPEN) {
        this.connectWebSocket();
      }
      if (newStreams.length > 0 && this.realtimeWs && this.realtimeWs.readyState === WebSocket.OPEN) {
        console.log(`\u{1F50C} Subscribing to new streams for ${this.state.symbol}: ${newStreams.join(", ")}`);
        const subscribeMsg = {
          action: "subscribe",
          symbol: this.state.symbol,
          timeframes: tfArray
        };
        this.realtimeWs.send(JSON.stringify(subscribeMsg));
      }
    } finally {
      this.realtimeUpdating = false;
    }
  }
  connectWebSocket() {
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    const wsUrl = `${protocol}//${window.location.host}/ws/realtime`;
    console.log("\u{1F50C} Connecting to WebSocket:", wsUrl);
    this.realtimeWs = new WebSocket(wsUrl);
    this.realtimeWs.onopen = () => {
      console.log("\u2705 WebSocket connected");
    };
    this.realtimeWs.onmessage = (event) => {
      try {
        const msg = JSON.parse(event.data);
        if (msg.type === "candle_update") {
          this.handleRealtimeCandle(msg.timeframe, msg.candle, msg.candle.is_closed, true);
        } else if (msg.type === "subscribed") {
          console.log(`\u2705 Subscribed to ${msg.symbol} [${msg.timeframes.join(", ")}]`);
        } else if (msg.type === "error") {
          console.error("\u274C WebSocket error:", msg.message);
        }
      } catch (error) {
        console.error("Failed to parse WebSocket message:", error);
      }
    };
    this.realtimeWs.onerror = (error) => {
      console.error("\u274C WebSocket error:", error);
    };
    this.realtimeWs.onclose = () => {
      console.log("\u{1F50C} WebSocket closed, will reconnect on next update");
      this.realtimeWs = null;
    };
  }
  stopRealtimeUpdates() {
    if (this.realtimeWs) {
      this.realtimeWs.close();
      this.realtimeWs = null;
    }
    this.realtimeCandles.clear();
    console.log("\u{1F6D1} Stopped realtime WebSocket");
  }
  handleRealtimeCandle(timeframe, candle, isComplete, shouldRender = true) {
    this.realtimeCandles.set(timeframe, candle);
    let updated = false;
    if (timeframe === this.state.currentTimeframe) {
      const lastIndex = this.state.data.length - 1;
      if (lastIndex >= 0) {
        const lastCandle = this.state.data[lastIndex];
        const tfSeconds = this.parseTimeframeToSeconds(timeframe);
        if (lastCandle.time === candle.time) {
          this.state.data[lastIndex] = candle;
          updated = true;
        } else if (candle.time === lastCandle.time + tfSeconds) {
          this.state.data.push(candle);
          console.log(`\u2705 New candle added for ${timeframe} at ${new Date(candle.time * 1e3).toISOString().substring(0, 16)}`);
          const isAtEnd = this.state.viewEnd >= lastCandle.time + tfSeconds * 0.5;
          if (isAtEnd) {
            const viewWidth = this.state.viewEnd - this.state.viewStart;
            this.state.viewEnd = candle.time + tfSeconds;
            this.state.viewStart = this.state.viewEnd - viewWidth;
            console.log(`\u{1F4CD} Auto-scroll: view moved to ${new Date(this.state.viewStart * 1e3).toISOString().substring(0, 16)} \u2192 ${new Date(this.state.viewEnd * 1e3).toISOString().substring(0, 16)}`);
          }
          updated = true;
        } else if (candle.time > lastCandle.time + tfSeconds) {
          console.log(`\u{1F4CD} Skipping gap (${Math.floor((candle.time - lastCandle.time - tfSeconds) / tfSeconds)} candles missing), adding current candle`);
          this.state.data.push(candle);
          updated = true;
        }
        if (updated) {
          this.updateRealtimeRSI();
          if (shouldRender) {
            this.scheduleRender();
          }
        }
      }
    } else {
      if (isComplete) {
        console.log(`\u{1F4CA} Complete candle on ${timeframe} (RSI update skipped for performance)`);
        updated = true;
      }
    }
    return updated;
  }
  async updateSingleTimeframeRSI(timeframe) {
    if (!chartConfig.get("indicators.enabled")) return;
    const period = chartConfig.get("indicators.rsi.period") || 14;
    try {
      const margin = (this.state.viewEnd - this.state.viewStart) * 2;
      const data = await this.callbacks.onLoadData(
        this.state.symbol,
        timeframe,
        Math.floor(this.state.viewStart - margin),
        Math.ceil(this.state.viewEnd + margin)
      );
      if (data && data.length > period) {
        const rsi = this.calculateRSI(data, period);
        const referenceTimestamps = this.state.data.map((c2) => c2.time);
        const resampled = this.resampleIndicatorToGrid(rsi, referenceTimestamps);
        this.rsiData.set(timeframe, resampled);
        console.log(`\u{1F4CA} Updated RSI for ${timeframe} (${resampled.length} points)`);
        this.render();
      }
    } catch (e2) {
      console.error(`\u274C Failed to update RSI for ${timeframe}:`, e2);
    }
  }
  updateRealtimeRSI() {
    if (!chartConfig.get("indicators.enabled")) return;
    const period = chartConfig.get("indicators.rsi.period") || 14;
    if (this.state.data.length > period + 1) {
      const maxSamples = period * 2;
      const dataToUse = this.state.data.length > maxSamples ? this.state.data.slice(-maxSamples) : this.state.data;
      const rsi = this.calculateRSI(dataToUse, period);
      const existingRSI = this.rsiData.get(this.state.currentTimeframe) || [];
      const rsiPointsToReplace = Math.min(rsi.length, 10);
      if (existingRSI.length > rsiPointsToReplace) {
        const updatedRSI = existingRSI.slice(0, -rsiPointsToReplace).concat(rsi.slice(-rsiPointsToReplace));
        this.rsiData.set(this.state.currentTimeframe, updatedRSI);
      } else {
        this.rsiData.set(this.state.currentTimeframe, rsi);
      }
    }
  }
  async loadIndicatorData() {
    console.log(`\u{1F4CA} loadIndicatorData() called - enabled: ${chartConfig.get("indicators.enabled")}, symbol: ${this.state.symbol}, data: ${this.state.data.length} candles`);
    if (!chartConfig.get("indicators.enabled")) {
      this.rsiData.clear();
      return;
    }
    if (!this.state.symbol || this.state.data.length === 0) {
      console.warn("\u26A0\uFE0F Cannot load indicators: no symbol or no data");
      this.rsiData.clear();
      return;
    }
    this.rsiData.clear();
    const currentIdx = this.timeframes.indexOf(this.state.currentTimeframe);
    const rsiTimeframes = [];
    if (currentIdx > 0) {
      rsiTimeframes.push(this.timeframes[currentIdx - 1]);
    }
    rsiTimeframes.push(this.state.currentTimeframe);
    if (currentIdx < this.timeframes.length - 1) {
      rsiTimeframes.push(this.timeframes[currentIdx + 1]);
    }
    console.log(`\u{1F4CA} Current TF: ${this.state.currentTimeframe}, RSI TFs: ${rsiTimeframes.join(", ")}`);
    const period = chartConfig.get("indicators.rsi.period") || 14;
    const referenceTimestamps = this.state.data.map((c2) => c2.time);
    console.log(`\u{1F4CA} Reference timestamps: ${referenceTimestamps.length} candles`);
    for (const tf of rsiTimeframes) {
      try {
        const margin = (this.state.viewEnd - this.state.viewStart) * 2;
        console.log(`\u{1F4CA} Loading ${tf} data for RSI (${this.state.symbol})...`);
        let data = await this.callbacks.onLoadData(
          this.state.symbol,
          tf,
          Math.floor(this.state.viewStart - margin),
          Math.ceil(this.state.viewEnd + margin)
        );
        console.log(`\u{1F4CA} Loaded ${data?.length || 0} candles for ${tf}`);
        if (data && data.length > period) {
          const rsi = this.calculateRSI(data, period);
          console.log(`\u{1F4CA} Calculated ${rsi.length} RSI points for ${tf}`);
          const resampled = this.resampleIndicatorToGrid(rsi, referenceTimestamps);
          console.log(`\u{1F4CA} Resampled to ${resampled.length} points for ${tf}`);
          this.rsiData.set(tf, resampled);
          if (!this.rsiVisibility.has(tf)) {
            this.rsiVisibility.set(tf, true);
          }
        } else {
          console.warn(`\u274C Not enough data for RSI on ${tf}: ${data?.length || 0} candles (need > ${period})`);
        }
      } catch (e2) {
        console.error(`\u274C Failed to load RSI data for ${tf}:`, e2);
      }
    }
    console.log(`\u{1F4CA} RSI data loaded for ${this.rsiData.size} timeframes`);
    this.updateRSILegend();
  }
  updateRSILegend() {
    this.legendContainer.innerHTML = "";
    if (this.rsiData.size === 0 || !chartConfig.get("indicators.enabled")) return;
    this.rsiData.forEach((data, tf) => {
      const color = this.getRSIColorForTimeframe(tf);
      const label = document.createElement("label");
      label.style.cssText = `display: inline-flex; align-items: center; margin: 0 10px 5px 0; padding: 4px 8px; background: rgba(0,0,0,0.7); border-radius: 4px; font-size: 11px; color: ${color}; cursor: pointer; font-family: monospace;`;
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = this.rsiVisibility.get(tf) || false;
      checkbox.style.marginRight = "5px";
      checkbox.style.cursor = "pointer";
      checkbox.addEventListener("change", () => {
        this.rsiVisibility.set(tf, checkbox.checked);
        this.scheduleRender();
      });
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(`RSI ${tf}`));
      this.legendContainer.appendChild(label);
    });
  }
  resampleIndicatorToGrid(indicatorData, targetTimestamps) {
    const sorted = [...indicatorData].sort((a2, b2) => a2.time - b2.time);
    return targetTimestamps.map((targetTime) => {
      let lastValid = null;
      for (const point of sorted) {
        if (point.time <= targetTime) {
          lastValid = point;
        } else {
          break;
        }
      }
      if (!lastValid) return null;
      return { time: targetTime, value: lastValid.value };
    }).filter((p2) => p2 !== null);
  }
  getRSIColorForTimeframe(tf) {
    const intensity = chartConfig.get("indicators.rsi.heatIntensity") || 1;
    const loadedTFs = Array.from(this.rsiData.keys()).sort(
      (a2, b3) => this.parseTimeframeToSeconds(a2) - this.parseTimeframeToSeconds(b3)
    );
    const tfIndex = loadedTFs.indexOf(tf);
    if (tfIndex === -1) return "#FF8C00";
    const normalizedIndex = loadedTFs.length > 1 ? tfIndex / (loadedTFs.length - 1) : 0.5;
    const r2 = 255;
    const g2 = Math.round(215 * (1 - normalizedIndex));
    const b2 = 0;
    return `#${r2.toString(16).padStart(2, "0")}${g2.toString(16).padStart(2, "0")}${b2.toString(16).padStart(2, "0")}`;
  }
  fitToData() {
    if (this.state.data.length === 0) return;
    const barsToShow = Math.min(100, this.state.data.length);
    const tfSeconds = this.parseTimeframeToSeconds(this.state.currentTimeframe);
    this.state.viewEnd = this.state.data[this.state.data.length - 1].time + tfSeconds;
    this.state.viewStart = this.state.viewEnd - barsToShow * tfSeconds;
  }
  restoreViewFromRange(savedRange) {
    this.state.viewStart = savedRange.start;
    this.state.viewEnd = savedRange.end;
    const oldTFSeconds = savedRange.oldTFSeconds || this.parseTimeframeToSeconds(this.state.currentTimeframe);
    const newTFSeconds = this.parseTimeframeToSeconds(this.state.currentTimeframe);
    const savedWidth = savedRange.end - savedRange.start;
    const oldBarsCount = Math.round(savedWidth / oldTFSeconds);
    const newBarsCount = Math.round(savedWidth / newTFSeconds);
    console.log(`\u{1F4CA} Timeframe change: ${oldBarsCount} bars \u2192 ${newBarsCount} bars`);
    console.log(`   Fixed window: ${new Date(this.state.viewStart * 1e3).toISOString().substring(0, 16)} \u2192 ${new Date(this.state.viewEnd * 1e3).toISOString().substring(0, 16)}`);
  }
  renderBackground() {
    const w2 = this.app.screen.width;
    const h2 = this.app.screen.height;
    this.bgLayer.removeChildren();
    const bgColor = this.theme.bg === "#ffffff" ? 16777215 : parseInt(this.theme.bg.replace("#", ""), 16);
    const bg = new Graphics();
    bg.beginFill(bgColor);
    bg.drawRect(0, 0, w2, h2);
    bg.endFill();
    this.bgLayer.addChild(bg);
    const chartX = this.layout.marginLeft;
    const chartY = this.layout.marginTop;
    const chartW = w2 - this.layout.marginLeft - this.layout.marginRight;
    const chartH = h2 - this.layout.marginTop - this.layout.marginBottom;
    const gridOpacity = chartConfig.get("grid.opacity");
    const gridColor = parseInt(this.theme.grid.replace("#", ""), 16);
    const grid = new Graphics();
    grid.lineStyle(1, gridColor, gridOpacity);
    const numLines = chartConfig.get("grid.horizontal");
    for (let i2 = 0; i2 <= numLines; i2++) {
      const y2 = chartY + i2 / numLines * chartH;
      grid.moveTo(chartX, y2);
      grid.lineTo(chartX + chartW, y2);
    }
    const numTimeLines = chartConfig.get("grid.vertical");
    for (let i2 = 0; i2 <= numTimeLines; i2++) {
      const x2 = chartX + i2 / numTimeLines * chartW;
      grid.moveTo(x2, chartY);
      grid.lineTo(x2, chartY + chartH);
    }
    this.bgLayer.addChild(grid);
    if (chartConfig.get("watermark.enabled") && this.state.symbol) {
      this.renderWatermark(w2, h2);
    }
  }
  renderWatermark(w2, h2) {
    const opacity = chartConfig.get("watermark.opacity") / 100;
    const fontSize = chartConfig.get("watermark.fontSize");
    const text = `${this.state.symbol} ${this.state.currentTimeframe}`;
    const watermark = new Text(text, {
      fontFamily: "sans-serif",
      fontSize,
      fontWeight: "bold",
      fill: this.theme.textLight,
      align: "center"
    });
    watermark.anchor.set(0.5);
    watermark.x = w2 / 2;
    watermark.y = h2 / 2;
    watermark.alpha = opacity;
    this.bgLayer.addChild(watermark);
  }
  /**
   * Planifie un rendu complet via requestAnimationFrame
   * Évite plusieurs rendus par frame
   */
  scheduleRender() {
    if (this.renderScheduled) return;
    this.renderScheduled = true;
    requestAnimationFrame(() => {
      this.renderScheduled = false;
      this.render();
    });
  }
  /**
   * Planifie un rendu d'overlay uniquement via requestAnimationFrame
   * Plus léger que render() complet
   */
  scheduleOverlayRender() {
    if (this.overlayRenderScheduled) return;
    this.overlayRenderScheduled = true;
    requestAnimationFrame(() => {
      this.overlayRenderScheduled = false;
      this.renderOverlayOnly();
    });
  }
  render() {
    if (this.state.data.length === 0) return;
    const w2 = this.app.screen.width;
    const h2 = this.app.screen.height;
    this.wicksGraphics.clear();
    this.bodiesUpFilledGraphics.clear();
    this.bodiesUpHollowGraphics.clear();
    this.bodiesDownGraphics.clear();
    this.bordersGraphics.clear();
    this.realtimeMarkersGraphics.clear();
    this.volumeGraphics.clear();
    this.rsiGraphics.clear();
    this.indicatorBgGraphics.clear();
    this.overlayCtx.clearRect(0, 0, w2, h2);
    const chartX = this.layout.marginLeft;
    const chartY = this.layout.marginTop;
    const chartW = w2 - this.layout.marginLeft - this.layout.marginRight;
    let chartH = h2 - this.layout.marginTop - this.layout.marginBottom;
    let indicatorH = 0;
    if (chartConfig.get("indicators.enabled") && this.rsiData.size > 0 && !chartConfig.get("indicators.rsi.overlay")) {
      const indicatorHeightPercent = chartConfig.get("indicators.heightPercent") / 100;
      indicatorH = h2 * indicatorHeightPercent;
      chartH = chartH - indicatorH - 5;
    }
    const visibleCandles = this.state.data.filter(
      (c2) => c2.time >= this.state.viewStart && c2.time <= this.state.viewEnd
    );
    if (visibleCandles.length === 0) {
      this.renderNoData();
      return;
    }
    const visiblePrices = visibleCandles.flatMap((c2) => [c2.high, c2.low]);
    const priceMin = Math.min(...visiblePrices);
    const priceMax = Math.max(...visiblePrices);
    const priceRange = priceMax - priceMin;
    const padding = priceRange * 0.05;
    const priceToY = (price) => {
      const ratio = (price - (priceMin - padding)) / (priceRange + 2 * padding);
      return chartY + chartH * (1 - ratio);
    };
    const timeToX = (time) => {
      const ratio = (time - this.state.viewStart) / (this.state.viewEnd - this.state.viewStart);
      return chartX + ratio * chartW;
    };
    this.renderPriceAxis(priceMin, priceMax, priceRange, priceToY, chartY, chartH);
    let volumeHeight = 0;
    if (chartConfig.get("volume.enabled")) {
      volumeHeight = chartH * (chartConfig.get("volume.heightPercent") / 100);
      this.renderVolume(visibleCandles, chartX, chartY, chartW, chartH, volumeHeight, timeToX);
    }
    const tfSeconds = this.parseTimeframeToSeconds(this.state.currentTimeframe);
    const candleWidthSeconds = (this.state.viewEnd - this.state.viewStart) / chartW;
    const candleWidth = Math.max(1, Math.min(50, tfSeconds / candleWidthSeconds * 0.8));
    const borderWidth = chartConfig.get("candles.borderWidth");
    const wickWidth = chartConfig.get("candles.wickWidth");
    const hollowUp = chartConfig.get("candles.hollowUp");
    const minBodyHeight = chartConfig.get("candles.minBodyHeight");
    const realtimeCandle = this.realtimeCandles.get(this.state.currentTimeframe);
    const realtimeCandleTime = realtimeCandle?.time || null;
    const upColor = parseInt(this.theme.upColor.replace("#", ""), 16);
    const downColor = parseInt(this.theme.downColor.replace("#", ""), 16);
    const upBorderColor = parseInt(this.theme.upBorderColor.replace("#", ""), 16);
    const downBorderColor = parseInt(this.theme.downBorderColor.replace("#", ""), 16);
    visibleCandles.forEach((candle) => {
      const x2 = timeToX(candle.time);
      const yOpen = priceToY(candle.open);
      const yClose = priceToY(candle.close);
      const yHigh = priceToY(candle.high);
      const yLow = priceToY(candle.low);
      const isUp = candle.close >= candle.open;
      const color = isUp ? upColor : downColor;
      const borderColor = isUp ? upBorderColor : downBorderColor;
      const isRealtimeCandle = realtimeCandleTime !== null && candle.time === realtimeCandleTime;
      if (isRealtimeCandle) {
        const markerY = yLow + 8;
        this.realtimeMarkersGraphics.lineStyle(2, 8421504, 0.6);
        this.realtimeMarkersGraphics.moveTo(x2 - candleWidth / 2, markerY);
        this.realtimeMarkersGraphics.lineTo(x2 + candleWidth / 2, markerY);
      }
      this.wicksGraphics.lineStyle(wickWidth, color, 1);
      this.wicksGraphics.moveTo(x2, yHigh);
      this.wicksGraphics.lineTo(x2, yLow);
      const bodyTop = Math.min(yOpen, yClose);
      const bodyHeight = Math.max(minBodyHeight, Math.abs(yClose - yOpen));
      if (isUp && hollowUp) {
        if (borderWidth > 0) {
          this.bodiesUpHollowGraphics.lineStyle(borderWidth, borderColor, 1);
          this.bodiesUpHollowGraphics.drawRect(x2 - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
        }
      } else if (isUp) {
        this.bodiesUpFilledGraphics.beginFill(color);
        this.bodiesUpFilledGraphics.drawRect(x2 - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
        this.bodiesUpFilledGraphics.endFill();
        if (borderWidth > 0) {
          this.bordersGraphics.lineStyle(borderWidth, borderColor, 1);
          this.bordersGraphics.drawRect(x2 - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
        }
      } else {
        this.bodiesDownGraphics.beginFill(color);
        this.bodiesDownGraphics.drawRect(x2 - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
        this.bodiesDownGraphics.endFill();
        if (borderWidth > 0) {
          this.bordersGraphics.lineStyle(borderWidth, borderColor, 1);
          this.bordersGraphics.drawRect(x2 - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
        }
      }
    });
    this.wicksGraphics.stroke();
    this.realtimeMarkersGraphics.stroke();
    this.bodiesUpHollowGraphics.stroke();
    this.bordersGraphics.stroke();
    if (chartConfig.get("indicators.enabled") && this.rsiData.size > 0) {
      console.log(`\u{1F4CA} Rendering ${this.rsiData.size} RSI timeframes`);
      const overlay = chartConfig.get("indicators.rsi.overlay");
      if (overlay) {
        const candleChartH = chartH - volumeHeight;
        this.renderIndicatorsOverlay(chartX, chartY, chartW, candleChartH, timeToX, priceMin, priceMax, priceRange);
      } else {
        this.renderIndicatorsSeparate(chartX, chartY, chartW, chartH, indicatorH, timeToX);
      }
    }
    const indicatorY = chartY + chartH + 5;
    this.overlayParams = {
      w: w2,
      h: h2,
      priceMin,
      priceMax,
      priceRange,
      priceToY,
      chartX,
      chartY,
      chartW,
      chartH,
      visibleCandles,
      volumeHeight,
      indicatorH,
      indicatorY,
      timeToX
    };
    this.renderStaticOverlay();
    if (this.state.showCrosshair) {
      this.renderDynamicOverlay();
    }
  }
  renderVolume(candles, chartX, chartY, chartW, chartH, volumeHeight, timeToX) {
    if (candles.length === 0) return;
    const maxVolume = Math.max(...candles.map((c2) => c2.volume));
    const volUpColorStr = chartConfig.get("colors.volumeUpColor");
    const volDownColorStr = chartConfig.get("colors.volumeDownColor");
    const matchUp = volUpColorStr.match(/^#([0-9a-f]{6})([0-9a-f]{2})?$/i);
    const volUpColor = matchUp ? parseInt(matchUp[1], 16) : 2533018;
    const volUpAlpha = matchUp && matchUp[2] ? parseInt(matchUp[2], 16) / 255 : 0.5;
    const matchDown = volDownColorStr.match(/^#([0-9a-f]{6})([0-9a-f]{2})?$/i);
    const volDownColor = matchDown ? parseInt(matchDown[1], 16) : 15684432;
    const volDownAlpha = matchDown && matchDown[2] ? parseInt(matchDown[2], 16) / 255 : 0.5;
    const barWidth = Math.max(1, chartW / candles.length * 0.8);
    candles.forEach((candle) => {
      const x2 = timeToX(candle.time);
      const height = candle.volume / maxVolume * volumeHeight * 0.95;
      const y2 = chartY + chartH - height;
      const isUp = candle.close >= candle.open;
      const color = isUp ? volUpColor : volDownColor;
      const alpha = isUp ? volUpAlpha : volDownAlpha;
      this.volumeGraphics.beginFill(color, alpha);
      this.volumeGraphics.drawRect(x2 - barWidth / 2, y2, barWidth, height);
      this.volumeGraphics.endFill();
    });
  }
  renderIndicatorsOverlay(chartX, chartY, chartW, chartH, timeToX, priceMin, priceMax, priceRange) {
    if (this.rsiData.size === 0) {
      console.log("\u{1F4CA} No RSI data to render (overlay mode)");
      return;
    }
    console.log(`\u{1F4CA} Rendering RSI (overlay mode) for ${this.rsiData.size} timeframes`);
    const rsiToY = (value) => {
      const ratio = value / 100;
      return chartY + chartH * (1 - ratio);
    };
    this.rsiData.forEach((data, tf) => {
      if (!this.rsiVisibility.get(tf)) return;
      const colorStr = this.getRSIColorForTimeframe(tf);
      const color = parseInt(colorStr.replace("#", ""), 16);
      this.rsiGraphics.lineStyle(1.5, color, 1);
      let first = true;
      data.forEach((point) => {
        if (point.time >= this.state.viewStart && point.time <= this.state.viewEnd) {
          const x2 = timeToX(point.time);
          const y2 = rsiToY(point.value);
          if (first) {
            this.rsiGraphics.moveTo(x2, y2);
            first = false;
          } else {
            this.rsiGraphics.lineTo(x2, y2);
          }
        }
      });
      this.rsiGraphics.stroke();
    });
  }
  renderIndicatorsSeparate(chartX, chartY, chartW, chartH, indicatorH, timeToX) {
    if (this.rsiData.size === 0) {
      console.log("\u{1F4CA} No RSI data to render (separate mode)");
      return;
    }
    console.log(`\u{1F4CA} Rendering RSI (separate mode) for ${this.rsiData.size} timeframes`);
    const indicatorY = chartY + chartH + 5;
    const bgColor = this.theme.bg === "#ffffff" ? 16382457 : 2434341;
    this.indicatorBgGraphics.beginFill(bgColor);
    this.indicatorBgGraphics.drawRect(chartX, indicatorY, chartW, indicatorH);
    this.indicatorBgGraphics.endFill();
    const rsiToY = (value) => indicatorY + indicatorH * (1 - value / 100);
    this.rsiData.forEach((data, tf) => {
      if (!this.rsiVisibility.get(tf)) return;
      const colorStr = this.getRSIColorForTimeframe(tf);
      const color = parseInt(colorStr.replace("#", ""), 16);
      this.rsiGraphics.lineStyle(1.5, color, 1);
      let first = true;
      data.forEach((point) => {
        if (point.time >= this.state.viewStart && point.time <= this.state.viewEnd) {
          const x2 = timeToX(point.time);
          const y2 = rsiToY(point.value);
          if (first) {
            this.rsiGraphics.moveTo(x2, y2);
            first = false;
          } else {
            this.rsiGraphics.lineTo(x2, y2);
          }
        }
      });
      this.rsiGraphics.stroke();
    });
  }
  renderLastPriceLine(candles, chartX, chartW, priceToY) {
    const lastCandle = candles[candles.length - 1];
    if (!lastCandle) return;
    const y2 = priceToY(lastCandle.close);
    const isUp = lastCandle.close >= lastCandle.open;
    const color = isUp ? this.theme.upColor : this.theme.downColor;
    this.overlayCtx.save();
    this.overlayCtx.strokeStyle = color;
    this.overlayCtx.lineWidth = 1;
    const lineStyle = chartConfig.get("lastPrice.lineStyle");
    if (lineStyle === "dashed") {
      this.overlayCtx.setLineDash([4, 4]);
    } else if (lineStyle === "dotted") {
      this.overlayCtx.setLineDash([2, 2]);
    }
    this.overlayCtx.beginPath();
    this.overlayCtx.moveTo(chartX, y2);
    this.overlayCtx.lineTo(chartX + chartW, y2);
    this.overlayCtx.stroke();
    if (chartConfig.get("lastPrice.labelBg")) {
      const text = lastCandle.close.toFixed(2);
      this.overlayCtx.font = "11px monospace";
      const textWidth = this.overlayCtx.measureText(text).width;
      this.overlayCtx.fillStyle = color;
      this.overlayCtx.fillRect(chartX + chartW + 5, y2 - 10, textWidth + 8, 20);
      this.overlayCtx.fillStyle = "#ffffff";
      this.overlayCtx.textAlign = "left";
      this.overlayCtx.textBaseline = "middle";
      this.overlayCtx.fillText(text, chartX + chartW + 9, y2);
    }
    this.overlayCtx.restore();
  }
  formatPrice(price, priceStep) {
    let decimals;
    if (priceStep >= 1e3) {
      decimals = 0;
    } else if (priceStep >= 100) {
      decimals = 0;
    } else if (priceStep >= 10) {
      decimals = 0;
    } else if (priceStep >= 1) {
      decimals = 1;
    } else if (priceStep >= 0.1) {
      decimals = 2;
    } else if (priceStep >= 0.01) {
      decimals = 3;
    } else if (priceStep >= 1e-3) {
      decimals = 4;
    } else {
      decimals = 6;
    }
    return price.toFixed(decimals);
  }
  renderPriceAxis(priceMin, priceMax, priceRange, priceToY, chartY, chartH) {
    this.overlayCtx.save();
    this.overlayCtx.fillStyle = this.theme.text;
    this.overlayCtx.font = "11px monospace";
    this.overlayCtx.textAlign = "right";
    this.overlayCtx.textBaseline = "middle";
    const priceStep = this.calculatePriceStep(priceRange);
    const start = Math.floor(priceMin / priceStep) * priceStep;
    let count2 = 0;
    for (let price = start; price <= priceMax; price += priceStep) {
      const y2 = priceToY(price);
      if (y2 < chartY || y2 > chartY + chartH) continue;
      this.overlayCtx.fillText(this.formatPrice(price, priceStep), this.layout.marginLeft - 8, y2);
      count2++;
    }
    console.log(`\u{1F4CA} Price axis: rendered ${count2} labels`);
    this.overlayCtx.restore();
  }
  renderTimeAxis(w2, h2) {
    this.overlayCtx.save();
    const chartX = this.layout.marginLeft;
    const chartW = w2 - this.layout.marginLeft - this.layout.marginRight;
    const viewDuration = this.state.viewEnd - this.state.viewStart;
    const viewDurationDays = viewDuration / 86400;
    let formatFn;
    let estimatedLabelWidth;
    if (viewDurationDays < 1) {
      formatFn = (ts) => new Date(ts * 1e3).toISOString().substring(11, 16);
      estimatedLabelWidth = 40;
    } else if (viewDurationDays < 30) {
      formatFn = (ts) => {
        const date = new Date(ts * 1e3);
        const iso = date.toISOString();
        return `${iso.substring(5, 10)} ${iso.substring(11, 16)}`;
      };
      estimatedLabelWidth = 80;
    } else if (viewDurationDays < 365) {
      formatFn = (ts) => new Date(ts * 1e3).toISOString().substring(5, 10);
      estimatedLabelWidth = 45;
    } else {
      formatFn = (ts) => new Date(ts * 1e3).toISOString().substring(0, 10);
      estimatedLabelWidth = 70;
    }
    const minSpacing = estimatedLabelWidth + 10;
    const maxLabels = Math.floor(chartW / minSpacing);
    const numLabels = Math.max(3, Math.min(maxLabels, 12));
    this.overlayCtx.fillStyle = this.theme.text;
    this.overlayCtx.font = "11px sans-serif";
    this.overlayCtx.textAlign = "center";
    this.overlayCtx.textBaseline = "top";
    const y2 = h2 - this.layout.marginBottom + 10;
    for (let i2 = 0; i2 <= numLabels; i2++) {
      const ratio = i2 / numLabels;
      const timestamp = this.state.viewStart + ratio * viewDuration;
      const x2 = chartX + ratio * chartW;
      this.overlayCtx.strokeStyle = this.theme.grid;
      this.overlayCtx.globalAlpha = 0.3;
      this.overlayCtx.lineWidth = 1;
      this.overlayCtx.beginPath();
      this.overlayCtx.moveTo(x2, y2 - 5);
      this.overlayCtx.lineTo(x2, y2);
      this.overlayCtx.stroke();
      this.overlayCtx.globalAlpha = 1;
      this.overlayCtx.fillText(formatFn(timestamp), x2, y2 + 2);
    }
    this.overlayCtx.restore();
  }
  renderStaticOverlay() {
    if (!this.overlayParams) return;
    const { w: w2, h: h2, priceMin, priceMax, priceRange, priceToY, chartX, chartY, chartW, chartH, visibleCandles, volumeHeight, indicatorH, indicatorY, timeToX } = this.overlayParams;
    this.renderPriceAxis(priceMin, priceMax, priceRange, priceToY, chartY, chartH);
    this.renderTimeAxis(w2, h2);
    if (chartConfig.get("lastPrice.enabled") && visibleCandles.length > 0) {
      this.renderLastPriceLine(visibleCandles, chartX, chartW, priceToY);
    }
    if (chartConfig.get("indicators.enabled") && this.rsiData.size > 0) {
      const overlay = chartConfig.get("indicators.rsi.overlay");
      if (overlay) {
        const candleChartH = chartH - volumeHeight;
        this.renderRSIScaleOverlay(chartX, chartY, chartW, candleChartH, priceMin, priceMax, priceRange);
      } else {
        this.renderRSIScaleSeparate(chartX, indicatorY, indicatorH);
      }
    }
  }
  renderRSIScaleOverlay(chartX, chartY, chartW, chartH, priceMin, priceMax, priceRange) {
    const padding = priceRange * 0.05;
    const rsiToY = (value) => {
      const ratio = value / 100;
      return chartY + chartH * (1 - ratio);
    };
    this.overlayCtx.save();
    this.overlayCtx.strokeStyle = "#666666";
    this.overlayCtx.lineWidth = 1;
    this.overlayCtx.globalAlpha = 0.25;
    this.overlayCtx.setLineDash([4, 4]);
    [30, 50, 70].forEach((level) => {
      const y2 = rsiToY(level);
      this.overlayCtx.beginPath();
      this.overlayCtx.moveTo(chartX, y2);
      this.overlayCtx.lineTo(chartX + chartW, y2);
      this.overlayCtx.stroke();
    });
    this.overlayCtx.setLineDash([]);
    this.overlayCtx.globalAlpha = 1;
    this.overlayCtx.fillStyle = this.theme.textLight;
    this.overlayCtx.font = "10px monospace";
    this.overlayCtx.textAlign = "left";
    [30, 50, 70].forEach((level) => {
      const y2 = rsiToY(level);
      this.overlayCtx.fillText(`RSI ${level}`, chartX + chartW + 5, y2 + 3);
    });
    this.overlayCtx.restore();
  }
  renderRSIScaleSeparate(chartX, indicatorY, indicatorH) {
    const chartW = this.app.screen.width - this.layout.marginLeft - this.layout.marginRight;
    this.overlayCtx.save();
    this.overlayCtx.strokeStyle = "#666666";
    this.overlayCtx.lineWidth = 1;
    this.overlayCtx.globalAlpha = 0.3;
    this.overlayCtx.setLineDash([4, 4]);
    [30, 50, 70].forEach((level) => {
      const y2 = indicatorY + indicatorH * (1 - level / 100);
      this.overlayCtx.beginPath();
      this.overlayCtx.moveTo(chartX, y2);
      this.overlayCtx.lineTo(chartX + chartW, y2);
      this.overlayCtx.stroke();
    });
    this.overlayCtx.setLineDash([]);
    this.overlayCtx.globalAlpha = 1;
    this.overlayCtx.fillStyle = this.theme.text;
    this.overlayCtx.font = "10px monospace";
    this.overlayCtx.textAlign = "right";
    this.overlayCtx.textBaseline = "middle";
    [0, 30, 50, 70, 100].forEach((level) => {
      const y2 = indicatorY + indicatorH * (1 - level / 100);
      this.overlayCtx.fillText(level.toString(), chartX - 5, y2);
    });
    this.overlayCtx.restore();
  }
  renderDynamicOverlay() {
    if (!this.state.showCrosshair) return;
    const w2 = this.app.screen.width;
    const h2 = this.app.screen.height;
    const chartX = this.layout.marginLeft;
    const chartY = this.layout.marginTop;
    const chartW = w2 - this.layout.marginLeft - this.layout.marginRight;
    const chartH = h2 - this.layout.marginTop - this.layout.marginBottom;
    const crosshairStyle = chartConfig.get("crosshair.style");
    const crosshairWidth = chartConfig.get("crosshair.width");
    let dashArray = [];
    if (crosshairStyle === "dashed") dashArray = [4, 4];
    else if (crosshairStyle === "dotted") dashArray = [2, 2];
    this.overlayCtx.strokeStyle = this.theme.crosshair;
    this.overlayCtx.lineWidth = crosshairWidth;
    this.overlayCtx.setLineDash(dashArray);
    this.overlayCtx.beginPath();
    this.overlayCtx.moveTo(this.state.mouseX, chartY);
    this.overlayCtx.lineTo(this.state.mouseX, chartY + chartH);
    this.overlayCtx.stroke();
    this.overlayCtx.beginPath();
    this.overlayCtx.moveTo(chartX, this.state.mouseY);
    this.overlayCtx.lineTo(chartX + chartW, this.state.mouseY);
    this.overlayCtx.stroke();
    this.overlayCtx.setLineDash([]);
    if (chartConfig.get("crosshair.floatingLabels")) {
      this.renderFloatingLabels(chartX, chartY, chartW, chartH);
    }
    if (this.state.crosshairCandle) {
      this.renderTooltip(this.state.crosshairCandle);
    }
  }
  renderOverlayOnly() {
    const w2 = this.app.screen.width;
    const h2 = this.app.screen.height;
    this.overlayCtx.clearRect(0, 0, w2, h2);
    this.renderStaticOverlay();
    this.renderDynamicOverlay();
  }
  renderFloatingLabels(chartX, chartY, chartW, chartH) {
    if (this.state.data.length > 0) {
      const visibleCandles = this.state.data.filter(
        (c2) => c2.time >= this.state.viewStart && c2.time <= this.state.viewEnd
      );
      if (visibleCandles.length > 0) {
        const visiblePrices = visibleCandles.flatMap((c2) => [c2.high, c2.low]);
        const priceMin = Math.min(...visiblePrices);
        const priceMax = Math.max(...visiblePrices);
        const priceRange = priceMax - priceMin;
        const padding = priceRange * 0.05;
        const mouseYRatio = (this.state.mouseY - chartY) / chartH;
        const price = priceMax + padding - mouseYRatio * (priceRange + 2 * padding);
        this.overlayCtx.fillStyle = this.theme.crosshair;
        this.overlayCtx.fillRect(chartX - 60, this.state.mouseY - 10, 55, 20);
        this.overlayCtx.fillStyle = "#ffffff";
        this.overlayCtx.font = "11px monospace";
        this.overlayCtx.textAlign = "right";
        this.overlayCtx.textBaseline = "middle";
        this.overlayCtx.fillText(price.toFixed(2), chartX - 8, this.state.mouseY);
      }
    }
    const mouseXRatio = (this.state.mouseX - chartX) / chartW;
    const timestamp = this.state.viewStart + mouseXRatio * (this.state.viewEnd - this.state.viewStart);
    const timeStr = new Date(timestamp * 1e3).toISOString().substring(11, 16);
    this.overlayCtx.fillStyle = this.theme.crosshair;
    this.overlayCtx.fillRect(this.state.mouseX - 25, chartY + chartH + 5, 50, 20);
    this.overlayCtx.fillStyle = "#ffffff";
    this.overlayCtx.font = "11px sans-serif";
    this.overlayCtx.textAlign = "center";
    this.overlayCtx.textBaseline = "top";
    this.overlayCtx.fillText(timeStr, this.state.mouseX, chartY + chartH + 10);
  }
  renderTooltip(candle) {
    const padding = 8;
    const lineHeight = 16;
    const date = new Date(candle.time * 1e3);
    const utcStr = date.toISOString().substring(0, 19).replace("T", " ") + " UTC";
    const parisStr = date.toLocaleString("fr-FR", {
      timeZone: "Europe/Paris",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) + " CET/CEST";
    const lines = [
      `Time: ${utcStr}`,
      `      ${parisStr}`,
      `Open:  ${candle.open.toFixed(2)}`,
      `High:  ${candle.high.toFixed(2)}`,
      `Low:   ${candle.low.toFixed(2)}`,
      `Close: ${candle.close.toFixed(2)}`,
      `Vol:   ${candle.volume.toFixed(2)}`
    ];
    const maxWidth = Math.max(...lines.map((l2) => this.overlayCtx.measureText(l2).width));
    const tooltipW = maxWidth + padding * 2;
    const tooltipH = lines.length * lineHeight + padding * 2;
    let x2 = this.state.mouseX + 15;
    let y2 = this.state.mouseY + 15;
    const rect = this.container.getBoundingClientRect();
    if (x2 + tooltipW > rect.width) x2 = this.state.mouseX - tooltipW - 15;
    if (y2 + tooltipH > rect.height) y2 = this.state.mouseY - tooltipH - 15;
    this.overlayCtx.fillStyle = this.theme.tooltipBg;
    this.overlayCtx.strokeStyle = this.theme.tooltipBorder;
    this.overlayCtx.lineWidth = 1;
    this.overlayCtx.fillRect(x2, y2, tooltipW, tooltipH);
    this.overlayCtx.strokeRect(x2, y2, tooltipW, tooltipH);
    this.overlayCtx.fillStyle = this.theme.text;
    this.overlayCtx.font = "11px monospace";
    this.overlayCtx.textAlign = "left";
    this.overlayCtx.textBaseline = "top";
    lines.forEach((line, i2) => {
      this.overlayCtx.fillText(line, x2 + padding, y2 + padding + i2 * lineHeight);
    });
  }
  renderLoading() {
    const rect = this.container.getBoundingClientRect();
    this.mainCtx.clearRect(0, 0, rect.width, rect.height);
    this.mainCtx.fillStyle = this.theme.textLight;
    this.mainCtx.font = "14px sans-serif";
    this.mainCtx.textAlign = "center";
    this.mainCtx.textBaseline = "middle";
    this.mainCtx.fillText("Loading...", rect.width / 2, rect.height / 2);
  }
  renderNoData() {
    const rect = this.container.getBoundingClientRect();
    this.mainCtx.fillStyle = this.theme.textLight;
    this.mainCtx.font = "14px sans-serif";
    this.mainCtx.textAlign = "center";
    this.mainCtx.textBaseline = "middle";
    const message = this.state.isLoading ? "Loading new timeframe..." : "Zoom out to see data";
    this.mainCtx.fillText(message, rect.width / 2, rect.height / 2);
    this.renderTimeAxis(rect.width, rect.height);
  }
  renderError(message) {
    const rect = this.container.getBoundingClientRect();
    this.mainCtx.clearRect(0, 0, rect.width, rect.height);
    this.mainCtx.fillStyle = this.theme.downColor;
    this.mainCtx.font = "14px sans-serif";
    this.mainCtx.textAlign = "center";
    this.mainCtx.textBaseline = "middle";
    this.mainCtx.fillText(`Error: ${message}`, rect.width / 2, rect.height / 2);
  }
  calculatePriceStep(range) {
    const steps = [0.01, 0.05, 0.1, 0.5, 1, 5, 10, 50, 100, 500, 1e3, 5e3, 1e4];
    const targetLines = 8;
    for (const step of steps) {
      if (range / step <= targetLines) return step;
    }
    return steps[steps.length - 1];
  }
  destroy() {
    this.stopRealtimeUpdates();
    this.app.destroy(true, { children: true, texture: true });
    this.overlayCanvas.remove();
    this.legendContainer.remove();
  }
};

// app.ts
var API_BASE = "/api";
var app = {
  chart: null,
  currentPair: null,
  currentTimeframe: "1d",
  isLoading: false,
  availableTimeframes: []
};
document.addEventListener("DOMContentLoaded", async () => {
  console.log("\u{1F680} Initializing Chart Engine v2...");
  initSettingsPanel();
  await initChart();
  await loadPairs();
});
async function initChart() {
  const container = document.getElementById("chart");
  app.chart = await ChartEngine.create(container, {
    onLoadData: async (symbol, timeframe, start, end) => {
      return await fetchCandles(symbol, timeframe, start, end);
    },
    onTimeframeChange: async (newTimeframe, savedRange) => {
      if (app.isLoading) {
        console.log("\u26A0\uFE0F Already loading, ignoring TF change");
        return;
      }
      app.currentTimeframe = newTimeframe;
      updateTimeframeDisplay();
      await loadCandles(savedRange);
    },
    onError: (error) => {
      console.error("Chart error:", error);
      updateStatus(`Error: ${error.message}`, true);
    }
  });
  console.log("\u2705 Chart engine initialized");
}
async function loadPairs() {
  try {
    const response = await fetch(`${API_BASE}/pairs`);
    const pairs = await response.json();
    const selector = document.getElementById("pairSelector");
    selector.innerHTML = '<option value="">Select a pair...</option>';
    const pairsData = {};
    pairs.forEach((pair) => {
      pairsData[pair.symbol] = pair.timeframes;
      const option = document.createElement("option");
      option.value = pair.symbol;
      option.textContent = `${pair.symbol} (${pair.timeframes.join(", ")})`;
      selector.appendChild(option);
    });
    selector.addEventListener("change", async (e2) => {
      app.currentPair = e2.target.value;
      if (app.currentPair) {
        localStorage.setItem("selectedPair", app.currentPair);
        app.availableTimeframes = pairsData[app.currentPair] || [];
        app.chart.setTimeframes(app.availableTimeframes);
        app.currentTimeframe = app.availableTimeframes.includes("1d") ? "1d" : app.availableTimeframes[app.availableTimeframes.length - 1];
        updateTimeframeDisplay();
        await loadCandles();
      }
    });
    const savedPair = localStorage.getItem("selectedPair");
    let initialPair = savedPair && pairsData[savedPair] ? savedPair : pairs.length > 0 ? pairs[0].symbol : null;
    if (initialPair) {
      selector.value = initialPair;
      app.currentPair = initialPair;
      app.availableTimeframes = pairsData[app.currentPair] || [];
      app.chart.setTimeframes(app.availableTimeframes);
      app.currentTimeframe = app.availableTimeframes.includes("1d") ? "1d" : app.availableTimeframes[app.availableTimeframes.length - 1];
      await loadCandles();
      console.log(`\u2705 Loaded ${pairs.length} pairs (selected: ${initialPair})`);
    }
  } catch (error) {
    console.error("Error loading pairs:", error);
    updateStatus("Error loading pairs", true);
  }
}
async function loadCandles(savedRange = null) {
  if (!app.currentPair) return;
  if (app.isLoading) {
    console.log("\u26A0\uFE0F Already loading, skipping...");
    return;
  }
  app.isLoading = true;
  showLoading(true);
  updateStatus("Loading...");
  try {
    await app.chart.loadData(app.currentPair, app.currentTimeframe, savedRange);
    updateStatus("Ready");
  } catch (error) {
    console.error("Error loading candles:", error);
    updateStatus(`Error: ${error.message}`, true);
  } finally {
    app.isLoading = false;
    showLoading(false);
  }
}
async function fetchCandles(symbol, timeframe, start = null, end = null) {
  let url = `${API_BASE}/candles?symbol=${symbol}&timeframe=${timeframe}&limit=5000`;
  if (start !== null) {
    url += `&start=${start}`;
  }
  if (end !== null) {
    url += `&end=${end}`;
  }
  console.log(`\u{1F4E1} Fetching ${symbol} ${timeframe} (${start ? new Date(start * 1e3).toISOString().substring(0, 16) : "auto"} \u2192 ${end ? new Date(end * 1e3).toISOString().substring(0, 16) : "auto"})...`);
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  const candles = await response.json();
  if (!Array.isArray(candles) || candles.length === 0) {
    throw new Error("No data received");
  }
  updateCandleCount(candles.length);
  return candles;
}
function showLoading(show) {
  const el = document.getElementById("loading");
  if (el) el.style.display = show ? "flex" : "none";
}
function updateStatus(message, isError = false) {
  const el = document.getElementById("status");
  if (el) {
    el.textContent = message;
    el.style.color = isError ? "#ef5350" : "";
  }
}
function updateCandleCount(count2) {
  const el = document.getElementById("candleCount");
  if (el) el.textContent = count2.toLocaleString();
}
function updateTimeframeDisplay() {
  const el = document.getElementById("currentTimeframe");
  if (el) el.textContent = app.currentTimeframe;
}
function initSettingsPanel() {
  const panel = document.getElementById("settingsPanel");
  const toggle = document.getElementById("settingsToggle");
  const close = document.getElementById("closeSettings");
  const reset = document.getElementById("resetConfig");
  toggle.addEventListener("click", () => {
    panel.classList.toggle("open");
    toggle.classList.toggle("hidden");
  });
  close.addEventListener("click", () => {
    panel.classList.remove("open");
    toggle.classList.remove("hidden");
  });
  document.addEventListener("click", (e2) => {
    if (panel.classList.contains("open")) {
      const target = e2.target;
      if (!panel.contains(target) && target !== toggle) {
        panel.classList.remove("open");
        toggle.classList.remove("hidden");
      }
    }
  });
  loadSettingsToUI();
  bindSetting("hollowUp", "candles.hollowUp", "checkbox");
  bindSetting("borderWidth", "candles.borderWidth", "range", "borderWidthValue");
  bindSetting("wickWidth", "candles.wickWidth", "range", "wickWidthValue");
  bindSetting("volumeEnabled", "volume.enabled", "checkbox");
  bindSetting("volumeHeight", "volume.heightPercent", "range", "volumeHeightValue");
  bindSetting("watermarkEnabled", "watermark.enabled", "checkbox");
  bindSetting("watermarkOpacity", "watermark.opacity", "range", "watermarkOpacityValue");
  bindSetting("gridHorizontal", "grid.horizontal", "range", "gridHorizontalValue");
  bindSetting("gridOpacity", "grid.opacity", "range", "gridOpacityValue", (v2) => v2 / 100);
  bindSetting("floatingLabels", "crosshair.floatingLabels", "checkbox");
  bindSetting("crosshairStyle", "crosshair.style", "select");
  bindSetting("lastPriceEnabled", "lastPrice.enabled", "checkbox");
  bindSetting("indicatorsEnabled", "indicators.enabled", "checkbox");
  bindSetting("indicatorsHeight", "indicators.heightPercent", "range", "indicatorsHeightValue");
  bindSetting("rsiOverlay", "indicators.rsi.overlay", "checkbox");
  bindSetting("theme", "colors.theme", "select", null, null, applyThemeChange);
  reset.addEventListener("click", () => {
    chartConfig.reset();
    loadSettingsToUI();
    refreshChart();
  });
}
function loadSettingsToUI() {
  document.getElementById("hollowUp").checked = chartConfig.get("candles.hollowUp");
  document.getElementById("borderWidth").value = chartConfig.get("candles.borderWidth");
  document.getElementById("borderWidthValue").textContent = chartConfig.get("candles.borderWidth");
  document.getElementById("wickWidth").value = chartConfig.get("candles.wickWidth");
  document.getElementById("wickWidthValue").textContent = chartConfig.get("candles.wickWidth");
  document.getElementById("volumeEnabled").checked = chartConfig.get("volume.enabled");
  document.getElementById("volumeHeight").value = chartConfig.get("volume.heightPercent");
  document.getElementById("volumeHeightValue").textContent = chartConfig.get("volume.heightPercent");
  document.getElementById("watermarkEnabled").checked = chartConfig.get("watermark.enabled");
  document.getElementById("watermarkOpacity").value = chartConfig.get("watermark.opacity");
  document.getElementById("watermarkOpacityValue").textContent = chartConfig.get("watermark.opacity");
  document.getElementById("gridHorizontal").value = chartConfig.get("grid.horizontal");
  document.getElementById("gridHorizontalValue").textContent = chartConfig.get("grid.horizontal");
  document.getElementById("gridOpacity").value = String(chartConfig.get("grid.opacity") * 100);
  document.getElementById("gridOpacityValue").textContent = String(Math.round(chartConfig.get("grid.opacity") * 100));
  document.getElementById("floatingLabels").checked = chartConfig.get("crosshair.floatingLabels");
  document.getElementById("crosshairStyle").value = chartConfig.get("crosshair.style");
  document.getElementById("lastPriceEnabled").checked = chartConfig.get("lastPrice.enabled");
  document.getElementById("indicatorsEnabled").checked = chartConfig.get("indicators.enabled");
  document.getElementById("indicatorsHeight").value = chartConfig.get("indicators.heightPercent");
  document.getElementById("indicatorsHeightValue").textContent = chartConfig.get("indicators.heightPercent");
  document.getElementById("rsiOverlay").checked = chartConfig.get("indicators.rsi.overlay");
  document.getElementById("theme").value = chartConfig.get("colors.theme");
}
function bindSetting(elementId, configPath, type, valueDisplayId = null, transform = null, callback = null) {
  const element = document.getElementById(elementId);
  element.addEventListener(type === "checkbox" ? "change" : "input", (e2) => {
    let value;
    if (type === "checkbox") {
      value = e2.target.checked;
    } else if (type === "range") {
      value = parseFloat(e2.target.value);
      if (valueDisplayId) {
        document.getElementById(valueDisplayId).textContent = e2.target.value;
      }
      if (transform) value = transform(value);
    } else {
      value = e2.target.value;
    }
    chartConfig.set(configPath, value);
    if (callback) {
      callback(value);
    } else {
      refreshChart();
    }
  });
}
function applyThemeChange(theme) {
  chartConfig.applyTheme(theme);
  const isDark = theme === "dark";
  document.body.style.background = isDark ? "linear-gradient(135deg, #2c3e50 0%, #34495e 100%)" : "linear-gradient(135deg, #667eea 0%, #764ba2 100%)";
  refreshChart();
}
async function refreshChart() {
  if (app.chart && app.currentPair) {
    app.chart.updateTheme();
    await app.chart.loadIndicatorData();
    app.chart.renderBackground();
    app.chart.render();
  }
}
/*! Bundled license information:

tiny-lru/dist/tiny-lru.js:
  (**
   * tiny-lru
   *
   * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 11.4.5
   *)
*/
//# sourceMappingURL=app.js.map
