// ============================================================================
// IMPORTS ET CONFIGURATION
// ============================================================================

// anyhow::Result - Gestion d'erreurs ergonomique en Rust
// Permet de propager les erreurs avec `?` sans d√©finir un type d'erreur explicite
// Alternative √† Result<T, E> quand on n'a pas besoin d'un type d'erreur sp√©cifique
use anyhow::Result;

// Imports de la biblioth√®que binance-rs pour interagir avec l'API Binance
use binance::api::*; // Trait API pour les op√©rations g√©n√©riques
use binance::market::*; // Module Market pour les donn√©es de march√©
use binance::model::KlineSummaries; // Enum qui encapsule les r√©sultats de klines

// chrono - Biblioth√®que de manipulation de dates/temps en Rust
use chrono::{DateTime, NaiveDateTime, Utc};

// clap - Biblioth√®que de parsing d'arguments CLI (Command Line Interface Parser)
// Utilise les macros d√©riv√©es pour g√©n√©rer le code de parsing automatiquement
use clap::Parser;

// rusqlite - Wrapper Rust pour SQLite
// Result as SqlResult: renommage pour √©viter le conflit avec std::Result
// params!: macro pour passer des param√®tres SQL de mani√®re type-safe
use rusqlite::{Connection, Result as SqlResult, params};

use std::path::Path;
use std::thread; // Pour thread::sleep() (mode synchrone, pas tokio)
use std::time::{Duration, SystemTime, UNIX_EPOCH};

// Module de v√©rification d√©fini dans src/verify.rs
mod verify;

// Constantes globales - En Rust, les const sont √©valu√©es √† la compilation
// et peuvent √™tre utilis√©es partout sans overhead runtime
const DB_FILE: &str = "candlesticks.db";
const BATCH_SIZE: usize = 1000; // usize = taille naturelle du CPU (32/64 bits)

// ============================================================================
// STRUCTURES DE DONN√âES
// ============================================================================

/// Structure des arguments CLI g√©n√©r√©e automatiquement par clap
///
/// SUBTILIT√â RUST #1: Derive macros
/// #[derive(Parser)] g√©n√®re automatiquement le code de parsing des arguments
/// C'est un exemple de "programmation g√©n√©rative" √† la compilation
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Le symbole/paire de trading √† r√©cup√©rer (ex: BTCUSDT)
    ///
    /// SUBTILIT√â RUST #2: String vs &str
    /// String = owned (allou√©e sur le heap, mutable)
    /// &str = borrowed (r√©f√©rence, immutable)
    /// Ici on utilise String car on poss√®de la valeur (pas juste une r√©f√©rence)
    #[arg(short, long)]
    symbol: String,

    /// Optionnel: Date de d√©but au format YYYY-MM-DD
    ///
    /// SUBTILIT√â RUST #3: Option<T>
    /// Option est un enum avec deux variantes: Some(T) ou None
    /// Remplace les NULL/nil d'autres langages de mani√®re type-safe
    /// Le compilateur force √† g√©rer les deux cas (pas de NullPointerException!)
    #[arg(short = 'd', long)]
    start_date: Option<String>,

    /// V√©rifier l'espacement des donn√©es apr√®s la r√©cup√©ration
    #[arg(short = 'v', long)]
    verify: bool,

    /// Forcer le retraitement des timeframes d√©j√† marqu√©s comme complets
    ///
    /// USAGE:
    /// Utilisez cette option si vous voulez r√©cup√©rer des donn√©es plus anciennes
    /// que la limite pr√©c√©dente, ou si vous voulez retraiter un timeframe complet
    #[arg(short = 'f', long)]
    force: bool,
}

// ============================================================================
// FONCTION PRINCIPALE
// ============================================================================

/// Point d'entr√©e du programme
///
/// SUBTILIT√â RUST #4: Result<()>
/// () = unit type (√©quivalent √† void)
/// Result<()> signifie "retourne Ok(()) en cas de succ√®s ou Err(e) en cas d'erreur"
/// L'op√©rateur ? propage automatiquement les erreurs vers le haut
fn main() -> Result<()> {
    // Parse les arguments CLI - panique si les arguments sont invalides
    let args = Args::parse();

    // SUBTILIT√â RUST #5: Ownership et clone
    // to_uppercase() consomme args.symbol (ownership move)
    // Mais on a besoin de symbol plusieurs fois, donc on le stocke
    let symbol = args.symbol.to_uppercase();

    // clone() cr√©e une copie profonde - n√©cessaire car println! emprunte temporairement
    // Alternative: utiliser &symbol (mais ici clone est plus lisible)
    println!(
        "D√©marrage de la r√©cup√©ration pour le symbole: {}",
        symbol.clone()
    );

    // SUBTILIT√â RUST #6: mut (mutabilit√©)
    // Par d√©faut, tout est immutable en Rust
    // mut permet de modifier la variable (ici, la connexion DB)
    // ? = op√©rateur de propagation d'erreur (√©quivalent √† un early return si Err)
    let mut conn = setup_database()?;
    println!("Base de donn√©es initialis√©e.");

    // vec! = macro pour cr√©er un Vec<T> (vecteur dynamique sur le heap)
    // &str = string slice (r√©f√©rence immutable vers une cha√Æne)
    let timeframes = vec!["5m", "15m", "30m", "1h"];

    // Binance::new(None, None) = pas de cl√©s API (donn√©es publiques seulement)
    // None = variant de Option<T> qui repr√©sente l'absence de valeur
    let market: Market = Binance::new(None, None);

    // SUBTILIT√â RUST #7: Pattern matching avec match
    // match est exhaustif: le compilateur v√©rifie que tous les cas sont couverts
    // Plus s√ªr que les if/else car impossible d'oublier un cas
    let start_timestamp_ms: Option<i64> = match args.start_date {
        Some(date_str) => {
            // ALGORITHME: Parser la date YYYY-MM-DD et la convertir en timestamp UTC
            // + " 00:00:00" car parse_from_str attend une heure compl√®te
            let naive_date =
                NaiveDateTime::parse_from_str(&(date_str + " 00:00:00"), "%Y-%m-%d %H:%M:%S")?;

            // NaiveDateTime = date sans timezone
            // DateTime<Utc> = date avec timezone UTC
            // Cette conversion est n√©cessaire pour timestamp_millis()
            let datetime_utc = DateTime::<Utc>::from_naive_utc_and_offset(naive_date, Utc);

            // Convertir en timestamp milliseconde (format Binance API)
            Some(datetime_utc.timestamp_millis())
        }
        None => None, // Pas de date de d√©but = r√©cup√©rer toutes les donn√©es
    };

    // SUBTILIT√â RUST #8: It√©ration avec r√©f√©rence (&)
    // &timeframes = it√®re sur des r√©f√©rences (&str) au lieu de consommer le vecteur
    // Sinon, timeframes serait d√©plac√© (moved) et on ne pourrait plus l'utiliser apr√®s
    for tf in &timeframes {
        // ALGORITHME: V√©rifier si le timeframe est d√©j√† complet (sauf si --force)
        // Si is_complete=1 ET que --force n'est pas activ√©, on saute ce timeframe
        if !args.force && is_timeframe_complete(&conn, "binance", &symbol, tf) {
            println!(
                "‚è≠Ô∏è  Timeframe {} d√©j√† complet pour {}. Passage au suivant.",
                tf, symbol
            );
            println!("   (Utilisez --force pour forcer le retraitement)");
            continue;
        }

        if args.force && is_timeframe_complete(&conn, "binance", &symbol, tf) {
            println!(
                "üîÑ Mode --force activ√©: retraitement du timeframe {} pour {}",
                tf, symbol
            );
        }

        println!("R√©cup√©ration pour le timeframe: {}...", tf);

        // SUBTILIT√â RUST #9: Emprunt mutable (&mut)
        // &mut conn = emprunte mutably la connexion (permet de la modifier)
        // &symbol = emprunte immutably le symbol (lecture seule)
        // Rust garantit qu'il n'y a qu'un seul emprunt mutable √† la fois (data race impossible)
        match fetch_and_store_klines(&market, &mut conn, &symbol, tf, start_timestamp_ms) {
            Ok(count) => println!("Termin√© pour {}. {} nouvelles bougies ins√©r√©es.", tf, count),
            Err(e) => eprintln!("Erreur lors de la r√©cup√©ration pour {}: {}", tf, e),
        }
    }

    println!("Toutes les op√©rations sont termin√©es.");

    // ALGORITHME: V√©rification optionnelle de l'int√©grit√© des donn√©es
    if args.verify {
        println!("\n========================================");
        println!("V√âRIFICATION DE L'ESPACEMENT DES DONN√âES");
        println!("========================================");

        // SUBTILIT√â RUST #10: if let - pattern matching simplifi√©
        // √âquivalent √†: match result { Err(e) => ..., Ok(_) => {} }
        for tf in &timeframes {
            if let Err(e) = verify::verify_data_spacing(&conn, "binance", &symbol, tf) {
                eprintln!("Erreur lors de la v√©rification pour {}: {}", tf, e);
            }
        }
    }

    // Ok(()) = succ√®s sans valeur de retour
    // En Rust, la derni√®re expression sans ; est le return implicite
    Ok(())
}

// ============================================================================
// UTILITAIRES DE REPRISE
// ============================================================================

/// R√©cup√®re le timestamp de la derni√®re bougie stock√©e pour un (provider, symbol, timeframe)
///
/// ALGORITHME DE REPRISE:
/// Cette fonction est cruciale pour le mode de reprise. Elle permet de:
/// 1. √âviter de re-t√©l√©charger des donn√©es d√©j√† pr√©sentes en base
/// 2. Reprendre exactement l√† o√π on s'est arr√™t√© en cas d'interruption
/// 3. Optimiser la bande passante en ne r√©cup√©rant que les nouvelles donn√©es
///
/// SUBTILIT√â RUST #13a: Gestion des erreurs SQL avec unwrap_or
/// query_row() peut √©chouer si la table est vide ou n'existe pas
/// unwrap_or(None) transforme une erreur en None (approche pragmatique)
fn get_last_candle_time(
    conn: &Connection,
    provider: &str,
    symbol: &str,
    timeframe: &str,
) -> Option<i64> {
    conn.query_row(
        "SELECT MAX(open_time) FROM candlesticks
         WHERE provider = ?1 AND symbol = ?2 AND timeframe = ?3",
        params![provider, symbol, timeframe],
        |row| row.get(0),
    )
    .unwrap_or(None)
}

// ============================================================================
// GESTION DU STATUT DES TIMEFRAMES
// ============================================================================

/// V√©rifie si un timeframe est marqu√© comme complet
///
/// ALGORITHME:
/// Un timeframe est "complet" quand on a atteint la limite historique de l'API
/// (pas de nouvelles bougies retourn√©es par l'API)
///
/// RETOUR:
/// - true: timeframe d√©j√† complet, pas besoin de le re-traiter
/// - false: timeframe incomplet ou jamais trait√©
fn is_timeframe_complete(conn: &Connection, provider: &str, symbol: &str, timeframe: &str) -> bool {
    conn.query_row(
        "SELECT is_complete FROM timeframe_status
         WHERE provider = ?1 AND symbol = ?2 AND timeframe = ?3",
        params![provider, symbol, timeframe],
        |row| row.get(0),
    )
    .unwrap_or(0)
        == 1
}

/// Marque un timeframe comme complet
///
/// ALGORITHME:
/// Appel√© quand l'API retourne 0 bougies (limite historique atteinte)
/// Permet au programme de sauter ce timeframe lors des prochaines ex√©cutions
///
/// SUBTILIT√â RUST #26: INSERT OR REPLACE
/// Upsert SQLite: ins√®re si n'existe pas, met √† jour si existe
/// Plus simple que INSERT ... ON CONFLICT UPDATE
fn mark_timeframe_complete(
    conn: &Connection,
    provider: &str,
    symbol: &str,
    timeframe: &str,
    oldest_candle_time: Option<i64>,
) -> Result<()> {
    let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_millis() as i64;

    conn.execute(
        "INSERT OR REPLACE INTO timeframe_status
         (provider, symbol, timeframe, oldest_candle_time, is_complete, last_updated)
         VALUES (?1, ?2, ?3, ?4, 1, ?5)",
        params![provider, symbol, timeframe, oldest_candle_time, now],
    )?;

    Ok(())
}

/// Met √† jour la progression d'un timeframe (sans le marquer comme complet)
///
/// ALGORITHME:
/// Appel√© r√©guli√®rement pendant la r√©cup√©ration pour tracker la progression
/// Utile pour le monitoring et le debug
fn update_timeframe_progress(
    conn: &Connection,
    provider: &str,
    symbol: &str,
    timeframe: &str,
    oldest_candle_time: i64,
) -> Result<()> {
    let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_millis() as i64;

    conn.execute(
        "INSERT OR REPLACE INTO timeframe_status
         (provider, symbol, timeframe, oldest_candle_time, is_complete, last_updated)
         VALUES (?1, ?2, ?3, ?4, 0, ?5)",
        params![provider, symbol, timeframe, oldest_candle_time, now],
    )?;

    Ok(())
}

// ============================================================================
// CONFIGURATION BASE DE DONN√âES
// ============================================================================

/// Initialise la connexion √† la base de donn√©es SQLite
///
/// SUBTILIT√â RUST #11: Type alias
/// SqlResult<T> est un alias pour rusqlite::Result<T>
/// Permet d'√©viter la confusion avec std::Result ou anyhow::Result
fn setup_database() -> SqlResult<Connection> {
    // Path::new() cr√©e une r√©f√©rence vers un chemin sans allocation
    // &'static str -> &Path (zero-cost abstraction)
    let path = Path::new(DB_FILE);

    // Connection::open() peut √©chouer (fichier verrouill√©, permissions, etc.)
    // ? propage l'erreur vers le haut si √©chec
    let conn = Connection::open(path)?;

    // ALGORITHME: Sch√©ma de la table avec contrainte d'unicit√©
    // UNIQUE(provider, symbol, timeframe, open_time) √©vite les doublons
    // Permet d'utiliser INSERT OR IGNORE pour l'idempotence
    //
    // CHOIX DE CONCEPTION:
    // - provider: permet de supporter plusieurs exchanges (Binance, Kraken, etc.)
    // - open_time: timestamp en millisecondes (format Binance)
    // - Tous les prix en REAL (f64) pour la pr√©cision
    conn.execute(
        "CREATE TABLE IF NOT EXISTS candlesticks (
            provider TEXT NOT NULL,
            symbol TEXT NOT NULL,
            timeframe TEXT NOT NULL,
            open_time INTEGER NOT NULL,
            open REAL NOT NULL,
            high REAL NOT NULL,
            low REAL NOT NULL,
            close REAL NOT NULL,
            volume REAL NOT NULL,
            close_time INTEGER NOT NULL,
            quote_asset_volume REAL NOT NULL,
            number_of_trades INTEGER NOT NULL,
            taker_buy_base_asset_volume REAL NOT NULL,
            taker_buy_quote_asset_volume REAL NOT NULL,
            interpolated INTEGER NOT NULL DEFAULT 0,
            UNIQUE(provider, symbol, timeframe, open_time)
        )",
        [], // Pas de param√®tres pour cette requ√™te
    )?;

    // ALGORITHME: Table de statut pour tracker la compl√©tion des timeframes
    // Cette table r√©sout le probl√®me de boucle infinie quand on atteint la limite historique
    //
    // PROBL√àME R√âSOLU:
    // Sans cette table, quand l'API Binance retourne 0 bougies (limite historique atteinte),
    // le programme continue de boucler sur le m√™me timeframe au lieu de passer au suivant
    //
    // SOLUTION:
    // - is_complete=1: le timeframe a √©t√© enti√®rement r√©cup√©r√© jusqu'√† la limite historique
    // - oldest_candle_time: timestamp de la bougie la plus ancienne r√©cup√©r√©e
    // - last_updated: timestamp de la derni√®re mise √† jour (pour d√©bug/monitoring)
    conn.execute(
        "CREATE TABLE IF NOT EXISTS timeframe_status (
            provider TEXT NOT NULL,
            symbol TEXT NOT NULL,
            timeframe TEXT NOT NULL,
            oldest_candle_time INTEGER,
            is_complete INTEGER NOT NULL DEFAULT 0,
            last_updated INTEGER NOT NULL,
            PRIMARY KEY (provider, symbol, timeframe)
        )",
        [],
    )?;

    // SUBTILIT√â RUST #12: Move s√©mantic
    // conn est "d√©plac√©" (moved) dans le Ok()
    // Apr√®s cette ligne, conn n'est plus accessible dans cette fonction
    // C'est le transfert d'ownership vers l'appelant
    Ok(conn)
}

// ============================================================================
// R√âCUP√âRATION ET STOCKAGE DES DONN√âES (C≈íUR DE L'ALGORITHME)
// ============================================================================

/// R√©cup√®re et stocke les bougies (candlesticks) depuis l'API Binance
///
/// ALGORITHME: R√©cup√©ration par batch en remontant dans le temps
/// 1. D√©marre √† now() et r√©cup√®re 1000 bougies vers le pass√©
/// 2. Identifie la bougie la plus ancienne du batch
/// 3. R√©p√®te en utilisant cette bougie comme nouvelle fin
/// 4. Continue jusqu'√† atteindre start_date ou fin des donn√©es
/// 5. Comble automatiquement les trous avec interpolation lin√©aire
///
/// SUBTILIT√â RUST #13: Signatures de fonction avec lifetime implicites
/// &Market, &str = emprunts immutables (lecture seule)
/// &mut Connection = emprunt mutable (permet modification)
/// Les lifetimes sont inf√©r√©s automatiquement par le compilateur
fn fetch_and_store_klines(
    market: &Market,
    conn: &mut Connection,
    symbol: &str,
    timeframe: &str,
    start_timestamp_ms: Option<i64>,
) -> Result<i64> {
    // Compteur de bougies ins√©r√©es (incluant les interpol√©es)
    // i64 car peut √™tre tr√®s grand pour des r√©cup√©rations longues
    let mut total_inserted = 0i64;

    // ALGORITHME DE REPRISE: D√©termination du point de d√©part intelligent
    //
    // Strat√©gie en 3 √©tapes:
    // 1. V√©rifier si des donn√©es existent d√©j√† pour ce (provider, symbol, timeframe)
    // 2. Si OUI ‚Üí reprendre depuis la derni√®re bougie stock√©e (mode REPRISE)
    // 3. Si NON ‚Üí partir de maintenant et remonter (mode PREMI√àRE EX√âCUTION)
    //
    // AVANTAGES:
    // - √âvite de re-t√©l√©charger des donn√©es d√©j√† pr√©sentes
    // - Permet de reprendre apr√®s une interruption (panne, Ctrl+C, etc.)
    // - √âconomise la bande passante et respecte les rate limits de l'API
    //
    // SUBTILIT√â RUST #14: Utilisation de la fonction d√©di√©e
    let last_stored_open_time = get_last_candle_time(conn, "binance", symbol, timeframe);

    let mut end_time_ms: i64;

    match last_stored_open_time {
        Some(last_time) => {
            // MODE REPRISE: on a d√©j√† des donn√©es
            end_time_ms = last_time;

            println!("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            println!("‚ïë MODE REPRISE ACTIV√â");
            println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            println!("‚ïë Provider: binance");
            println!("‚ïë Symbole: {}", symbol);
            println!("‚ïë Timeframe: {}", timeframe);
            println!(
                "‚ïë Derni√®re bougie en base: {}",
                format_timestamp_ms(last_time)
            );
            println!("‚ïë R√©cup√©ration: depuis cette date vers le pass√©");

            if let Some(start_ts) = start_timestamp_ms {
                println!(
                    "‚ïë Limite de r√©cup√©ration: {}",
                    format_timestamp_ms(start_ts)
                );
            } else {
                println!("‚ïë Limite de r√©cup√©ration: toutes les donn√©es disponibles");
            }
            println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        }
        None => {
            // MODE PREMI√àRE EX√âCUTION: aucune donn√©e existante
            end_time_ms = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .expect("Time went backwards")
                .as_millis() as i64;

            println!("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            println!("‚ïë MODE PREMI√àRE EX√âCUTION");
            println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            println!("‚ïë Provider: binance");
            println!("‚ïë Symbole: {}", symbol);
            println!("‚ïë Timeframe: {}", timeframe);
            println!("‚ïë Aucune donn√©e existante pour cette combinaison");
            println!("‚ïë D√©marrage: {}", format_timestamp_ms(end_time_ms));

            if let Some(start_ts) = start_timestamp_ms {
                println!("‚ïë R√©cup√©ration jusqu'√†: {}", format_timestamp_ms(start_ts));
            } else {
                println!("‚ïë R√©cup√©ration: toutes les donn√©es historiques disponibles");
            }
            println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        }
    }

    // ALGORITHME: Boucle principale de r√©cup√©ration
    // Continue jusqu'√† ce qu'on atteigne:
    // - La date de d√©but demand√©e (start_date)
    // - La fin des donn√©es disponibles sur Binance
    // - Une erreur non-r√©cup√©rable
    loop {
        println!(
            "Fetching {} klines ending before {}",
            BATCH_SIZE,
            format_timestamp_ms(end_time_ms)
        );

        // Utiliser l'appel get_klines qui prend un endTime optionnel
        let klines_data = match market
            .get_klines(symbol, timeframe, Some(BATCH_SIZE as u16), None, Some(end_time_ms as u64)) // startTime=None, endTime=Some(end_time_ms)
        {
            Ok(klines) => klines,
            Err(e) => {
                eprintln!("Erreur API Binance: {}", e);
                // Attendre avant de r√©essayer ?
                thread::sleep(Duration::from_secs(5));
                continue; // Tente de refaire la m√™me requ√™te apr√®s une pause
            }
        };

        // Extract the actual Vec from the enum
        let klines = match klines_data {
            KlineSummaries::AllKlineSummaries(vec) => vec,
        };

        if klines.len() == 0 {
            println!(
                "Aucune bougie suppl√©mentaire retourn√©e par l'API. Arr√™t pour {}/{}.",
                symbol, timeframe
            );

            // ALGORITHME: Marquer le timeframe comme complet
            // On a atteint la limite historique de l'API Binance
            // Lors de la prochaine ex√©cution, ce timeframe sera saut√©
            let oldest_time = get_last_candle_time(conn, "binance", symbol, timeframe);
            if let Err(e) = mark_timeframe_complete(conn, "binance", symbol, timeframe, oldest_time)
            {
                eprintln!(
                    "‚ö†Ô∏è  Erreur lors du marquage du timeframe comme complet: {}",
                    e
                );
            } else {
                println!(
                    "‚úÖ Timeframe {}/{} marqu√© comme complet (limite historique atteinte)",
                    symbol, timeframe
                );
            }

            break;
        }

        let oldest_kline_time = klines[0].open_time;

        let tx = conn.transaction()?;
        let mut inserted_in_batch = 0;
        {
            // Pr√©parer le statement une fois pour le batch
            let mut stmt = tx.prepare(
                "INSERT OR IGNORE INTO candlesticks (
                    provider, symbol, timeframe, open_time, open, high, low, close, volume,
                    close_time, quote_asset_volume, number_of_trades,
                    taker_buy_base_asset_volume, taker_buy_quote_asset_volume, interpolated
                ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15)",
            )?;

            for kline in &klines {
                // Kline est maintenant une structure, acc√©dons aux champs
                // interpolated = 0 car ce sont des donn√©es r√©elles de l'API
                let changes = stmt.execute(params![
                    "binance",
                    symbol,
                    timeframe,
                    kline.open_time,
                    kline.open.parse::<f64>().unwrap_or(0.0), // Parser les String en f64
                    kline.high.parse::<f64>().unwrap_or(0.0),
                    kline.low.parse::<f64>().unwrap_or(0.0),
                    kline.close.parse::<f64>().unwrap_or(0.0),
                    kline.volume.parse::<f64>().unwrap_or(0.0),
                    kline.close_time,
                    kline.quote_asset_volume.parse::<f64>().unwrap_or(0.0),
                    kline.number_of_trades,
                    kline
                        .taker_buy_base_asset_volume
                        .parse::<f64>()
                        .unwrap_or(0.0),
                    kline
                        .taker_buy_quote_asset_volume
                        .parse::<f64>()
                        .unwrap_or(0.0),
                    0, // interpolated = 0 (donn√©es r√©elles)
                ])?;
                if changes > 0 {
                    inserted_in_batch += 1;
                }
            }
        } // stmt est lib√©r√© ici
        tx.commit()?;

        total_inserted += inserted_in_batch;
        println!(
            "Batch trait√© pour {}/{}. {} nouvelles bougies ins√©r√©es. Bougie la plus ancienne: {}",
            symbol,
            timeframe,
            inserted_in_batch,
            format_timestamp_ms(oldest_kline_time)
        );

        // ALGORITHME: Mettre √† jour la progression du timeframe
        // Permet de tracker o√π on en est dans la r√©cup√©ration historique
        if let Err(e) =
            update_timeframe_progress(conn, "binance", symbol, timeframe, oldest_kline_time)
        {
            eprintln!("‚ö†Ô∏è  Erreur lors de la mise √† jour de la progression: {}", e);
        }

        // Combler les trous dans le batch qui vient d'√™tre ins√©r√©
        let filled = fill_gaps_in_range(
            conn,
            "binance",
            symbol,
            timeframe,
            oldest_kline_time,
            end_time_ms,
        )?;
        if filled > 0 {
            println!("  ‚Üí {} bougies interpol√©es pour combler les trous", filled);
            total_inserted += filled;
        }

        // Pr√©parer pour le prochain batch en remontant le temps
        // On met endTime juste avant l'ouverture de la bougie la plus ancienne de ce batch
        end_time_ms = oldest_kline_time; // Utiliser directement open_time pour la prochaine requ√™te

        // V√©rifier si on a atteint ou d√©pass√© la date de d√©but demand√©e
        if let Some(start_ts) = start_timestamp_ms {
            if oldest_kline_time <= start_ts {
                println!(
                    "Date de d√©but ({}) atteinte ou d√©pass√©e. Arr√™t pour {}/{}.",
                    format_timestamp_ms(start_ts),
                    symbol,
                    timeframe
                );

                // ALGORITHME: Marquer le timeframe comme complet
                // On a r√©cup√©r√© jusqu'√† la date demand√©e par l'utilisateur
                // Lors de la prochaine ex√©cution avec la m√™me date limite (ou sans limite),
                // ce timeframe sera saut√©
                let oldest_time = get_last_candle_time(conn, "binance", symbol, timeframe);
                if let Err(e) =
                    mark_timeframe_complete(conn, "binance", symbol, timeframe, oldest_time)
                {
                    eprintln!(
                        "‚ö†Ô∏è  Erreur lors du marquage du timeframe comme complet: {}",
                        e
                    );
                } else {
                    println!(
                        "‚úÖ Timeframe {}/{} marqu√© comme complet (date limite atteinte)",
                        symbol, timeframe
                    );
                }

                break;
            }
        }

        // Petite pause pour respecter les limites de l'API Binance
        thread::sleep(Duration::from_millis(10 * 500));
    }

    Ok(total_inserted)
}

// ============================================================================
// INTERPOLATION LIN√âAIRE DES TROUS
// ============================================================================

/// Comble les trous dans une plage de donn√©es avec interpolation lin√©aire
///
/// ALGORITHME D'INTERPOLATION:
/// 1. R√©cup√®re toutes les bougies existantes dans la plage [start_time, end_time]
/// 2. Parcourt les bougies paire par paire (fen√™tre glissante)
/// 3. Si intervalle > intervalle_attendu ‚Üí GAP d√©tect√©
/// 4. Calcule le nombre de bougies manquantes: (gap / intervalle) - 1
/// 5. Pour chaque bougie manquante:
///    - Calcule un ratio de position: i / (n+1)
///    - Interpole lin√©airement tous les champs: valeur = A + (B-A) √ó ratio
/// 6. Ins√®re les bougies interpol√©es avec INSERT OR IGNORE
///
/// EXEMPLE: Gap entre t=0 (close=100) et t=1500 (close=150) avec timeframe=5m (300ms)
/// ‚Üí 4 bougies manquantes (t=300, 600, 900, 1200)
/// ‚Üí Bougie #1 (ratio=1/5=0.2): close = 100 + (150-100)√ó0.2 = 110
/// ‚Üí Bougie #2 (ratio=2/5=0.4): close = 100 + (150-100)√ó0.4 = 120
/// ‚Üí etc.
///
/// JUSTIFICATION: Pourquoi interpolation lin√©aire?
/// - Simple et rapide √† calculer
/// - Acceptable pour petits gaps (quelques bougies)
/// - Meilleure que laisser des trous (√©vite erreurs dans analyses temporelles)
/// - Les donn√©es interpol√©es sont continues et monotones
fn fill_gaps_in_range(
    conn: &mut Connection,
    provider: &str,
    symbol: &str,
    timeframe: &str,
    start_time: i64,
    end_time: i64,
) -> Result<i64> {
    // SUBTILIT√â RUST #15: Match exhaustif avec pattern guard
    // Le _ (underscore) = catch-all pattern pour tous les autres cas
    // Ici utilis√© pour les timeframes non reconnus
    let expected_interval_ms = match timeframe {
        "1m" => 60_000,
        "3m" => 180_000,
        "5m" => 300_000,
        "15m" => 900_000,
        "30m" => 1_800_000,
        "1h" => 3_600_000,
        "2h" => 7_200_000,
        "4h" => 14_400_000,
        "6h" => 21_600_000,
        "8h" => 28_800_000,
        "12h" => 43_200_000,
        "1d" => 86_400_000,
        "3d" => 259_200_000,
        "1w" => 604_800_000,
        "1M" => 2_592_000_000,
        _ => return Ok(0),
    };

    // R√©cup√©rer toutes les bougies dans la plage, tri√©es par date
    let mut stmt = conn.prepare(
        "SELECT open_time, open, high, low, close, volume, close_time,
                quote_asset_volume, number_of_trades,
                taker_buy_base_asset_volume, taker_buy_quote_asset_volume
         FROM candlesticks
         WHERE provider = ?1 AND symbol = ?2 AND timeframe = ?3
           AND open_time >= ?4 AND open_time <= ?5
         ORDER BY open_time ASC",
    )?;

    let mut rows = stmt.query(params![provider, symbol, timeframe, start_time, end_time])?;

    // SUBTILIT√â RUST #16: Struct locale pour typage fort
    // On d√©finit une struct locale plut√¥t que d'utiliser des tuples
    // Avantages: nommage des champs, auto-documentation, type-safety
    //
    // #[derive(Debug)] = g√©n√®re automatiquement l'impl√©mentation de Debug
    // #[allow(dead_code)] = d√©sactive le warning pour close_time (lu mais non utilis√© directement)
    #[derive(Debug)]
    #[allow(dead_code)]
    struct Candle {
        open_time: i64,
        open: f64,
        high: f64,
        low: f64,
        close: f64,
        volume: f64,
        close_time: i64,
        quote_asset_volume: f64,
        number_of_trades: i64,
        taker_buy_base_asset_volume: f64,
        taker_buy_quote_asset_volume: f64,
    }

    let mut candles: Vec<Candle> = Vec::new();
    while let Some(row) = rows.next()? {
        candles.push(Candle {
            open_time: row.get(0)?,
            open: row.get(1)?,
            high: row.get(2)?,
            low: row.get(3)?,
            close: row.get(4)?,
            volume: row.get(5)?,
            close_time: row.get(6)?,
            quote_asset_volume: row.get(7)?,
            number_of_trades: row.get(8)?,
            taker_buy_base_asset_volume: row.get(9)?,
            taker_buy_quote_asset_volume: row.get(10)?,
        });
    }
    drop(rows);
    drop(stmt);

    if candles.len() < 2 {
        return Ok(0); // Pas assez de donn√©es pour interpoler
    }

    let mut total_filled = 0i64;
    let tx = conn.transaction()?;

    {
        let mut insert_stmt = tx.prepare(
            "INSERT OR IGNORE INTO candlesticks (
                provider, symbol, timeframe, open_time, open, high, low, close, volume,
                close_time, quote_asset_volume, number_of_trades,
                taker_buy_base_asset_volume, taker_buy_quote_asset_volume, interpolated
            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15)",
        )?;

        for i in 0..candles.len() - 1 {
            let current = &candles[i];
            let next = &candles[i + 1];

            let time_diff = next.open_time - current.open_time;

            // Si il y a un gap
            if time_diff > expected_interval_ms {
                let missing_candles = (time_diff / expected_interval_ms) - 1;

                // Interpoler lin√©airement pour chaque bougie manquante
                for j in 1..=missing_candles {
                    let ratio = j as f64 / (missing_candles + 1) as f64;
                    let interpolated_time = current.open_time + (j * expected_interval_ms);

                    // Interpolation lin√©aire pour tous les champs
                    let interpolated_open = current.open + (next.open - current.open) * ratio;
                    let interpolated_high = current.high + (next.high - current.high) * ratio;
                    let interpolated_low = current.low + (next.low - current.low) * ratio;
                    let interpolated_close = current.close + (next.close - current.close) * ratio;
                    let interpolated_volume =
                        current.volume + (next.volume - current.volume) * ratio;
                    let interpolated_close_time = interpolated_time + expected_interval_ms - 1;
                    let interpolated_quote_volume = current.quote_asset_volume
                        + (next.quote_asset_volume - current.quote_asset_volume) * ratio;
                    let interpolated_trades = (current.number_of_trades as f64
                        + (next.number_of_trades as f64 - current.number_of_trades as f64) * ratio)
                        as i64;
                    let interpolated_taker_base = current.taker_buy_base_asset_volume
                        + (next.taker_buy_base_asset_volume - current.taker_buy_base_asset_volume)
                            * ratio;
                    let interpolated_taker_quote = current.taker_buy_quote_asset_volume
                        + (next.taker_buy_quote_asset_volume
                            - current.taker_buy_quote_asset_volume)
                            * ratio;

                    // MARQUAGE: interpolated = 1 pour identifier les donn√©es g√©n√©r√©es
                    let changes = insert_stmt.execute(params![
                        provider,
                        symbol,
                        timeframe,
                        interpolated_time,
                        interpolated_open,
                        interpolated_high,
                        interpolated_low,
                        interpolated_close,
                        interpolated_volume,
                        interpolated_close_time,
                        interpolated_quote_volume,
                        interpolated_trades,
                        interpolated_taker_base,
                        interpolated_taker_quote,
                        1, // interpolated = 1 (donn√©es interpol√©es)
                    ])?;

                    if changes > 0 {
                        total_filled += 1;
                    }
                }
            }
        }
    }

    tx.commit()?;
    Ok(total_filled)
}

// Fonction utilitaire pour afficher les timestamps
fn format_timestamp_ms(timestamp_ms: i64) -> String {
    // Cr√©e un DateTime √† partir du timestamp Unix en millisecondes
    if let Some(datetime_utc) = DateTime::<Utc>::from_timestamp_millis(timestamp_ms) {
        // Formate la date et l'heure
        datetime_utc.format("%Y-%m-%d %H:%M:%S").to_string()
    } else {
        "Invalid timestamp".to_string()
    }
}
